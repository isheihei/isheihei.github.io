<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Java on isheihei&#39;s blog</title>
        <link>https://isheihei.github.io/tags/java/</link>
        <description>Recent content in Java on isheihei&#39;s blog</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <lastBuildDate>Tue, 24 May 2022 17:24:10 +0800</lastBuildDate><atom:link href="https://isheihei.github.io/tags/java/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>JVM 垃圾回收</title>
        <link>https://isheihei.github.io/posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/</link>
        <pubDate>Tue, 24 May 2022 17:24:10 +0800</pubDate>
        
        <guid>https://isheihei.github.io/posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/</guid>
        <description>&lt;h2 id=&#34;可达性分析&#34;&gt;可达性分析&lt;/h2&gt;
&lt;h3 id=&#34;gc-roots&#34;&gt;GC Roots&lt;/h3&gt;
&lt;p&gt;可达性分析算法：也可以称为根搜索算法、追踪性垃圾收集&lt;/p&gt;
&lt;p&gt;GC Roots 对象：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;虚拟机栈中局部变量表中引用的对象：各个线程被调用的方法中使用到的参数、局部变量等&lt;/li&gt;
&lt;li&gt;本地方法栈中引用的对象&lt;/li&gt;
&lt;li&gt;堆中类静态属性引用的对象&lt;/li&gt;
&lt;li&gt;方法区中的常量引用的对象&lt;/li&gt;
&lt;li&gt;字符串常量池（string Table）里的引用&lt;/li&gt;
&lt;li&gt;同步锁 synchronized 持有的对象&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;GC Roots 是一组活跃的引用，不是对象&lt;/strong&gt;，放在 GC Roots Set 集合&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;工作原理&#34;&gt;工作原理&lt;/h3&gt;
&lt;p&gt;可达性分析算法以根对象集合（GCRoots）为起始点，从上至下的方式搜索被根对象集合所连接的目标对象&lt;/p&gt;
&lt;p&gt;分析工作必须在一个保障&lt;strong&gt;一致性的快照&lt;/strong&gt;中进行，否则结果的准确性无法保证，这也是导致 GC 进行时必须 Stop The World 的一个原因&lt;/p&gt;
&lt;p&gt;基本原理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索走过的路径称为引用链&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;三色标记&#34;&gt;三色标记&lt;/h3&gt;
&lt;h3 id=&#34;标记算法&#34;&gt;标记算法&lt;/h3&gt;
&lt;p&gt;三色标记法把遍历对象图过程中遇到的对象，标记成以下三种颜色：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;白色：尚未访问过&lt;/li&gt;
&lt;li&gt;灰色：本对象已访问过，但是本对象引用到的其他对象尚未全部访问&lt;/li&gt;
&lt;li&gt;黑色：本对象已访问过，而且本对象引用到的其他对象也全部访问完成&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当 Stop The World (STW) 时，对象间的引用是不会发生变化的，可以轻松完成标记，遍历访问过程为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;初始时，所有对象都在白色集合&lt;/li&gt;
&lt;li&gt;将 GC Roots 直接引用到的对象挪到灰色集合&lt;/li&gt;
&lt;li&gt;从灰色集合中获取对象：
&lt;ul&gt;
&lt;li&gt;将本对象引用到的其他对象全部挪到灰色集合中&lt;/li&gt;
&lt;li&gt;将本对象挪到黑色集合里面&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;重复步骤 3，直至灰色集合为空时结束&lt;/li&gt;
&lt;li&gt;结束后，仍在白色集合的对象即为 GC Roots 不可达，可以进行回收&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/JVM-%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95%E8%BF%87%E7%A8%8B.gif&#34;
	width=&#34;706&#34;
	height=&#34;451&#34;
	srcset=&#34;https://isheihei.github.io/posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/JVM-%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95%E8%BF%87%E7%A8%8B_hud33a6cf6e4a2927aebe73fd8a24ced0d_152861_480x0_resize_box.gif 480w, https://isheihei.github.io/posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/JVM-%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95%E8%BF%87%E7%A8%8B_hud33a6cf6e4a2927aebe73fd8a24ced0d_152861_1024x0_resize_box.gif 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;JVM-三色标记法过程&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;156&#34;
		data-flex-basis=&#34;375px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;参考文章：https://www.jianshu.com/p/12544c0ad5c1&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;并发标记&#34;&gt;并发标记&lt;/h3&gt;
&lt;p&gt;并发标记时，对象间的引用可能发生变化，多标和漏标的情况就有可能发生&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多标情况：&lt;strong&gt;当 E 变为灰色或黑色时，其他线程断开的 D 对 E 的引用，导致这部分对象仍会被标记为存活，本轮 GC 不会回收这部分内存，这部分本应该回收但是没有回收到的内存，被称之为&lt;/strong&gt;浮动垃圾&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;针对并发标记开始后的&lt;strong&gt;新对象&lt;/strong&gt;，通常的做法是直接全部当成黑色，也算浮动垃圾&lt;/li&gt;
&lt;li&gt;浮动垃圾并不会影响应用程序的正确性，只是需要等到下一轮垃圾回收中才被清除&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/JVM-%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95%E5%A4%9A%E6%A0%87%E6%83%85%E5%86%B5.png&#34;
	width=&#34;683&#34;
	height=&#34;420&#34;
	srcset=&#34;https://isheihei.github.io/posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/JVM-%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95%E5%A4%9A%E6%A0%87%E6%83%85%E5%86%B5_hu693bfcae16628182766291aa82f4317e_13278_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/JVM-%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95%E5%A4%9A%E6%A0%87%E6%83%85%E5%86%B5_hu693bfcae16628182766291aa82f4317e_13278_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;JVM-三色标记法多标情况&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;162&#34;
		data-flex-basis=&#34;390px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;漏标情况：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;条件一：灰色对象断开了对一个白色对象的引用（直接或间接），即灰色对象原成员变量的引用发生了变化&lt;/li&gt;
&lt;li&gt;条件二：其他线程中修改了黑色对象，插入了一条或多条对该白色对象的新引用&lt;/li&gt;
&lt;li&gt;结果：导致该白色对象当作垃圾被 GC，影响到了程序的正确性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/JVM-%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95%E6%BC%8F%E6%A0%87%E6%83%85%E5%86%B5.png&#34;
	width=&#34;689&#34;
	height=&#34;432&#34;
	srcset=&#34;https://isheihei.github.io/posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/JVM-%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95%E6%BC%8F%E6%A0%87%E6%83%85%E5%86%B5_hub7806eff3b888461f9e8c79abec69ead_14122_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/JVM-%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95%E6%BC%8F%E6%A0%87%E6%83%85%E5%86%B5_hub7806eff3b888461f9e8c79abec69ead_14122_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;JVM-三色标记法漏标情况&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;159&#34;
		data-flex-basis=&#34;382px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;代码角度解释漏标：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;Object&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;G&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;objE&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;fieldG&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 读
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;objE&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;fieldG&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;  	&lt;span class=&#34;c1&#34;&gt;// 写
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;objD&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;fieldG&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;G&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;     	&lt;span class=&#34;c1&#34;&gt;// 写
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;为了解决问题，可以操作上面三步，&lt;strong&gt;将对象 G 记录起来，然后作为灰色对象再进行遍历&lt;/strong&gt;，比如放到一个特定的集合，等初始的 GC Roots 遍历完（并发标记），再遍历该集合（重新标记）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;所以&lt;strong&gt;重新标记需要 STW&lt;/strong&gt;，应用程序一直在运行，该集合可能会一直增加新的对象，导致永远都运行不完&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;解决方法：添加读写屏障，读屏障拦截第一步，写屏障拦截第二三步，在读写前后进行一些后置处理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;写屏障 + 增量更新&lt;/strong&gt;：黑色对象新增引用，会将黑色对象变成灰色对象，最后对该节点重新扫描&lt;/p&gt;
&lt;p&gt;增量更新 (Incremental Update) 破坏了条件二，从而保证了不会漏标&lt;/p&gt;
&lt;p&gt;缺点：对黑色变灰的对象重新扫描所有引用，比较耗费时间&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;写屏障 (Store Barrier) + SATB&lt;/strong&gt;：当原来成员变量的引用发生变化之前，记录下原来的引用对象&lt;/p&gt;
&lt;p&gt;保留 GC 开始时的对象图，即原始快照 SATB，当 GC Roots 确定后，对象图就已经确定，那后续的标记也应该是按照这个时刻的对象图走，如果期间对白色对象有了新的引用会记录下来，并且将白色对象变灰（说明可达了），重新扫描该对象的引用关系&lt;/p&gt;
&lt;p&gt;SATB (Snapshot At The Beginning) 破坏了条件一，从而保证了不会漏标&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;读屏障 (Load Barrier)&lt;/strong&gt;：破坏条件二，黑色对象引用白色对象的前提是获取到该对象，此时读屏障发挥作用&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以 Java HotSpot VM 为例，其并发标记时对漏标的处理方案如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CMS：写屏障 + 增量更新&lt;/li&gt;
&lt;li&gt;G1：写屏障 + SATB&lt;/li&gt;
&lt;li&gt;ZGC：读屏障&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;垃圾回收器&#34;&gt;垃圾回收器&lt;/h2&gt;
&lt;h3 id=&#34;普通&#34;&gt;普通&lt;/h3&gt;
&lt;h4 id=&#34;serial&#34;&gt;Serial&lt;/h4&gt;
&lt;p&gt;Serial：串行垃圾收集器，作用于新生代，是指使用单线程进行垃圾回收，采用&lt;strong&gt;复制算法&lt;/strong&gt;，新生代基本都是复制算法，因为分区了&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;STW（Stop-The-World）&lt;/strong&gt;：垃圾回收时，只有一个线程在工作，并且 Java 应用中的所有线程都要暂停，等待垃圾回收的完成&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Serial old&lt;/strong&gt;：执行老年代垃圾回收的串行收集器，内存回收算法使用的是&lt;strong&gt;标记-整理算法&lt;/strong&gt;，同样也采用了串行回收和 STW 机制&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Serial old 是 Client 模式下默认的老年代的垃圾回收器&lt;/li&gt;
&lt;li&gt;Serial old 在 Server 模式下主要有两个用途：
&lt;ul&gt;
&lt;li&gt;在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用&lt;/li&gt;
&lt;li&gt;作为老年代 CMS 收集器的&lt;strong&gt;后备垃圾回收方案&lt;/strong&gt;，在并发收集发生 Concurrent Mode Failure 时使用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;开启参数：&lt;code&gt;-XX:+UseSerialGC&lt;/code&gt; 等价于新生代用 Serial GC 且老年代用 Serial old GC&lt;/p&gt;
&lt;p&gt;优点：简单而高效（与其他收集器的单线程比），对于限定单个 CPU 的环境来说，Serial 收集器由于没有线程交互的开销，可以获得最高的单线程收集效率&lt;/p&gt;
&lt;p&gt;缺点：对于交互性较强的应用而言，这种垃圾收集器是不能够接受的，比如 JavaWeb 应用&lt;/p&gt;
&lt;h4 id=&#34;parnew&#34;&gt;ParNew&lt;/h4&gt;
&lt;p&gt;Par 是 Parallel 并行的缩写，&lt;strong&gt;New 是只能处理的是新生代&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;并行垃圾收集器在串行垃圾收集器的基础之上做了改进，&lt;strong&gt;采用复制算法&lt;/strong&gt;，将单线程改为了多线程进行垃圾回收，可以缩短垃圾回收的时间&lt;/p&gt;
&lt;p&gt;对于其他的行为（收集算法、stop the world、对象分配规则、回收策略等）同 Serial 收集器一样，应用在年轻代，除 Serial 外，只有&lt;strong&gt;ParNew GC 能与 CMS 收集器配合工作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;相关参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-XX：+UseParNewGC&lt;/code&gt;：表示年轻代使用并行收集器，不影响老年代&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-XX:ParallelGCThreads&lt;/code&gt;：默认开启和 CPU 数量相同的线程数&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ParNew 是很多 JVM 运行在 Server 模式下新生代的默认垃圾收集器&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于新生代，回收次数频繁，使用并行方式高效&lt;/li&gt;
&lt;li&gt;对于老年代，回收次数少，使用串行方式节省资源（CPU 并行需要切换线程，串行可以省去切换线程的资源）&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;parallel&#34;&gt;Parallel&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Parallel Scavenge&lt;/strong&gt; 收集器是应用于新生代的并行垃圾回收器，&lt;strong&gt;采用复制算法&lt;/strong&gt;、并行回收和 Stop the World 机制&lt;/p&gt;
&lt;p&gt;**Parallel Old ** 收集器：是一个应用于老年代的并行垃圾回收器，&lt;strong&gt;采用标记-整理算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对比其他回收器：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;其它收集器目标是尽可能缩短垃圾收集时用户线程的停顿时间&lt;/li&gt;
&lt;li&gt;Parallel 目标是达到一个可控制的吞吐量，被称为&lt;strong&gt;吞吐量优先&lt;/strong&gt;收集器&lt;/li&gt;
&lt;li&gt;Parallel Scavenge 对比 ParNew 拥有&lt;strong&gt;自适应调节策略&lt;/strong&gt;，可以通过一个开关参数打开 GC Ergonomics&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;应用场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验&lt;/li&gt;
&lt;li&gt;高吞吐量可以高效率地利用 CPU 时间，尽快完成程序的运算任务，适合在后台运算而不需要太多交互&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;停顿时间和吞吐量的关系：新生代空间变小 → 缩短停顿时间 → 垃圾回收变得频繁 → 导致吞吐量下降&lt;/p&gt;
&lt;p&gt;在注重吞吐量及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge + Parallel Old 收集器，在 Server 模式下的内存回收性能很好，&lt;strong&gt;Java8 默认是此垃圾收集器组合&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;参数配置：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-XX：+UseParallelGC&lt;/code&gt;：手动指定年轻代使用 Paralle 并行收集器执行内存回收任务&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-XX：+UseParalleloldcc&lt;/code&gt;：手动指定老年代使用并行回收收集器执行内存回收任务
&lt;ul&gt;
&lt;li&gt;上面两个参数，默认开启一个，另一个也会被开启（互相激活），默认 JDK8 是开启的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-XX:+UseAdaptivesizepplicy&lt;/code&gt;：设置 Parallel scavenge 收集器具有&lt;strong&gt;自适应调节策略&lt;/strong&gt;，在这种模式下，年轻代的大小、Eden 和 Survivor 的比例、晋升老年代的对象年龄等参数会被自动调整，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-XX:ParallelGcrhreads&lt;/code&gt;：设置年轻代并行收集器的线程数，一般与 CPU 数量相等，以避免过多的线程数影响垃圾收集性能
&lt;ul&gt;
&lt;li&gt;在默认情况下，当 CPU 数量小于 8 个，ParallelGcThreads 的值等于 CPU 数量&lt;/li&gt;
&lt;li&gt;当 CPU 数量大于 8 个，ParallelGCThreads 的值等于 3+[5*CPU Count]/8]&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-XX:MaxGCPauseMillis&lt;/code&gt;：设置垃圾收集器最大停顿时间（即 STW 的时间），单位是毫秒
&lt;ul&gt;
&lt;li&gt;对于用户来讲，停顿时间越短体验越好；在服务器端，注重高并发，整体的吞吐量&lt;/li&gt;
&lt;li&gt;为了把停顿时间控制在 MaxGCPauseMillis 以内，收集器在工作时会调整 Java 堆大小或其他一些参数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-XX:GCTimeRatio&lt;/code&gt;：垃圾收集时间占总时间的比例 =1/(N+1)，用于衡量吞吐量的大小
&lt;ul&gt;
&lt;li&gt;取值范围（0，100）。默认值 99，也就是垃圾回收时间不超过 1&lt;/li&gt;
&lt;li&gt;与 &lt;code&gt;-xx:MaxGCPauseMillis&lt;/code&gt; 参数有一定矛盾性，暂停时间越长，Radio 参数就容易超过设定的比例&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;并发&#34;&gt;并发&lt;/h3&gt;
&lt;h4 id=&#34;cms&#34;&gt;CMS&lt;/h4&gt;
&lt;p&gt;CMS 全称 Concurrent Mark Sweep，是一款&lt;strong&gt;并发的、使用标记-清除&lt;/strong&gt;算法、针对老年代的垃圾回收器，其最大特点是&lt;strong&gt;让垃圾收集线程与用户线程同时工作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;CMS 收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间，停顿时间越短（&lt;strong&gt;低延迟&lt;/strong&gt;）越适合与用户交互的程序，良好的响应速度能提升用户体验&lt;/p&gt;
&lt;p&gt;分为以下四个流程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初始标记：使用 STW 出现短暂停顿，仅标记一下 GC Roots 能直接关联到的对象，速度很快&lt;/li&gt;
&lt;li&gt;并发标记：进行 GC Roots 开始遍历整个对象图，在整个回收过程中耗时最长，不需要 STW，可以与用户线程并发运行&lt;/li&gt;
&lt;li&gt;重新标记：修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，比初始标记时间长但远比并发标记时间短，需要 STW（不停顿就会一直变化，采用写屏障 + 增量更新来避免漏标情况）&lt;/li&gt;
&lt;li&gt;并发清除：清除标记为可以回收对象，&lt;strong&gt;不需要移动存活对象&lt;/strong&gt;，所以这个阶段可以与用户线程同时并发的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Mark Sweep 会造成内存碎片，不把算法换成 Mark Compact 的原因：Mark Compact 算法会整理内存，导致用户线程使用的&lt;strong&gt;对象的地址改变&lt;/strong&gt;，影响用户线程继续执行&lt;/p&gt;
&lt;p&gt;在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/JVM-CMS%E6%94%B6%E9%9B%86%E5%99%A8.png&#34;
	width=&#34;1061&#34;
	height=&#34;328&#34;
	srcset=&#34;https://isheihei.github.io/posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/JVM-CMS%E6%94%B6%E9%9B%86%E5%99%A8_hu56ccf0817be9cd7594dce5ab3d2c7565_171134_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/JVM-CMS%E6%94%B6%E9%9B%86%E5%99%A8_hu56ccf0817be9cd7594dce5ab3d2c7565_171134_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;JVM-CMS收集器&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;323&#34;
		data-flex-basis=&#34;776px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;优点：并发收集、低延迟&lt;/p&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;吞吐量降低：在并发阶段虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，CPU 利用率不够高&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CMS 收集器&lt;strong&gt;无法处理浮动垃圾&lt;/strong&gt;，可能出现 Concurrent Mode Failure 导致另一次 Full GC 的产生&lt;/p&gt;
&lt;p&gt;浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾（产生了新对象），这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，CMS 收集需要预留出一部分内存，不能等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS，导致很长的停顿时间&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;标记 - 清除算法导致的空间碎片，往往出现老年代空间无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC；为新对象分配内存空间时，将无法使用指针碰撞（Bump the Pointer）技术，而只能够选择空闲列表（Free List）执行内存分配&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参数设置：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-XX：+UseConcMarkSweepGC&lt;/code&gt;：手动指定使用 CMS 收集器执行内存回收任务&lt;/p&gt;
&lt;p&gt;开启该参数后会自动将 &lt;code&gt;-XX:+UseParNewGC&lt;/code&gt; 打开，即：ParNew + CMS + Serial old的组合&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-XX:CMSInitiatingoccupanyFraction&lt;/code&gt;：设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JDK5 及以前版本的默认值为 68，即当老年代的空间使用率达到 68% 时，会执行一次CMS回收&lt;/li&gt;
&lt;li&gt;JDK6 及以上版本默认值为 92%&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-XX:+UseCMSCompactAtFullCollection&lt;/code&gt;：用于指定在执行完 Full GC 后对内存空间进行压缩整理，以此避免内存碎片的产生，由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-XX:CMSFullGCsBeforecompaction&lt;/code&gt;：&lt;strong&gt;设置在执行多少次 Full GC 后对内存空间进行压缩整理&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-XX:ParallelCMSThreads&lt;/code&gt;：设置 CMS 的线程数量&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CMS 默认启动的线程数是 (ParallelGCThreads+3)/4，ParallelGCThreads 是年轻代并行收集器的线程数&lt;/li&gt;
&lt;li&gt;收集线程占用的 CPU 资源多于25%，对用户程序影响可能较大；当 CPU 资源比较紧张时，受到 CMS 收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;g1-收集器&#34;&gt;G1 收集器&lt;/h4&gt;
&lt;h5 id=&#34;g1-特点&#34;&gt;G1 特点&lt;/h5&gt;
&lt;p&gt;G1（Garbage-First）是一款面向服务端应用的垃圾收集器，&lt;strong&gt;应用于新生代和老年代&lt;/strong&gt;、采用标记-整理算法、软实时、低延迟、可设定目标（最大 STW 停顿时间）的垃圾回收器，用于代替 CMS，适用于较大的堆（&amp;gt;4 ~ 6G），在 JDK9 之后默认使用 G1&lt;/p&gt;
&lt;p&gt;G1 对比其他处理器的优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;并发与并行：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;并行性：G1 在回收期间，可以有多个 GC 线程同时工作，有效利用多核计算能力，此时用户线程 STW&lt;/li&gt;
&lt;li&gt;并发性：G1 拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此不会在整个回收阶段发生完全阻塞应用程序的情况&lt;/li&gt;
&lt;li&gt;其他的垃圾收集器使用内置的 JVM 线程执行 GC 的多线程操作，而 G1 GC 可以采用应用线程承担后台运行的 GC 工作，JVM 的 GC 线程处理速度慢时，系统会&lt;strong&gt;调用应用程序线程加速垃圾回收&lt;/strong&gt;过程&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;分区算法&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;从分代上看，G1  属于分代型垃圾回收器，区分年轻代和老年代，年轻代依然有 Eden 区和 Survivor 区。从堆结构上看，&lt;strong&gt;新生代和老年代不再物理隔离&lt;/strong&gt;，不用担心每个代内存是否足够，这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次 GC&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将整个堆划分成约 2048 个大小相同的独立 Region 块，每个 Region 块大小根据堆空间的实际大小而定，整体被控制在 1MB 到 32 MB之间且为 2 的 N 次幂，所有 Region 大小相同，在 JVM 生命周期内不会被改变。G1 把堆划分成多个大小相等的独立区域，使得每个小空间可以单独进行垃圾回收&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;新的区域 Humongous&lt;/strong&gt;：本身属于老年代区，当出现了一个巨型对象超出了分区容量的一半，该对象就会进入到该区域。如果一个 H 区装不下一个巨型对象，那么 G1 会寻找连续的 H 分区来存储，为了能找到连续的 H 区，有时候不得不启动 Full GC&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;G1 不会对巨型对象进行拷贝，回收时被优先考虑，G1 会跟踪老年代所有 incoming 引用，这样老年代 incoming 引用为 0 的巨型对象就可以在新生代垃圾回收时处理掉&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Region 结构图：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-G1-Region%e5%8c%ba%e5%9f%9f.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;空间整合：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CMS：标记-清除算法、内存碎片、若干次 GC 后进行一次碎片整理&lt;/li&gt;
&lt;li&gt;G1：整体来看是基于标记 - 整理算法实现的收集器，从局部（Region 之间）上来看是基于复制算法实现的，两种算法都可以避免内存碎片&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;可预测的停顿时间模型（软实时 soft real-time）&lt;/strong&gt;：可以指定在 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由于分块的原因，G1 可以只选取部分区域进行内存回收，这样缩小了回收的范围，对于全局停顿情况也能得到较好的控制&lt;/li&gt;
&lt;li&gt;G1 跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间，通过过去回收的经验获得），在后台维护一个&lt;strong&gt;优先列表&lt;/strong&gt;，每次根据允许的收集时间优先回收价值最大的 Region，保证了 G1 收集器在有限的时间内可以获取尽可能高的收集效率&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;相比于 CMS GC，G1 未必能做到 CMS 在最好情况下的延时停顿，但是最差情况要好很多&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;G1 垃圾收集器的缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;相较于 CMS，G1 还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1 无论是为了垃圾收集产生的内存占用还是程序运行时的额外执行负载都要比 CMS 要高&lt;/li&gt;
&lt;li&gt;从经验上来说，在小内存应用上 CMS 的表现大概率会优于 G1，而 G1 在大内存应用上则发挥其优势，平衡点在 6-8GB 之间&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;应用场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;面向服务端应用，针对具有大内存、多处理器的机器&lt;/li&gt;
&lt;li&gt;需要低 GC 延迟，并具有大堆的应用程序提供解决方案&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h5 id=&#34;记忆集&#34;&gt;记忆集&lt;/h5&gt;
&lt;p&gt;&lt;em&gt;对象不是孤立的，对象之间会存在跨代引用。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/%E8%B7%A8%E4%BB%A3%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98.png&#34;
	width=&#34;553&#34;
	height=&#34;515&#34;
	srcset=&#34;https://isheihei.github.io/posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/%E8%B7%A8%E4%BB%A3%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98_hu52035108ac6161466b665188b0e3f286_16386_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/%E8%B7%A8%E4%BB%A3%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98_hu52035108ac6161466b665188b0e3f286_16386_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;跨代引用问题&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;107&#34;
		data-flex-basis=&#34;257px&#34;
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;假如只局限于新生代的收集，那么我们将错误的回收E；若想正确回收，那就需要对老年区同样做一次GC搜索，明显效率低下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;假如要现在进行一次只局限于新生代区域内的收集（Minor GC），但新生代中的对象是完全有可能被老年代所引用的，为了找出该区域中的存活对象，不得不在固定的GC Roots之外，再额外遍历整个老年代中所有对象来确保可达性分析结果的正确性，反过来也是一样 。遍历整个老年代所有对象 的方案虽然理论上可行，但无疑会为内存回收带来很大的性能负担。&lt;/p&gt;
&lt;p&gt;记忆集 Remembered Set 在新生代中，每个 Region 都有一个 Remembered Set，用来被哪些其他 Region 里的对象引用（谁引用了我就记录谁）&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/JUC-G1%E8%AE%B0%E5%BF%86%E9%9B%86.png&#34;
	width=&#34;906&#34;
	height=&#34;412&#34;
	srcset=&#34;https://isheihei.github.io/posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/JUC-G1%E8%AE%B0%E5%BF%86%E9%9B%86_hu055b6e68b0ca02d5e7ac9c5083acebb0_81130_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/JUC-G1%E8%AE%B0%E5%BF%86%E9%9B%86_hu055b6e68b0ca02d5e7ac9c5083acebb0_81130_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;JUC-G1记忆集&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;219&#34;
		data-flex-basis=&#34;527px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;程序对 Reference 类型数据写操作时，产生一个 Write Barrier 暂时中断操作，检查该对象和 Reference 类型数据是否在不同的 Region（跨代引用），不同就将相关引用信息记录到 Reference 类型所属的 Region 的 Remembered Set 之中&lt;/li&gt;
&lt;li&gt;进行内存回收时，在 GC 根节点的枚举范围中加入 Remembered Set 即可保证不对全堆扫描也不会有遗漏&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;垃圾收集器在新生代中建立了记忆集这样的数据结构，可以理解为它是一个抽象类，具体实现记忆集的三种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;字长精度&lt;/li&gt;
&lt;li&gt;对象精度&lt;/li&gt;
&lt;li&gt;卡精度(卡表)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;卡表（Card Table）在老年代中，是一种对记忆集的具体实现，主要定义了记忆集的记录精度、与堆内存的映射关系等，卡表中的每一个元素都对应着一块特定大小的内存块，这个内存块称之为卡页（card page），当存在跨代引用时，会将卡页标记为 dirty，JVM 对于卡页的维护也是通过写屏障的方式&lt;/p&gt;
&lt;p&gt;收集集合 CSet 代表每次 GC 暂停时回收的一系列目标分区，在任意一次收集暂停中，CSet 所有分区都会被释放，内部存活的对象都会被转移到分配的空闲分区中。年轻代收集 CSet 只容纳年轻代分区，而混合收集会通过启发式算法，在老年代候选回收分区中，筛选出回收收益最高的分区添加到 CSet 中&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CSet of Young Collection&lt;/li&gt;
&lt;li&gt;CSet of Mix Collection&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h5 id=&#34;工作原理-1&#34;&gt;工作原理&lt;/h5&gt;
&lt;p&gt;G1 中提供了三种垃圾回收模式：YoungGC、Mixed GC 和 Full GC，在不同的条件下被触发&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当堆内存使用达到一定值（默认 45%）时，开始老年代并发标记过程&lt;/li&gt;
&lt;li&gt;标记完成马上开始混合回收过程&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/JVM-G1%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B.png&#34;
	width=&#34;1129&#34;
	height=&#34;402&#34;
	srcset=&#34;https://isheihei.github.io/posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/JVM-G1%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B_huecccb4369629cd64422785cf13d275a0_99587_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/JVM-G1%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B_huecccb4369629cd64422785cf13d275a0_99587_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;JVM-G1回收过程&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;280&#34;
		data-flex-basis=&#34;674px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;顺时针：Young GC → Young GC + Concurrent Mark → Mixed GC 顺序，进行垃圾回收&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Young GC&lt;/strong&gt;：发生在年轻代的 GC 算法，一般对象（除了巨型对象）都是在 eden region 中分配内存，当所有 eden region 被耗尽无法申请内存时，就会触发一次 Young GC，G1 停止应用程序的执行 STW，把活跃对象放入老年代，垃圾对象回收&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;回收过程&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;扫描根：根引用连同 RSet 记录的外部引用作为扫描存活对象的入口&lt;/li&gt;
&lt;li&gt;更新 RSet：处理 dirty card queue 更新 RS，此后 RSet 准确的反映对象的引用关系
&lt;ul&gt;
&lt;li&gt;dirty card queue：类似缓存，产生了引用先记录在这里，然后更新到 RSet&lt;/li&gt;
&lt;li&gt;作用：产生引用直接更新 RSet 需要线程同步开销很大，使用队列性能好&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;处理 RSet：识别被老年代对象指向的 Eden 中的对象，这些被指向的对象被认为是存活的对象，把需要回收的分区放入 Young CSet 中进行回收&lt;/li&gt;
&lt;li&gt;复制对象：Eden 区内存段中存活的对象会被复制到 survivor 区，survivor 区内存段中存活的对象如果年龄未达阈值，年龄会加1，达到阀值会被会被复制到 old 区中空的内存分段，如果 survivor 空间不够，Eden 空间的部分数据会直接晋升到老年代空间&lt;/li&gt;
&lt;li&gt;处理引用：处理 Soft，Weak，Phantom，JNI Weak  等引用，最终 Eden 空间的数据为空，GC 停止工作&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;**Concurrent Mark **：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初始标记：标记从根节点直接可达的对象，这个阶段是 STW 的，并且会触发一次年轻代 GC&lt;/li&gt;
&lt;li&gt;并发标记 (Concurrent Marking)：在整个堆中进行并发标记（应用程序并发执行），可能被 YoungGC 中断。会计算每个区域的对象活性，即区域中存活对象的比例，若区域中的所有对象都是垃圾，则这个区域会被立即回收（&lt;strong&gt;实时回收&lt;/strong&gt;），给浮动垃圾准备出更多的空间，把需要收集的 Region 放入 CSet 当中&lt;/li&gt;
&lt;li&gt;最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中，这阶段需要停顿线程，但是可并行执行（&lt;strong&gt;防止漏标&lt;/strong&gt;）&lt;/li&gt;
&lt;li&gt;筛选回收：并发清理阶段，首先对 CSet 中各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划，也需要 STW&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/JVM-G1%E6%94%B6%E9%9B%86%E5%99%A8.jpg&#34;
	width=&#34;763&#34;
	height=&#34;249&#34;
	srcset=&#34;https://isheihei.github.io/posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/JVM-G1%E6%94%B6%E9%9B%86%E5%99%A8_hub533c5874b46ffc58619fcd23bdf83e7_37888_480x0_resize_q75_box.jpg 480w, https://isheihei.github.io/posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/JVM-G1%E6%94%B6%E9%9B%86%E5%99%A8_hub533c5874b46ffc58619fcd23bdf83e7_37888_1024x0_resize_q75_box.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;JVM-G1收集器&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;306&#34;
		data-flex-basis=&#34;735px&#34;
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Mixed GC&lt;/strong&gt;：当很多对象晋升到老年代时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即 Mixed GC，除了回收整个 young region，还会回收一部分的 old region，过程同 YGC&lt;/p&gt;
&lt;p&gt;注意：&lt;strong&gt;是一部分老年代，而不是全部老年代&lt;/strong&gt;，可以选择哪些老年代 region 收集，对垃圾回收的时间进行控制&lt;/p&gt;
&lt;p&gt;在 G1 中，Mixed GC 可以通过 &lt;code&gt;-XX:InitiatingHeapOccupancyPercent&lt;/code&gt; 设置阈值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Full GC&lt;/strong&gt;：对象内存分配速度过快，Mixed GC 来不及回收，导致老年代被填满，就会触发一次 Full GC，G1 的 Full GC 算法就是单线程执行的垃圾回收，会导致异常长时间的暂停时间，需要进行不断的调优，尽可能的避免 Full GC&lt;/p&gt;
&lt;p&gt;产生 Full GC 的原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;晋升时没有足够的空间存放晋升的对象&lt;/li&gt;
&lt;li&gt;并发处理过程完成之前空间耗尽，浮动垃圾&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h5 id=&#34;相关参数&#34;&gt;相关参数&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-XX:+UseG1GC&lt;/code&gt;：手动指定使用 G1 垃圾收集器执行内存回收任务&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-XX:G1HeapRegionSize&lt;/code&gt;：设置每个 Region 的大小。值是 2 的幂，范围是 1MB 到 32MB 之间，目标是根据最小的 Java 堆大小划分出约 2048 个区域，默认是堆内存的 1/2000&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-XX:MaxGCPauseMillis&lt;/code&gt;：设置期望达到的最大 GC 停顿时间指标，JVM会尽力实现，但不保证达到，默认值是 200ms&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-XX:+ParallelGcThread&lt;/code&gt;：设置 STW 时 GC 线程数的值，最多设置为 8&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-XX:ConcGCThreads&lt;/code&gt;：设置并发标记线程数，设置为并行垃圾回收线程数 ParallelGcThreads 的1/4左右&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-XX:InitiatingHeapoccupancyPercent&lt;/code&gt;：设置触发并发 Mixed GC 周期的 Java 堆占用率阈值，超过此值，就触发 GC，默认值是 45&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-XX:+ClassUnloadingWithConcurrentMark&lt;/code&gt;：并发标记类卸载，默认启用，所有对象都经过并发标记后，就可以知道哪些类不再被使用，当一个类加载器的所有类都不再使用，则卸载它所加载的所有类&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-XX:G1NewSizePercent&lt;/code&gt;：新生代占用整个堆内存的最小百分比（默认5％）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-XX:G1MaxNewSizePercent&lt;/code&gt;：新生代占用整个堆内存的最大百分比（默认60％）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-XX:G1ReservePercent=10&lt;/code&gt;：保留内存区域，防止 to space（Survivor中的 to 区）溢出&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备一下特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;并行与并发&lt;/strong&gt;：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分代收集&lt;/strong&gt;：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;空间整合&lt;/strong&gt;：与 CMS 的“标记-清理”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可预测的停顿&lt;/strong&gt;：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;G1 收集器的运作大致分为以下几个步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;初始标记(Initial Marking)&lt;/strong&gt;：这阶段&lt;strong&gt;仅仅只是标记GC Roots能直接关联到的对象并修改TAMS(Next Top at Mark Start)的值&lt;/strong&gt;，让下一阶段用户程序并发运行时，能在正确的可用的Region中创建新对象，这阶段&lt;strong&gt;需要停顿线程，但是耗时很短&lt;/strong&gt;。而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际并没有额外的停顿。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;并发标记(Concurrent Marking)&lt;/strong&gt;：&lt;strong&gt;从GC Roots开始对堆的对象进行可达性分析，递归扫描整个堆里的对象图，找出存活的对象&lt;/strong&gt;，这阶段耗时较长，但是可以与用户程序并发执行。当对象图扫描完成以后，还要&lt;strong&gt;重新处理SATB记录下的在并发时有引用变动的对象。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;最终标记(Final Marking)&lt;/strong&gt;：对用户线程做另一个短暂的暂停，&lt;strong&gt;用于处理并发阶段结束后仍遗留下来的最后那少量的 SATB 记录。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;筛选回收(Live Data Counting and Evacuation)&lt;/strong&gt;：&lt;strong&gt;负责更新 Region 的统计数据，对各个 Region 的回收价值和成本进行排序&lt;/strong&gt;，根据用户所期望的停顿时间来制定回收计划。&lt;strong&gt;可以自由选择多个Region来构成回收集，然后把回收的那一部分Region中的存活对象==复制==到空的Region中，在对那些Region进行清空。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;除了并发标记外，其余过程都要 STW&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)&lt;/strong&gt; 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;不管是G1还是其他分代收集器，JVM都是使用 记忆集(Remembered Set) 来避免全局扫描。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;每个Region都有一个对应的记忆集。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;每次Reference类型数据写操作时，都会产生一个 写屏障（Write Barrier）暂时去终止操作&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;然后检查将要写入的引用 指向的对象是否和该Reference类型数据在不同的 Region（其他收集器：检查老年代对象是否引用了新生代对象）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;如果不同，通过 卡表（Card Table）把相关引用信息记录到引用指向对象的所在Region对应的记忆集(Remembered Set) 中&lt;/strong&gt;，被引用对象记录引用自己的对象，这样被引用对象要可达性分析时候，可以找记忆集中的对象&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;当进行垃圾收集时，在GC Roots枚举范围加上记忆集；就可以保证不进行全局扫描了。&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;《深入理解 Java 虚拟机：JVM 高级特性与最佳实践（第二版》&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://docs.oracle.com/javase/specs/jvms/se8/html/index.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://docs.oracle.com/javase/specs/jvms/se8/html/index.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>线程安全与锁优化</title>
        <link>https://isheihei.github.io/posts/java/jvm-%E9%94%81%E4%BC%98%E5%8C%96/</link>
        <pubDate>Tue, 24 May 2022 14:11:07 +0800</pubDate>
        
        <guid>https://isheihei.github.io/posts/java/jvm-%E9%94%81%E4%BC%98%E5%8C%96/</guid>
        <description>&lt;h1 id=&#34;线程安全与锁优化&#34;&gt;线程安全与锁优化&lt;/h1&gt;
&lt;h2 id=&#34;线程安全&#34;&gt;线程安全&lt;/h2&gt;
&lt;h3 id=&#34;java语言中的线程安全&#34;&gt;Java语言中的线程安全&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;不可变&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Java语言中，如果多线程共享的数据是一个基本数据类型，那么只要在定义时使用final关键字修饰它就可以保证它是不可变的&lt;/p&gt;
&lt;p&gt;只要一个不可变的对象被正确地构建出来（即没有发生this引用逃逸的情况），那其外部的可见状态永远都不会改变，永远都不会看到它在多个线程之中处于不一致的状态。“不可变”带来的安全性是最直接、最纯粹的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;绝对线程安全&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个定义其实是很严格的，一个类要达到“不管运行时环境如何，调用者都不需要任何额外的同步措施”可能需要付出非常高昂的，甚至不切实际的代价。&lt;/p&gt;
&lt;p&gt;在Java API中标注自己是线程安全的类，大多数都不是绝对的线程安全。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;相对线程安全&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;相对线程安全就是我们通常意义上所讲的线程安全，它需要保证对这个对象单次的操作是线程安全的，我们在调用的时候不需要进行额外的保障措施，但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;线程兼容&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;线程对立&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;线程对立是指不管调用端是否采取了同步措施，都无法在多线程环境中并发使用代码。&lt;/p&gt;
&lt;p&gt;一个线程对立的例子是Thread类的suspend()和resume()方法。如果有两个线程同时持有一个线程对象，一个尝试去中断线程，一个尝试去恢复线程，在并发进行的情况下，无论调用时是否进行了同步，目标线程都存在死锁风险——假如suspend()中断的线程就是即将要执行resume()的那个线程，那就肯定要产生死锁了。&lt;/p&gt;
&lt;h3 id=&#34;线程安全的实现方法&#34;&gt;线程安全的实现方法&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;互斥同步&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在Java里面，最基本的互斥同步手段就是synchronized关键字，这是一种块结构（Block Structured）的同步语法。synchronized关键字经过Javac编译之后，会在同步块的前后分别形成monitorenter和monitorexit这两个字节码指令。&lt;/p&gt;
&lt;p&gt;这两个字节码指令都需要一个reference类型的参数来指明要锁定和解锁的对象。如果Java源码中的synchronized明确指定了对象参数，那就以这个对象的引用作为reference；如果没有明确指定，那将根据synchronized修饰的方法类型（如实例方法或类方法），来决定是取代码所在的对象实例还是取类型对应的Class对象来作为线程要持有的锁&lt;/p&gt;
&lt;p&gt;从功能上看，根据以上《Java虚拟机规范》对monitorenter和monitorexit的行为描述，我们可以得出两个关于synchronized的直接推论，这是使用它时需特别注意的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;被synchronized修饰的同步块对同一条线程来说是可重入的。这意味着同一线程反复进入同步块也不会出现自己把自己锁死的情况。&lt;/li&gt;
&lt;li&gt;被synchronized修饰的同步块在持有锁的线程执行完毕并释放锁之前，会无条件地阻塞后面其他线程的进入。这意味着无法像处理某些数据库中的锁那样，强制已获取锁的线程释放锁；也无法强制正在等待锁的线程中断等待或超时退出。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从执行成本的角度看，持有锁是一个重量级（Heavy-Weight）的操作。在主流Java虚拟机实现中，Java的线程是映射到操作系统的原生内核线程之上的，如果要阻塞或唤醒一条线程，则需要操作系统来帮忙完成，这就不可避免地陷入用户态到核心态的转换中，进行这种状态转换需要耗费很多的处理器时间。尤其是对于代码特别简单的同步块（譬如被synchronized修饰的getter()或setter()方法），状态转换消耗的时间甚至会比用户代码本身执行的时间还要长。因此才说，synchronized是Java语言中一个重量级的操作，有经验的程序员都只会在确实必要的情况下才使用这种操作。&lt;/p&gt;
&lt;p&gt;**重入锁（ReentrantLock）**是Lock接口最常见的一种实现，顾名思义，它与synchronized一样是可重入的。在基本用法上，ReentrantLock也与synchronized很相似，只是代码写法上稍有区别而已。不过，ReentrantLock与synchronized相比增加了一些高级功能，主要有以下三项：等待可中断、可实现公平锁及锁可以绑定多个条件。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;等待可中断：是指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。可中断特性对处理执行时间非常长的同步块很有帮助。&lt;/li&gt;
&lt;li&gt;公平锁：是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁；而非公平
锁则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。synchronized中的锁是非公平的，ReentrantLock在默认情况下也是非公平的，但可以通过带布尔值的构造函数要求使用公平锁。不过一旦使用了公平锁，将会导致ReentrantLock的性能急剧下降，会明显影响吞吐量。&lt;/li&gt;
&lt;li&gt;锁绑定多个条件：是指一个ReentrantLock对象可以同时绑定多个Condition对象。在synchronized中，锁对象的wait()跟它的notify()或者notifyAll()方法配合可以实现一个隐含的条件，如果要和多于一个的条件关联的时候，就不得不额外添加一个锁；而ReentrantLock则无须这样做，多次调用newCondition()方法即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ReentrantLock在功能上是synchronized的超集，在性能上又至少不会弱于synchronized，那synchronized修饰符是否应该被直接抛弃，不再使用了呢？当然不是，基于以下理由，笔者仍然推荐在synchronized与ReentrantLock都可满足需要时优先使用synchronized：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;synchronized是在Java语法层面的同步，足够清晰，也足够简单。每个Java程序员都熟悉synchronized，但J.U.C中的Lock接口则并非如此。因此在只需要基础的同步功能时，更推荐synchronized。&lt;/li&gt;
&lt;li&gt;Lock应该确保在finally块中释放锁，否则一旦受同步保护的代码块中抛出异常，则有可能永远不会释放持有的锁。这一点必须由程序员自己来保证，而使用synchronized的话则可以由Java虚拟机来确保即使出现异常，锁也能被自动释放。&lt;/li&gt;
&lt;li&gt;尽管在JDK 5时代ReentrantLock曾经在性能上领先过synchronized，但这已经是十多年之前的胜利了。从长远来看，Java虚拟机更容易针对synchronized来进行优化，因为Java虚拟机可以在线程和对象的元数据中记录synchronized中锁的相关信息，而使用J.U.C中的Lock的话，Java虚拟机是很难得知具体哪些锁对象是由特定线程锁持有的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;非阻塞同步&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;随着硬件指令集的发展，我们已经有了另外一个选择：基于冲突检测的乐观并发策略，通俗地说就是不管风险，先进行操作，如果没有其他线程争用共享数据，那操作就直接成功了；如果共享的数据的确被争用，产生了冲突，那再进行其他的补偿措施，最常用的补偿措施是不断地重试，直到出现没有竞争的共享数据为止。这种乐观并发策略的实现不再需要把线程阻塞挂起，因此这种同步操作被称为非阻塞同步（Non-Blocking Synchronization），使用这种措施的代码也常被称为无锁（Lock-Free）编程。&lt;/p&gt;
&lt;p&gt;硬件保证某些从语义上看起来需要多次操作的行为可以只通过一条处理器指令就能完成，这类指令常用的有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;测试并设置（Test-and-Set）；&lt;/li&gt;
&lt;li&gt;获取并增加（Fetch-and-Increment）；&lt;/li&gt;
&lt;li&gt;交换（Swap）；&lt;/li&gt;
&lt;li&gt;比较并交换（Compare-and-Swap，下文称CAS）；&lt;/li&gt;
&lt;li&gt;加载链接/条件储存（Load-Linked/Store-Conditional，下文称LL/SC）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CAS指令需要有三个操作数，分别是内存位置（在Java中可以简单地理解为变量的内存地址，用V表示）、旧的预期值（用A表示）和准备设置的新值（用B表示）。CAS指令执行时，当且仅当V符合A时，处理器才会用B更新V的值，否则它就不执行更新。但是，不管是否更新了V的值，都会返回V的旧值，上述的处理过程是一个原子操作，执行期间不会被其他线程中断。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;无同步方案&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;要保证线程安全，也并非一定要进行阻塞或非阻塞同步，同步与线程安全两者没有必然的联系。同步只是保障存在共享数据争用时正确性的手段，如果能让一个方法本来就不涉及共享数据，那它自然就不需要任何同步措施去保证其正确性，因此会有一些代码天生就是线程安全的，简单介绍其中的两类。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可重入代码（Reentrant Code）&lt;/strong&gt;：这种代码又称纯代码（Pure Code），是指可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误，也不会对结果有所影响。在特指多线程的上下文语境里（不涉及信号量等因素），我们可以认为可重入代码是线程安全代码的一个真子集，这意味着相对线程安全来说，可重入性是更为基础的特性，它可以保证代码线程安全，即所有可重入的代码都是线程安全的，但并非所有的线程安全的代码都是可重入的。&lt;/p&gt;
&lt;p&gt;可重入代码有一些共同的特征，例如，不依赖全局变量、存储在堆上的数据和公用的系统资源，用到的状态量都由参数中传入，不调用非可重入的方法等。我们可以通过一个比较简单的原则来判断代码是否具备可重入性：如果一个方法的返回结果是可以预测的，只要输入了相同的数据，就都能返回相同的结果，那它就满足可重入性的要求，当然也就是线程安全的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;线程本地存储&lt;/strong&gt;（Thread Local Storage）：如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。&lt;/p&gt;
&lt;h2 id=&#34;锁优化&#34;&gt;锁优化&lt;/h2&gt;
&lt;p&gt;Java虚拟机中，synchronized支持的同步方法和同步语句都是使用monitor来实现的。每个对象都与一个monitor相关联，当一个线程执行到一个monitor监视下的代码块中的第一个指令时，该线程必须在引用的对象上获得一个锁，这个锁是monitor实现的。在HotSpot虚拟机中，monitor是由ObjectMonitor实现，使用C++编写实现，具体代码在HotSpot虚拟机源码ObjectMonitor.hpp文件中。&lt;/p&gt;
&lt;p&gt;查看源码会发现，主要的属性有_count(记录该线程获取锁的次数)、_recursions(锁的重入次数)、_owner(指向持有ObjectMonitor对象的线程)、_WaitSet(处于wait状态的线程集合)、_EntryList(处于等待锁block状态的线程队列)。&lt;/p&gt;
&lt;p&gt;当并发线程执行synchronized修饰的方法或语句块时，先进入_EntryList中，当某个线程获取到对象的monitor后，把monitor对象中的_owner变量设置为当前线程，同时monitor对象中的计数器_count加1，当前线程获取同步锁成功。&lt;/p&gt;
&lt;p&gt;当synchronized修饰的方法或语句块中的线程调用wait()方法时，当前线程将释放持有的monitor对象，monitor对象中的_owner变量赋值为null，同时，monitor对象中的_count值减1，然后当前线程进入_WaitSet集合中等待被唤醒。&lt;/p&gt;
&lt;h3 id=&#34;自旋锁与自适应自旋&#34;&gt;自旋锁与自适应自旋&lt;/h3&gt;
&lt;p&gt;如果物理机器有一个以上的处理器或者处理器核心，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的那个线程“稍等一会”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只须让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁。&lt;/p&gt;
&lt;p&gt;在JDK 6中对自旋锁的优化，引入了自适应的自旋。自适应意味着自旋的时间不再是固定的了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定的。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而允许自旋等待持续相对更长的时间&lt;/p&gt;
&lt;p&gt;如果对于某个锁，自旋很少成功获得过锁，那在以后要获取这个锁时将有可能直接省略掉自旋过程，以避免浪费处理器资源。&lt;/p&gt;
&lt;h3 id=&#34;锁消除&#34;&gt;锁消除&lt;/h3&gt;
&lt;p&gt;锁消除是指虚拟机即时编译器在运行时，对一些代码要求同步，但是对被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持（第11章已经讲解过逃逸分析技术），如果判断到一段代码中，在堆上的所有数据都不会逃逸出去被其他线程访问到，那就可以把它们当作栈上数据对待，认为它们是线程私有的，同步加锁自然就无须再进行。&lt;/p&gt;
&lt;h3 id=&#34;锁粗化&#34;&gt;锁粗化&lt;/h3&gt;
&lt;p&gt;原则上，我们在编写代码的时候，总是推荐将同步块的作用范围限制得尽量小——只在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变少，即使存在锁竞争，等待锁的线程也能尽可能快地拿到锁。&lt;/p&gt;
&lt;p&gt;大多数情况下，上面的原则都是正确的，但是如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体之中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。&lt;/p&gt;
&lt;p&gt;如果虚拟机探测到有这样一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部&lt;/p&gt;
&lt;h3 id=&#34;轻量级锁&#34;&gt;轻量级锁&lt;/h3&gt;
&lt;p&gt;轻量级锁并不是用来代替重量级锁的，它设计的初衷是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/java/jvm-%E9%94%81%E4%BC%98%E5%8C%96/Untitled.png&#34;
	width=&#34;1169&#34;
	height=&#34;395&#34;
	srcset=&#34;https://isheihei.github.io/posts/java/jvm-%E9%94%81%E4%BC%98%E5%8C%96/Untitled_hu7e11831428aef6f9b6ac505529fed6fc_114020_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/java/jvm-%E9%94%81%E4%BC%98%E5%8C%96/Untitled_hu7e11831428aef6f9b6ac505529fed6fc_114020_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;32位HotSpot虚拟机对象头Mark Word&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;295&#34;
		data-flex-basis=&#34;710px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;32位HotSpot虚拟机对象头Mark Word&lt;/p&gt;
&lt;p&gt;接下来介绍轻量级锁的工作过程：在代码即将进入同步块的时候，如果此同步对象没有被锁定（锁标志位为“01”状态），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝（官方为这份拷贝加了一个Displaced前缀，即Displaced Mark Word），这时候线程堆栈与对象头的状态如图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/java/jvm-%E9%94%81%E4%BC%98%E5%8C%96/Untitled1.png&#34;
	width=&#34;668&#34;
	height=&#34;310&#34;
	srcset=&#34;https://isheihei.github.io/posts/java/jvm-%E9%94%81%E4%BC%98%E5%8C%96/Untitled1_huffad5e73d0e6e077613752f5f7dc355b_49676_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/java/jvm-%E9%94%81%E4%BC%98%E5%8C%96/Untitled1_huffad5e73d0e6e077613752f5f7dc355b_49676_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;轻量级锁CAS操作之前堆栈与对象的状态&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;215&#34;
		data-flex-basis=&#34;517px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;然后，虚拟机将使用CAS操作尝试把对象的Mark Word更新为指向Lock Record的指针。如果这个更新动作成功了，即代表该线程拥有了这个对象的锁，并且对象Mark Word的锁标志位（Mark Word的最后两个比特）将转变为“00”，表示此对象处于轻量级锁定状态。这时候线程堆栈与对象头的状态如图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/java/jvm-%E9%94%81%E4%BC%98%E5%8C%96/Untitled2.png&#34;
	width=&#34;460&#34;
	height=&#34;309&#34;
	srcset=&#34;https://isheihei.github.io/posts/java/jvm-%E9%94%81%E4%BC%98%E5%8C%96/Untitled2_hu6534f21b5d87ddca44d307db7517c0ca_39489_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/java/jvm-%E9%94%81%E4%BC%98%E5%8C%96/Untitled2_hu6534f21b5d87ddca44d307db7517c0ca_39489_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;轻量级锁CAS操作之后堆栈与对象的状态&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;148&#34;
		data-flex-basis=&#34;357px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;如果这个更新操作失败了，那就意味着至少存在一条线程与当前线程竞争获取该对象的锁。虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是，说明当前线程已经拥有了这个对象的锁，那直接进入同步块继续执行就可以了，否则就说明这个锁对象已经被其他线程抢占了。如果出现两条以上的线程争用同一个锁的情况，那轻量级锁就不再有效，必须要膨胀为重量级锁，锁标志的状态值变为“10”，此时Mark Word中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也必须进入阻塞状态。&lt;/p&gt;
&lt;p&gt;上面描述的是轻量级锁的加锁过程，它的解锁过程也同样是通过CAS操作来进行的，如果对象的Mark Word仍然指向线程的锁记录，那就用CAS操作把对象当前的Mark Word和线程中复制DisplacedMark Word替换回来。假如能够成功替换，那整个同步过程就顺利完成了；如果替换失败，则说明有其他线程尝试过获取该锁，就要在释放锁的同时，唤醒被挂起的线程。&lt;/p&gt;
&lt;p&gt;轻量级锁能提升程序同步性能的依据是“对于绝大部分的锁，在整个同步周期内都是不存在竞争的”这一经验法则。如果没有竞争，轻量级锁便通过CAS操作成功避免了使用互斥量的开销；但如果确实存在锁竞争，除了互斥量的本身开销外，还额外发生了CAS操作的开销。因此在有竞争的情况下，轻量级锁反而会比传统的重量级锁更慢。&lt;/p&gt;
&lt;h3 id=&#34;偏向锁&#34;&gt;偏向锁&lt;/h3&gt;
&lt;p&gt;偏向锁的思想是偏向于让第一个获取锁对象的线程，这个线程在之后获取该锁就不再需要进行同步操作，甚至连 CAS 操作也不再需要。&lt;/p&gt;
&lt;p&gt;当锁对象第一次被线程获得的时候，进入偏向状态，标记为 |1|01|（前面内存布局图中说明了，这属于偏向锁状态）。同时使用 CAS 操作将线程 ID （ThreadID）记录到 Mark Word 中，如果 CAS 操作成功，这个线程以后每次进入这个锁相关的同步块就不需要再进行任何同步操作。&lt;/p&gt;
&lt;p&gt;当有另外一个线程去尝试获取这个锁对象时，偏向状态就宣告结束，此时撤销偏向（Revoke Bias）后恢复到未锁定状态或者轻量级锁状态。&lt;/p&gt;
&lt;p&gt;偏向锁是为了在资源没有被多线程竞争的情况下尽量减少锁带来的性能开销。&lt;/p&gt;
&lt;p&gt;在锁对象的对象头中有一个ThreadId字段，当第一个线程访问锁时，如果该锁没有被其他线程访问过，即&lt;strong&gt;ThreadId字段为空&lt;/strong&gt;，那么JVM让其持有偏向锁，并将ThreadId字段的值设置为该线程的ID。当下一次获取锁的时候，会判断ThreadId是否相等，如果一致就不会重复获取锁，从而提高了运行率&lt;/p&gt;
&lt;p&gt;如果存在锁的竞争情况，偏向锁就会被撤销并升级为轻量级锁。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;synchronized的执行过程：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;检测Mark Word里面是不是当前线程的ID，如果是，表示当前线程处于偏向锁&lt;/li&gt;
&lt;li&gt;如果不是，则使用CAS将当前线程的ID替换Mark Word，如果成功则表示当前线程获得偏向锁，置偏向标志位1&lt;/li&gt;
&lt;li&gt;如果失败，则说明发生竞争，撤销偏向锁，进而升级为轻量级锁。&lt;/li&gt;
&lt;li&gt;当前线程使用CAS将对象头的Mark Word替换为锁记录指针，如果成功，当前线程获得锁&lt;/li&gt;
&lt;li&gt;如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。&lt;/li&gt;
&lt;li&gt;如果自旋成功则依然处于轻量级状态。&lt;/li&gt;
&lt;li&gt;如果自旋失败，则升级为重量级锁。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;偏向锁、轻量级锁、重量级锁的区别&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;偏向锁的优点是加解锁不需要额外消耗，和执行非同步方法比仅存在纳秒级差距，缺点是如果存在锁竞争会带来额外锁撤销的消耗，适用只有一个线程访问同步代码块的场景。&lt;/p&gt;
&lt;p&gt;轻量级锁的优点是竞争线程不阻塞，程序响应速度快，缺点是如果线程始终得不到锁会自旋消耗 CPU，适用追求响应时间、同步代码块执行快的场景。&lt;/p&gt;
&lt;p&gt;重量级锁的优点是线程竞争不使用自旋不消耗CPU，缺点是线程会阻塞，响应时间慢，适应追求吞吐量、同步代码块执行慢的场景。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Jdk环境变量配置</title>
        <link>https://isheihei.github.io/posts/tips/jdk%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE/</link>
        <pubDate>Fri, 29 Jan 2021 23:21:58 +0800</pubDate>
        
        <guid>https://isheihei.github.io/posts/tips/jdk%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE/</guid>
        <description>&lt;h3 id=&#34;新建java_home变量填写jdk安装路径bin目录的上一级&#34;&gt;新建JAVA_HOME变量，填写jdk安装路径：bin目录的上一级&lt;/h3&gt;
&lt;h3 id=&#34;path变量添加两个&#34;&gt;PATH变量添加两个：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;%JAVA_HOME%\bin&lt;/li&gt;
&lt;li&gt;%JAVA_HOME%\jre\bin&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;新建classpath变量&#34;&gt;新建CLASSPATH变量：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\tools.jar&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        
    </channel>
</rss>
