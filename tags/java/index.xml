<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Java on isheihei&#39;s blog</title>
        <link>https://isheihei.github.io/tags/java/</link>
        <description>Recent content in Java on isheihei&#39;s blog</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <lastBuildDate>Fri, 15 Jul 2022 20:17:48 +0800</lastBuildDate><atom:link href="https://isheihei.github.io/tags/java/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>JVM-类加载</title>
        <link>https://isheihei.github.io/posts/java/jvm-%E7%B1%BB%E5%8A%A0%E8%BD%BD/</link>
        <pubDate>Fri, 15 Jul 2022 20:17:48 +0800</pubDate>
        
        <guid>https://isheihei.github.io/posts/java/jvm-%E7%B1%BB%E5%8A%A0%E8%BD%BD/</guid>
        <description>&lt;h2 id=&#34;类加载过程&#34;&gt;类加载过程&lt;/h2&gt;
&lt;h3 id=&#34;生命周期&#34;&gt;生命周期&lt;/h3&gt;
&lt;p&gt;类是在运行期间&lt;strong&gt;第一次使用时动态加载&lt;/strong&gt;的（不使用不加载），而不是一次性加载所有类，因为一次性加载会占用很多的内存，加载的类信息存放于一块成为方法区的内存空间&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/java/jvm-%E7%B1%BB%E5%8A%A0%E8%BD%BD/JVM-%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png&#34;
	width=&#34;1092&#34;
	height=&#34;234&#34;
	srcset=&#34;https://isheihei.github.io/posts/java/jvm-%E7%B1%BB%E5%8A%A0%E8%BD%BD/JVM-%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F_hu8e43835ce85328b9666c388e85f80113_34408_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/java/jvm-%E7%B1%BB%E5%8A%A0%E8%BD%BD/JVM-%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F_hu8e43835ce85328b9666c388e85f80113_34408_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;JVM-类的生命周期&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;466&#34;
		data-flex-basis=&#34;1120px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;包括 7 个阶段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;加载（Loading）&lt;/li&gt;
&lt;li&gt;链接：验证（Verification）、准备（Preparation）、解析（Resolution）&lt;/li&gt;
&lt;li&gt;初始化（Initialization）&lt;/li&gt;
&lt;li&gt;使用（Using）&lt;/li&gt;
&lt;li&gt;卸载（Unloading）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;加载阶段&#34;&gt;加载阶段&lt;/h3&gt;
&lt;p&gt;加载是类加载的其中一个阶段，注意不要混淆&lt;/p&gt;
&lt;p&gt;加载过程完成以下三件事：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过类的完全限定名称获取定义该类的二进制字节流（二进制字节码）&lt;/li&gt;
&lt;li&gt;将该字节流表示的静态存储结构转换为方法区的运行时存储结构（Java 类模型）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;在内存中生成一个代表该类的 Class 对象，作为该类在方法区中的各种数据的访问入口&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中二进制字节流可以从以下方式中获取：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从 ZIP 包读取，成为 JAR、EAR、WAR 格式的基础&lt;/li&gt;
&lt;li&gt;从网络中获取，最典型的应用是 Applet&lt;/li&gt;
&lt;li&gt;由其他文件生成，例如由 JSP 文件生成对应的 Class 类&lt;/li&gt;
&lt;li&gt;运行时计算生成，例如动态代理技术，在 java.lang.reflect.Proxy 使用 ProxyGenerator.generateProxyClass 生成字节码&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;将字节码文件加载至方法区后，会&lt;strong&gt;在堆中&lt;/strong&gt;创建一个 java.lang.Class 对象，用来引用位于方法区内的数据结构，该 Class 对象是在加载类的过程中创建的，每个类都对应有一个 Class 类型的对象&lt;/p&gt;
&lt;p&gt;方法区内部采用 C++ 的 instanceKlass 描述 Java 类的数据结构：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;_java_mirror&lt;/code&gt; 即 Java 的类镜像，例如对 String 来说就是 String.class，作用是把 class 暴露给 Java 使用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;_super&lt;/code&gt; 即父类、&lt;code&gt;_fields&lt;/code&gt; 即成员变量、&lt;code&gt;_methods&lt;/code&gt; 即方法、&lt;code&gt;_constants&lt;/code&gt; 即常量池、&lt;code&gt;_class_loader&lt;/code&gt; 即类加载器、&lt;code&gt;_vtable&lt;/code&gt; &lt;strong&gt;虚方法表&lt;/strong&gt;、&lt;code&gt;_itable&lt;/code&gt; 接口方法表&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;加载过程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果这个类还有父类没有加载，先加载父类&lt;/li&gt;
&lt;li&gt;加载和链接可能是交替运行的&lt;/li&gt;
&lt;li&gt;Class 对象和 _java_mirror 相互持有对方的地址，堆中对象通过 instanceKlass 和元空间进行交互&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/java/jvm-%E7%B1%BB%E5%8A%A0%E8%BD%BD/JVM-%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-%E5%8A%A0%E8%BD%BD.png&#34;
	width=&#34;817&#34;
	height=&#34;379&#34;
	srcset=&#34;https://isheihei.github.io/posts/java/jvm-%E7%B1%BB%E5%8A%A0%E8%BD%BD/JVM-%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-%E5%8A%A0%E8%BD%BD_hue21997fb3467820226412a963ce42254_80963_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/java/jvm-%E7%B1%BB%E5%8A%A0%E8%BD%BD/JVM-%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-%E5%8A%A0%E8%BD%BD_hue21997fb3467820226412a963ce42254_80963_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;JVM-类的生命周期-加载&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;215&#34;
		data-flex-basis=&#34;517px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;创建数组类有些特殊，因为数组类本身并不是由类加载器负责创建，而是由 JVM 在运行时根据需要而直接创建的，但数组的元素类型仍然需要依靠类加载器去创建，创建数组类的过程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果数组的元素类型是引用类型，那么遵循定义的加载过程递归加载和创建数组的元素类型&lt;/li&gt;
&lt;li&gt;JVM 使用指定的元素类型和数组维度来创建新的数组类&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;基本数据类型由启动类加载器加载&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;链接阶段&#34;&gt;链接阶段&lt;/h3&gt;
&lt;h4 id=&#34;验证&#34;&gt;验证&lt;/h4&gt;
&lt;p&gt;确保 Class 文件的字节流中包含的信息是否符合 JVM 规范，保证被加载类的正确性，不会危害虚拟机自身的安全&lt;/p&gt;
&lt;p&gt;主要包括&lt;strong&gt;四种验证&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;文件格式验证&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;语义检查，但凡在语义上不符合规范的，虚拟机不会给予验证通过&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;是否所有的类都有父类的存在（除了 Object 外，其他类都应该有父类）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;是否一些被定义为 final 的方法或者类被重写或继承了&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;非抽象类是否实现了所有抽象方法或者接口方法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;是否存在不兼容的方法&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;字节码验证，试图通过对字节码流的分析，判断字节码是否可以被正确地执行&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在字节码的执行过程中，是否会跳转到一条不存在的指令&lt;/li&gt;
&lt;li&gt;函数的调用是否传递了正确类型的参数&lt;/li&gt;
&lt;li&gt;变量的赋值是不是给了正确的数据类型&lt;/li&gt;
&lt;li&gt;栈映射帧（StackMapTable）在这个阶段用于检测在特定的字节码处，其局部变量表和操作数栈是否有着正确的数据类型&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;符号引用验证，Class 文件在其常量池会通过字符串记录将要使用的其他类或者方法&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;准备&#34;&gt;准备&lt;/h4&gt;
&lt;p&gt;准备阶段为&lt;strong&gt;静态变量（类变量）分配内存并设置初始值&lt;/strong&gt;，使用的是方法区的内存：&lt;/p&gt;
&lt;p&gt;说明：实例变量不会在这阶段分配内存，它会在对象实例化时随着对象一起被分配在堆中，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次&lt;/p&gt;
&lt;p&gt;类变量初始化：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;static 变量分配空间和赋值是两个步骤：&lt;strong&gt;分配空间在准备阶段完成，赋值在初始化阶段完成&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;如果 static 变量是 final 的基本类型以及字符串常量，那么编译阶段值（方法区）就确定了，准备阶段会显式初始化&lt;/li&gt;
&lt;li&gt;如果 static 变量是 final 的，但属于引用类型或者构造器方法的字符串，赋值在初始化阶段完成&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;初始值一般为 0 值，例如下面的类变量 value 被初始化为 0 而不是 123：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;value&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;123&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;常量 value 被初始化为 123 而不是 0：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;value&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;123&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Java 并不支持 boolean 类型，对于 boolean 类型，内部实现是 int，由于 int 的默认值是0，故 boolean 的默认值就是 false&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;解析&#34;&gt;解析&lt;/h4&gt;
&lt;p&gt;将常量池中类、接口、字段、方法的&lt;strong&gt;符号引用替换为直接引用&lt;/strong&gt;（内存地址）的过程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;符号引用：一组符号来描述目标，可以是任何字面量，属于编译原理方面的概念，如：包括类和接口的全限名、字段的名称和描述符、方法的名称和&lt;strong&gt;方法描述符&lt;/strong&gt;（因为类还没有加载完，很多方法是找不到的）&lt;/li&gt;
&lt;li&gt;直接引用：直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄，如果有了直接引用，那说明引用的目标必定已经存在于内存之中&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如：在 &lt;code&gt;com.demo.Solution&lt;/code&gt; 类中引用了 &lt;code&gt;com.test.Quest&lt;/code&gt;，把 &lt;code&gt;com.test.Quest&lt;/code&gt; 作为符号引用存进类常量池，在类加载完后，&lt;strong&gt;用这个符号引用去方法区找这个类的内存地址&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在类加载阶段解析的是非虚方法，静态绑定&lt;/li&gt;
&lt;li&gt;也可以在初始化阶段之后再开始解析，这是为了支持 Java 的&lt;strong&gt;动态绑定&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;通过解析操作，符号引用就可以转变为目标方法在类的虚方法表中的位置，从而使得方法被成功调用&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Load2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;throws&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Exception&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;ClassLoader&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;classloader&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Load2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;class&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getClassLoader&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// cloadClass 加载类方法不会导致类的解析和初始化，也不会加载D
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;Class&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;?&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;classloader&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;loadClass&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;cn.jvm.t3.load.C&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// new C();会导致类的解析和初始化，从而解析初始化D
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;in&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;read&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;C&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;D&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;d&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;D&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;D&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;初始化&#34;&gt;初始化&lt;/h3&gt;
&lt;h4 id=&#34;介绍&#34;&gt;介绍&lt;/h4&gt;
&lt;p&gt;初始化阶段才真正开始执行类中定义的 Java 程序代码，在准备阶段，类变量已经赋过一次系统要求的初始值；在初始化阶段，通过程序制定的计划去初始化类变量和其它资源，执行 clinit ()&lt;/p&gt;
&lt;p&gt;在编译生成 class 文件时，编译器会产生两个方法加于 class 文件中，一个是类的初始化方法 clinit，另一个是实例的初始化方法 init&lt;/p&gt;
&lt;p&gt;类构造器 clinit () 与实例构造器 init() 不同，它不需要程序员进行显式调用，在一个类的生命周期中，类构造器最多被虚拟机&lt;strong&gt;调用一次&lt;/strong&gt;，而实例构造器则会被虚拟机调用多次，只要程序员创建对象&lt;/p&gt;
&lt;p&gt;类在第一次实例化加载一次，把 class 读入内存，后续实例化不再加载，引用第一次加载的类&lt;/p&gt;
&lt;h4 id=&#34;clinit&#34;&gt;clinit&lt;/h4&gt;
&lt;p&gt;clinit ()：类构造器，由编译器自动收集类中&lt;strong&gt;所有类变量的赋值动作和静态语句块&lt;/strong&gt;中的语句合并产生的&lt;/p&gt;
&lt;p&gt;作用：是在类加载过程中的初始化阶段进行静态变量初始化和执行静态代码块&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果类中没有静态变量或静态代码块，那么 clinit 方法将不会被生成&lt;/li&gt;
&lt;li&gt;clinit 方法只执行一次，在执行 clinit 方法时，必须先执行父类的clinit方法&lt;/li&gt;
&lt;li&gt;static 变量的赋值操作和静态代码块的合并顺序由源文件中出现的顺序决定&lt;/li&gt;
&lt;li&gt;static 不加 final 的变量都在初始化环节赋值&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;线程安全&lt;/strong&gt;问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;虚拟机会保证一个类的 clinit () 方法在多线程环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行这个类的 clinit () 方法，其它线程都阻塞等待，直到活动线程执行clinit () 方法完毕&lt;/li&gt;
&lt;li&gt;如果在一个类的 clinit () 方法中有耗时的操作，就可能造成多个线程阻塞，在实际过程中此种阻塞很隐蔽&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;特别注意：静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Test&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;//i = 0;                // 给变量赋值可以正常编译通过
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;  	&lt;span class=&#34;c1&#34;&gt;// 这句编译器会提示“非法向前引用”
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成 clinit ()方法，两者不同的是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在初始化一个接口时，并不会先初始化它的父接口，所以执行接口的 clinit ()方法不需要先执行父接口的clinit () 方法&lt;/li&gt;
&lt;li&gt;在初始化一个类时，不会先初始化所实现的接口，所以接口的实现类在初始化时不会执行接口的 clinit () 方法&lt;/li&gt;
&lt;li&gt;只有当父接口中定义的变量使用时，父接口才会初始化&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;时机&#34;&gt;时机&lt;/h4&gt;
&lt;p&gt;类的初始化是懒惰的，只有在首次使用时才会被装载，JVM 不会无条件地装载 Class 类型，Java 虚拟机规定，一个类或接口在初次使用前，必须要进行初始化&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主动引用&lt;/strong&gt;：虚拟机规范中并没有强制约束何时进行加载，但是规范严格规定了有且只有下列情况必须对类进行初始化（加载、验证、准备都会发生）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当创建一个类的实例时，使用 new 关键字，或者通过反射、克隆、反序列化（前文讲述的对象的创建时机）&lt;/li&gt;
&lt;li&gt;当调用类的静态方法或访问静态字段时，遇到 getstatic、putstatic、invokestatic 这三条字节码指令，如果类没有进行过初始化，则必须先触发其初始化
&lt;ul&gt;
&lt;li&gt;getstatic：程序访问类的静态变量（不是静态常量，常量会被加载到运行时常量池）&lt;/li&gt;
&lt;li&gt;putstatic：程序给类的静态变量赋值&lt;/li&gt;
&lt;li&gt;invokestatic ：调用一个类的静态方法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;使用 java.lang.reflect 包的方法对类进行反射调用时，如果类没有进行初始化，则需要先触发其初始化&lt;/li&gt;
&lt;li&gt;当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化，但这条规则并&lt;strong&gt;不适用于接口&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;当虚拟机启动时，需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类&lt;/li&gt;
&lt;li&gt;MethodHandle 和 VarHandle 可以看作是轻量级的反射调用机制，而要想使用这两个调用， 就必须先使用 findStaticVarHandle 来初始化要调用的类&lt;/li&gt;
&lt;li&gt;补充：当一个接口中定义了 JDK8 新加入的默认方法（被 default 关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;被动引用&lt;/strong&gt;：所有引用类的方式都不会触发初始化，称为被动引用&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过子类引用父类的静态字段，不会导致子类初始化，只会触发父类的初始化&lt;/li&gt;
&lt;li&gt;通过数组定义来引用类，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法&lt;/li&gt;
&lt;li&gt;常量（final 修饰）在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化&lt;/li&gt;
&lt;li&gt;调用 ClassLoader 类的 loadClass() 方法加载一个类，并不是对类的主动使用，不会导致类的初始化&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;init&#34;&gt;init&lt;/h4&gt;
&lt;p&gt;init 指的是实例构造器，主要作用是在类实例化过程中执行，执行内容包括成员变量初始化和代码块的执行&lt;/p&gt;
&lt;p&gt;实例化即调用 init() ，虚拟机会保证这个类的构造方法的线程安全，先为实例变量分配内存空间，再执行赋默认值，然后根据源码中的顺序执行赋初值或代码块，没有成员变量初始化和代码块则不会执行&lt;/p&gt;
&lt;p&gt;类实例化过程：&lt;strong&gt;父类的类构造器 init() -&amp;gt; 子类的类构造器 init() -&amp;gt; 父类的成员变量和实例代码块 -&amp;gt; 父类的构造函数 -&amp;gt; 子类的成员变量和实例代码块 -&amp;gt; 子类的构造函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;new 关键字会创建对象并复制 dup 一个对象引用，一个调用 init()  方法，另一个用来赋值给接收者&lt;/p&gt;
&lt;h3 id=&#34;卸载阶段&#34;&gt;卸载阶段&lt;/h3&gt;
&lt;p&gt;时机：执行了 System.exit() 方法，程序正常执行结束，程序在执行过程中遇到了异常或错误而异常终止，由于操作系统出现错误而导致Java虚拟机进程终止&lt;/p&gt;
&lt;p&gt;卸载类即该类的 &lt;strong&gt;Class 对象被 GC&lt;/strong&gt;，卸载类需要满足3个要求:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;该类的所有的实例对象都已被 GC，也就是说堆不存在该类的实例对象&lt;/li&gt;
&lt;li&gt;该类没有在其他任何地方被引用&lt;/li&gt;
&lt;li&gt;该类的类加载器的实例已被 GC，一般是可替换类加载器的场景，如 OSGi、JSP 的重加载等，很难达成&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在 JVM 生命周期类，由 JVM 自带的类加载器加载的类是不会被卸载的，自定义的类加载器加载的类是可能被卸载。因为 JVM 会始终引用启动、扩展、系统类加载器，这些类加载器始终引用它们所加载的类，这些类始终是可及的&lt;/p&gt;
&lt;h2 id=&#34;类加载器&#34;&gt;类加载器&lt;/h2&gt;
&lt;h3 id=&#34;类加载&#34;&gt;类加载&lt;/h3&gt;
&lt;p&gt;类加载方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;隐式加载：不直接在代码中调用 ClassLoader 的方法加载类对象
&lt;ul&gt;
&lt;li&gt;创建类对象、使用类的静态域、创建子类对象、使用子类的静态域&lt;/li&gt;
&lt;li&gt;在 JVM 启动时，通过三大类加载器加载 class&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;显式加载：
&lt;ul&gt;
&lt;li&gt;ClassLoader.loadClass(className)：只加载和连接，&lt;strong&gt;不会进行初始化&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Class.forName(String name, boolean initialize, ClassLoader loader)：使用 loader 进行加载和连接，根据参数 initialize 决定是否初始化&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;类的唯一性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 JVM 中表示两个 class 对象判断为同一个类存在的两个必要条件：
&lt;ul&gt;
&lt;li&gt;类的完整类名必须一致，包括包名&lt;/li&gt;
&lt;li&gt;加载这个类的 ClassLoader（指 ClassLoader 实例对象）必须相同&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;这里的相等，包括类的 Class 对象的 equals() 方法、isAssignableFrom() 方法、isInstance() 方法的返回结果为 true，也包括使用 instanceof 关键字做对象所属关系判定结果为 true&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;命名空间：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个类加载器都有自己的命名空间，命名空间由该加载器及所有的父加载器所加载的类组成&lt;/li&gt;
&lt;li&gt;在同一命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基本特征：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;可见性&lt;/strong&gt;，子类加载器可以访问父加载器加载的类型，但是反过来是不允许的&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;单一性&lt;/strong&gt;，由于父加载器的类型对于子加载器是可见的，所以父加载器中加载过的类型，不会在子加载器中重复加载&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;加载器&#34;&gt;加载器&lt;/h3&gt;
&lt;p&gt;类加载器是 Java 的核心组件，用于加载字节码到 JVM 内存，得到 Class 类的对象&lt;/p&gt;
&lt;p&gt;从 Java 虚拟机规范来讲，只存在以下两种不同的类加载器：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;启动类加载器（Bootstrap ClassLoader）：使用 C++ 实现，是虚拟机自身的一部分&lt;/li&gt;
&lt;li&gt;自定义类加载器（User-Defined ClassLoader）：Java 虚拟机规范&lt;strong&gt;将所有派生于抽象类 ClassLoader 的类加载器都划分为自定义类加载器&lt;/strong&gt;，使用 Java 语言实现，独立于虚拟机&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从 Java 开发人员的角度看：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;启动类加载器（Bootstrap ClassLoader）：
&lt;ul&gt;
&lt;li&gt;处于安全考虑，Bootstrap 启动类加载器只加载包名为 java、javax、sun 等开头的类&lt;/li&gt;
&lt;li&gt;类加载器负责加载在 &lt;code&gt;JAVA_HOME/jre/lib&lt;/code&gt; 或 &lt;code&gt;sun.boot.class.path&lt;/code&gt; 目录中的，或者被 -Xbootclasspath 参数所指定的路径中的类，并且是虚拟机识别的类库加载到虚拟机内存中&lt;/li&gt;
&lt;li&gt;仅按照文件名识别，如 rt.jar 名字不符合的类库即使放在 lib 目录中也不会被加载&lt;/li&gt;
&lt;li&gt;启动类加载器无法被 Java 程序直接引用，编写自定义类加载器时，如果要把加载请求委派给启动类加载器，直接使用 null 代替&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;扩展类加载器（Extension ClassLoader）：
&lt;ul&gt;
&lt;li&gt;由 ExtClassLoader (sun.misc.Launcher$ExtClassLoader)  实现，上级为 Bootstrap，显示为 null&lt;/li&gt;
&lt;li&gt;将 &lt;code&gt;JAVA_HOME/jre/lib/ext&lt;/code&gt; 或者被 &lt;code&gt;java.ext.dir&lt;/code&gt; 系统变量所指定路径中的所有类库加载到内存中&lt;/li&gt;
&lt;li&gt;开发者可以使用扩展类加载器，创建的 JAR 放在此目录下，会由扩展类加载器自动加载&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;应用程序类加载器（Application ClassLoader）：
&lt;ul&gt;
&lt;li&gt;由 AppClassLoader(sun.misc.Launcher$AppClassLoader) 实现，上级为 Extension&lt;/li&gt;
&lt;li&gt;负责加载环境变量 classpath 或系统属性 &lt;code&gt;java.class.path&lt;/code&gt; 指定路径下的类库&lt;/li&gt;
&lt;li&gt;这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，因此称为系统类加载器&lt;/li&gt;
&lt;li&gt;可以直接使用这个类加载器，如果应用程序中没有自定义类加载器，这个就是程序中默认的类加载器&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;自定义类加载器：由开发人员自定义的类加载器，上级是 Application&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;//获取系统类加载器
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;ClassLoader&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;systemClassLoader&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ClassLoader&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getSystemClassLoader&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;systemClassLoader&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//sun.misc.Launcher$AppClassLoader@18b4aac2
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;//获取其上层  扩展类加载器
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;ClassLoader&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;extClassLoader&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;systemClassLoader&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getParent&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;extClassLoader&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//sun.misc.Launcher$ExtClassLoader@610455d6
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;//获取其上层 获取不到引导类加载器
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;ClassLoader&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bootStrapClassLoader&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;extClassLoader&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getParent&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bootStrapClassLoader&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//null
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;//对于用户自定义类来说：使用系统类加载器进行加载
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;ClassLoader&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;classLoader&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ClassLoaderTest&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;class&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getClassLoader&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;classLoader&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//sun.misc.Launcher$AppClassLoader@18b4aac2
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;//String 类使用引导类加载器进行加载的 --&amp;gt; java核心类库都是使用启动类加载器加载的
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;ClassLoader&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;classLoader1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;class&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getClassLoader&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;classLoader1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//null
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;补充两个类加载器：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SecureClassLoader 扩展了 ClassLoader，新增了几个与使用相关的代码源和权限定义类验证（对 class 源码的访问权限）的方法，一般不会直接跟这个类打交道，更多是与它的子类 URLClassLoader 有所关联&lt;/li&gt;
&lt;li&gt;ClassLoader 是一个抽象类，很多方法是空的没有实现，而 URLClassLoader 这个实现类为这些方法提供了具体的实现，并新增了 URLClassPath 类协助取得 Class 字节流等功能。在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承 URLClassLoader 类，这样就可以避免去编写 findClass() 方法及其获取字节码流的方式，使自定义类加载器编写更加简洁&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;常用api&#34;&gt;常用API&lt;/h3&gt;
&lt;p&gt;ClassLoader 类，是一个抽象类，其后所有的类加载器都继承自 ClassLoader（不包括启动类加载器）&lt;/p&gt;
&lt;p&gt;获取 ClassLoader 的途径：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;获取当前类的 ClassLoader：&lt;code&gt;clazz.getClassLoader()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;获取当前线程上下文的 ClassLoader：&lt;code&gt;Thread.currentThread.getContextClassLoader()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;获取系统的 ClassLoader：&lt;code&gt;ClassLoader.getSystemClassLoader()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;获取调用者的 ClassLoader：&lt;code&gt;DriverManager.getCallerClassLoader()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ClassLoader 类常用方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;getParent()&lt;/code&gt;：返回该类加载器的超类加载器&lt;/li&gt;
&lt;li&gt;&lt;code&gt;loadclass(String name)&lt;/code&gt;：加载名为 name 的类，返回结果为 Class 类的实例，&lt;strong&gt;该方法就是双亲委派模式&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;findclass(String name)&lt;/code&gt;：查找二进制名称为 name 的类，返回结果为 Class 类的实例，该方法会在检查完父类加载器之后被 loadClass() 方法调用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;findLoadedClass(String name)&lt;/code&gt;：查找名称为 name 的已经被加载过的类，final 修饰无法重写&lt;/li&gt;
&lt;li&gt;&lt;code&gt;defineClass(String name, byte[] b, int off, int len)&lt;/code&gt;：将&lt;strong&gt;字节流&lt;/strong&gt;解析成 JVM 能够识别的类对象&lt;/li&gt;
&lt;li&gt;&lt;code&gt;resolveclass(Class&amp;lt;?&amp;gt; c)&lt;/code&gt;：链接指定的 Java 类，可以使类的 Class 对象创建完成的同时也被解析&lt;/li&gt;
&lt;li&gt;&lt;code&gt;InputStream getResourceAsStream(String name)&lt;/code&gt;：指定资源名称获取输入流&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;加载模型&#34;&gt;加载模型&lt;/h3&gt;
&lt;h4 id=&#34;加载机制&#34;&gt;加载机制&lt;/h4&gt;
&lt;p&gt;在 JVM 中，对于类加载模型提供了三种，分别为全盘加载、双亲委派、缓存机制&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;全盘加载：&lt;/strong&gt; 当一个类加载器负责加载某个 Class 时，该 Class 所依赖和引用的其他 Class 也将由该类加载器负责载入，除非显示指定使用另外一个类加载器来载入&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;双亲委派：&lt;/strong&gt; 先让父类加载器加载该 Class，在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。简单来说就是，某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，&lt;strong&gt;依次递归&lt;/strong&gt;，如果父加载器可以完成类加载任务，就成功返回；只有当父加载器无法完成此加载任务时，才自己去加载&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;缓存机制：&lt;/strong&gt; 会保证所有加载过的 Class 都会被缓存，当程序中需要使用某个 Class 时，类加载器先从缓存区中搜寻该 Class，只有当缓存区中不存在该 Class 对象时，系统才会读取该类对应的二进制数据，并将其转换成 Class 对象存入缓冲区（方法区）中&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这就是修改了 Class 后，必须重新启动 JVM，程序所做的修改才会生效的原因&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;双亲委派&#34;&gt;双亲委派&lt;/h4&gt;
&lt;p&gt;双亲委派模型（Parents Delegation Model）：该模型要求除了顶层的启动类加载器外，其它类加载器都要有父类加载器，这里的父子关系一般通过组合关系（Composition）来实现，而不是继承关系（Inheritance）&lt;/p&gt;
&lt;p&gt;工作过程：一个类加载器首先将类加载请求转发到父类加载器，只有当父类加载器无法完成时才尝试自己加载&lt;/p&gt;
&lt;p&gt;双亲委派机制的优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;可以避免某一个类被重复加载，当父类已经加载后则无需重复加载，保证全局唯一性&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Java 类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;保护程序安全，防止类库的核心 API 被随意篡改&lt;/p&gt;
&lt;p&gt;例如：在工程中新建 java.lang 包，接着在该包下新建 String 类，并定义 main 函数&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;demo info&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;此时执行 main 函数，会出现异常，在类 java.lang.String 中找不到 main 方法，防止恶意篡改核心 API 库。出现该信息是因为双亲委派的机制，java.lang.String 的在启动类加载器（Bootstrap）得到加载，启动类加载器优先级更高，在核心 jre 库中有其相同名字的类文件，但该类中并没有 main 方法&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;双亲委派机制的缺点：检查类是否加载的委托过程是单向的，这个方式虽然从结构上看比较清晰，使各个 ClassLoader 的职责非常明确，但&lt;strong&gt;顶层的 ClassLoader 无法访问底层的 ClassLoader 所加载的类&lt;/strong&gt;（可见性）&lt;/p&gt;
&lt;h4 id=&#34;源码分析&#34;&gt;源码分析&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;protected&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Class&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;?&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;loadClass&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;boolean&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;resolve&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kd&#34;&gt;throws&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ClassNotFoundException&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kd&#34;&gt;synchronized&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;getClassLoadingLock&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;       &lt;span class=&#34;c1&#34;&gt;// 调用当前类加载器的 findLoadedClass(name)，检查当前类加载器是否已加载过指定 name 的类
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;n&#34;&gt;Class&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;findLoadedClass&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;// 当前类加载器如果没有加载过
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;t0&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;nanoTime&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;k&#34;&gt;try&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;c1&#34;&gt;// 判断当前类加载器是否有父类加载器
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;                &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;parent&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                    &lt;span class=&#34;c1&#34;&gt;// 如果当前类加载器有父类加载器，则调用父类加载器的 loadClass(name,false)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;         			&lt;span class=&#34;c1&#34;&gt;// 父类加载器的 loadClass 方法，又会检查自己是否已经加载过
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;                    &lt;span class=&#34;n&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;parent&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;loadClass&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                    &lt;span class=&#34;c1&#34;&gt;// 当前类加载器没有父类加载器，说明当前类加载器是 BootStrapClassLoader
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;          			&lt;span class=&#34;c1&#34;&gt;// 则调用 BootStrap ClassLoader 的方法加载类
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;                    &lt;span class=&#34;n&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;findBootstrapClassOrNull&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;catch&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ClassNotFoundException&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;c1&#34;&gt;// 如果调用父类的类加载器无法对类进行加载，则用自己的 findClass() 方法进行加载
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;                &lt;span class=&#34;c1&#34;&gt;// 可以自定义 findClass() 方法
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;                &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;t1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;nanoTime&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;n&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;findClass&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;c1&#34;&gt;// this is the defining class loader; record the stats
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;                &lt;span class=&#34;n&#34;&gt;sun&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;misc&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;PerfCounter&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getParentDelegationTime&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;addTime&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;t1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;t0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;n&#34;&gt;sun&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;misc&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;PerfCounter&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getFindClassTime&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;addElapsedTimeFrom&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;t1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;n&#34;&gt;sun&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;misc&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;PerfCounter&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getFindClasses&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;increment&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;resolve&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;c1&#34;&gt;// 链接指定的 Java 类，可以使类的 Class 对象创建完成的同时也被解析
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;n&#34;&gt;resolveClass&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h4 id=&#34;破坏委派&#34;&gt;破坏委派&lt;/h4&gt;
&lt;p&gt;双亲委派模型并不是一个具有强制性约束的模型，而是 Java 设计者推荐给开发者的类加载器实现方式&lt;/p&gt;
&lt;p&gt;破坏双亲委派模型的方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;自定义 ClassLoader&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果不想破坏双亲委派模型，只需要重写 findClass 方法&lt;/li&gt;
&lt;li&gt;如果想要去破坏双亲委派模型，需要去&lt;strong&gt;重写 loadClass&lt;/strong&gt;方法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;引入线程&lt;strong&gt;上下文类加载器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Java 提供了很多服务提供者接口（Service Provider Interface，SPI），允许第三方为这些接口提供实现。常见的 SPI 有 JDBC、JCE、JNDI 等。这些 SPI 接口由 Java 核心库来提供，而 SPI 的实现代码则是作为 Java 应用所依赖的 jar 包被包含进类路径 classpath 里，SPI 接口中的代码需要加载具体的实现类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SPI 的接口是 Java 核心库的一部分，是由引导类加载器来加载的&lt;/li&gt;
&lt;li&gt;SPI 的实现类是由系统类加载器加载，引导类加载器是无法找到 SPI 的实现类，因为双亲委派模型中 BootstrapClassloader 无法委派 AppClassLoader 来加载类&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;JDK 开发人员引入了线程上下文类加载器（Thread Context ClassLoader），这种类加载器可以通过 Thread  类的 setContextClassLoader 方法进行设置线程上下文类加载器，在执行线程中抛弃双亲委派加载模式，使程序可以逆向使用类加载器，使 Bootstrap 加载器拿到了 Application 加载器加载的类，破坏了双亲委派模型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实现程序的动态性，如代码热替换（Hot Swap）、模块热部署（Hot Deployment）&lt;/p&gt;
&lt;p&gt;IBM 公司主导的 JSR一291（OSGiR4.2）实现模块化热部署的关键是它自定义的类加载器机制的实现，每一个程序模块（OSGi 中称为 Bundle）都有一个自己的类加载器，当更换一个 Bundle 时，就把 Bundle 连同类加载器一起换掉以实现代码的热替换，在 OSGi 环境下，类加载器不再双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的网状结构&lt;/p&gt;
&lt;p&gt;当收到类加载请求时，OSGi 将按照下面的顺序进行类搜索:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将以 java.* 开头的类，委派给父类加载器加载&lt;/li&gt;
&lt;li&gt;否则，将委派列表名单内的类，委派给父类加载器加载&lt;/li&gt;
&lt;li&gt;否则，将 Import 列表中的类，委派给 Export 这个类的 Bundle 的类加载器加载&lt;/li&gt;
&lt;li&gt;否则，查找当前 Bundle 的 ClassPath，使用自己的类加载器加载&lt;/li&gt;
&lt;li&gt;否则，查找类是否在自己的 Fragment Bundle 中，如果在就委派给 Fragment Bundle 类加载器加载&lt;/li&gt;
&lt;li&gt;否则，查找 Dynamic Import 列表的 Bundle，委派给对应 Bundle 的类加载器加载&lt;/li&gt;
&lt;li&gt;否则，类查找失败&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;热替换是指在程序的运行过程中，不停止服务，只通过替换程序文件来修改程序的行为，&lt;strong&gt;热替换的关键需求在于服务不能中断&lt;/strong&gt;，修改必须立即表现正在运行的系统之中&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;对象创建&#34;&gt;对象创建&lt;/h2&gt;
&lt;h3 id=&#34;生命周期-1&#34;&gt;生命周期&lt;/h3&gt;
&lt;p&gt;在 Java 中，对象的生命周期包括以下几个阶段：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt; 创建阶段 (Created)：
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt; 应用阶段 (In Use)：对象至少被一个强引用持有着
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt; 不可见阶段 (Invisible)：程序的执行已经超出了该对象的作用域，不再持有该对象的任何强引用
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt; 不可达阶段 (Unreachable)：该对象不再被任何强引用所持有，包括 GC Root 的强引用
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt; 收集阶段 (Collected)：垃圾回收器对该对象的内存空间重新分配做好准备，该对象如果重写了 finalize() 方法，则会去执行该方法
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt; 终结阶段 (Finalized)：等待垃圾回收器对该对象空间进行回收，当对象执行完 finalize() 方法后仍然处于不可达状态时进入该阶段
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt; 对象空间重分配阶段 (De-allocated)：垃圾回收器对该对象的所占用的内存空间进行回收或者再分配
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;参考文章：https://blog.csdn.net/sodino/article/details/38387049&lt;/p&gt;
&lt;h3 id=&#34;创建时机&#34;&gt;创建时机&lt;/h3&gt;
&lt;p&gt;类在第一次实例化加载一次，后续实例化不再加载，引用第一次加载的类&lt;/p&gt;
&lt;p&gt;Java 对象创建时机：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;使用 new 关键字创建对象：由执行类实例创建表达式而引起的对象创建&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 Class 类的 newInstance 方法（反射机制）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 Constructor 类的 newInstance 方法（反射机制）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Student&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;id&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Student&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Integer&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;id&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;id&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;id&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;throws&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Exception&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;Constructor&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Student&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Student&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;class&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getConstructor&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Integer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;class&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;Student&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;stu&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;newInstance&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;123&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;使用 newInstance 方法的这两种方式创建对象使用的就是 Java 的反射机制，事实上 Class 的 newInstance 方法内部调用的也是 Constructor 的 newInstance 方法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 Clone 方法创建对象：用 clone 方法创建对象的过程中并不会调用任何构造函数，要想使用 clone 方法，我们就必须先实现 Cloneable 接口并实现其定义的 clone 方法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用（反）序列化机制创建对象：当反序列化一个对象时，JVM 会创建一个&lt;strong&gt;单独的对象&lt;/strong&gt;，在此过程中，JVM 并不会调用任何构造函数，为了反序列化一个对象，需要让类实现 Serializable 接口&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;从 Java 虚拟机层面看，除了使用 new 关键字创建对象的方式外，其他方式全部都是通过转变为 invokevirtual 指令直接创建对象的&lt;/p&gt;
&lt;h3 id=&#34;创建过程&#34;&gt;创建过程&lt;/h3&gt;
&lt;p&gt;创建对象的过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;判断对象对应的类是否加载、链接、初始化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为对象分配内存：指针碰撞、空闲链表。当一个对象被创建时，虚拟机就会为其分配内存来存放对象的实例变量及其从父类继承过来的实例变量，即使从&lt;strong&gt;隐藏变量&lt;/strong&gt;也会被分配空间（继承部分解释了为什么会隐藏）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;处理并发安全问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;采用 CAS 配上自旋保证更新的原子性&lt;/li&gt;
&lt;li&gt;每个线程预先分配一块 TLAB&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;初始化分配的空间：虚拟机将分配到的内存空间都初始化为零值（不包括对象头），保证对象实例字段在不赋值时可以直接使用，程序能访问到这些字段的数据类型所对应的零值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设置对象的对象头：将对象的所属类（类的元数据信息）、对象的 HashCode、对象的 GC 信息、锁信息等数据存储在对象头中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;执行 init 方法进行实例化：实例变量初始化、实例代码块初始化 、构造函数初始化&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;实例变量初始化与实例代码块初始化：&lt;/p&gt;
&lt;p&gt;对实例变量直接赋值或者使用实例代码块赋值，&lt;strong&gt;编译器会将其中的代码放到类的构造函数中去&lt;/strong&gt;，并且这些代码会被放在对超类构造函数的调用语句之后（Java 要求构造函数的第一条语句必须是超类构造函数的调用语句），构造函数本身的代码之前&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;构造函数初始化：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Java 要求在实例化类之前，必须先实例化其超类，以保证所创建实例的完整性&lt;/strong&gt;，在准备实例化一个类的对象前，首先准备实例化该类的父类，如果该类的父类还有父类，那么准备实例化该类的父类的父类，依次递归直到递归到 Object 类。然后从 Object 类依次对以下各类进行实例化，初始化父类中的变量和执行构造函数&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;tlab&#34;&gt;TLAB&lt;/h4&gt;
&lt;p&gt;TLAB：Thread Local Allocation Buffer，为每个线程在堆内单独分配了一个缓冲区，多线程分配内存时，使用 TLAB 可以避免线程安全问题，同时还能够提升内存分配的吞吐量，这种内存分配方式叫做&lt;strong&gt;快速分配策略&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;栈上分配使用的是栈来进行对象内存的分配&lt;/li&gt;
&lt;li&gt;TLAB 分配使用的是 Eden 区域进行内存分配，属于堆内存&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据，由于对象实例的创建在 JVM 中非常频繁，因此在并发环境下为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度&lt;/p&gt;
&lt;p&gt;问题：堆空间都是共享的么？ 不一定，因为还有 TLAB，在堆中划分出一块区域，为每个线程所独占&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/java/jvm-%E7%B1%BB%E5%8A%A0%E8%BD%BD/JVM-TLAB%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5.jpg&#34;
	width=&#34;1019&#34;
	height=&#34;508&#34;
	srcset=&#34;https://isheihei.github.io/posts/java/jvm-%E7%B1%BB%E5%8A%A0%E8%BD%BD/JVM-TLAB%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5_hu7bee462e369a6bde2c91f390735a88cb_81901_480x0_resize_q75_box.jpg 480w, https://isheihei.github.io/posts/java/jvm-%E7%B1%BB%E5%8A%A0%E8%BD%BD/JVM-TLAB%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5_hu7bee462e369a6bde2c91f390735a88cb_81901_1024x0_resize_q75_box.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;JVM-TLAB内存分配策略&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;200&#34;
		data-flex-basis=&#34;481px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;JVM 是将 TLAB 作为内存分配的首选，但不是所有的对象实例都能够在 TLAB 中成功分配内存，一旦对象在 TLAB 空间分配内存失败时，JVM 就会通过&lt;strong&gt;使用加锁机制确保数据操作的原子性&lt;/strong&gt;，从而直接在堆中分配内存&lt;/p&gt;
&lt;p&gt;栈上分配优先于 TLAB 分配进行，逃逸分析中若可进行栈上分配优化，会优先进行对象栈上直接分配内存&lt;/p&gt;
&lt;p&gt;参数设置：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-XX:UseTLAB&lt;/code&gt;：设置是否开启 TLAB 空间&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-XX:TLABWasteTargetPercent&lt;/code&gt;：设置 TLAB 空间所占用 Eden 空间的百分比大小，默认情况下 TLAB 空间的内存非常小，仅占有整个 Eden 空间的1%&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-XX:TLABRefillWasteFraction&lt;/code&gt;：指当 TLAB 空间不足，请求分配的对象内存大小超过此阈值时不会进行 TLAB 分配，直接进行堆内存分配，否则还是会优先进行 TLAB 分配&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/java/jvm-%E7%B1%BB%E5%8A%A0%E8%BD%BD/JVM-TLAB%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E8%BF%87%E7%A8%8B.jpg&#34;
	width=&#34;1048&#34;
	height=&#34;487&#34;
	srcset=&#34;https://isheihei.github.io/posts/java/jvm-%E7%B1%BB%E5%8A%A0%E8%BD%BD/JVM-TLAB%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E8%BF%87%E7%A8%8B_hu207684061cb338e73386fb993f778b6e_163864_480x0_resize_q75_box.jpg 480w, https://isheihei.github.io/posts/java/jvm-%E7%B1%BB%E5%8A%A0%E8%BD%BD/JVM-TLAB%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E8%BF%87%E7%A8%8B_hu207684061cb338e73386fb993f778b6e_163864_1024x0_resize_q75_box.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;JVM-TLAB内存分配过程&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;215&#34;
		data-flex-basis=&#34;516px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;承上启下&#34;&gt;承上启下&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;一个实例变量在对象初始化的过程中会被赋值几次？一个实例变量最多可以被初始化 4 次&lt;/p&gt;
&lt;p&gt;JVM 在为一个对象分配完内存之后，会给每一个实例变量赋予默认值，这个实例变量被第一次赋值；在声明实例变量的同时对其进行了赋值操作，那么这个实例变量就被第二次赋值；在实例代码块中又对变量做了初始化操作，那么这个实例变量就被第三次赋值；在构造函数中也对变量做了初始化操作，那么这个实例变量就被第四次赋值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;类的初始化过程与类的实例化过程的异同？&lt;/p&gt;
&lt;p&gt;类的初始化是指类加载过程中的初始化阶段对类变量按照代码进行赋值的过程；类的实例化是指在类完全加载到内存中后创建对象的过程（类的实例化触发了类的初始化，先初始化才能实例化）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;假如一个类还未加载到内存中，那么在创建一个该类的实例时，具体过程是怎样的？（&lt;strong&gt;经典案例&lt;/strong&gt;）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;StaticTest&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;staticFunction&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//调用静态方法，触发初始化
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;StaticTest&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;st&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;StaticTest&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;   &lt;span class=&#34;c1&#34;&gt;//静态代码块
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;1&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;       &lt;span class=&#34;c1&#34;&gt;// 实例代码块
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;2&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;StaticTest&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 实例构造器
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;3&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;a=&amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;,b=&amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;staticFunction&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;   &lt;span class=&#34;c1&#34;&gt;// 静态方法
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;4&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;110&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;    		&lt;span class=&#34;c1&#34;&gt;// 实例变量
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;112&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;     &lt;span class=&#34;c1&#34;&gt;// 静态变量
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;/* Output: 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;        2
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;        3
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;        a=110,b=0
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;        1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;        4
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; */&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//:~
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;code&gt;static StaticTest st = new StaticTest();&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;实例实例化不一定要在类初始化结束之后才开始&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在同一个类加载器下，一个类型只会被初始化一次。所以一旦开始初始化一个类，无论是否完成后续都不会再重新触发该类型的初始化阶段了（只考虑在同一个类加载器下的情形）。因此在实例化上述程序中的 st 变量时，&lt;strong&gt;实际上是把实例化嵌入到了静态初始化流程中，并且在上面的程序中，嵌入到了静态初始化的起始位置&lt;/strong&gt;，这就导致了实例初始化完全发生在静态初始化之前，这也是导致 a 为 110，b 为 0 的原因&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;代码等价于：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;StaticTest&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;clinit&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;(){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;110&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 实例变量
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;2&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;// 实例代码块
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;3&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;// 实例构造器中代码的执行
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;a=&amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;,b=&amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// 实例构造器中代码的执行
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;n&#34;&gt;类变量st被初始化&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;1&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;//静态代码块
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;n&#34;&gt;类变量b被初始化为112&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>JVM-垃圾回收</title>
        <link>https://isheihei.github.io/posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/</link>
        <pubDate>Tue, 24 May 2022 17:24:10 +0800</pubDate>
        
        <guid>https://isheihei.github.io/posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/</guid>
        <description>&lt;h2 id=&#34;可达性分析&#34;&gt;可达性分析&lt;/h2&gt;
&lt;h3 id=&#34;gc-roots&#34;&gt;GC Roots&lt;/h3&gt;
&lt;p&gt;可达性分析算法：也可以称为根搜索算法、追踪性垃圾收集&lt;/p&gt;
&lt;p&gt;GC Roots 对象：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;虚拟机栈中局部变量表中引用的对象：各个线程被调用的方法中使用到的参数、局部变量等&lt;/li&gt;
&lt;li&gt;本地方法栈中引用的对象&lt;/li&gt;
&lt;li&gt;堆中类静态属性引用的对象&lt;/li&gt;
&lt;li&gt;方法区中的常量引用的对象&lt;/li&gt;
&lt;li&gt;字符串常量池（string Table）里的引用&lt;/li&gt;
&lt;li&gt;同步锁 synchronized 持有的对象&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;GC Roots 是一组活跃的引用，不是对象&lt;/strong&gt;，放在 GC Roots Set 集合&lt;/p&gt;
&lt;h3 id=&#34;工作原理&#34;&gt;工作原理&lt;/h3&gt;
&lt;p&gt;可达性分析算法以根对象集合（GCRoots）为起始点，从上至下的方式搜索被根对象集合所连接的目标对象&lt;/p&gt;
&lt;p&gt;分析工作必须在一个保障&lt;strong&gt;一致性的快照&lt;/strong&gt;中进行，否则结果的准确性无法保证，这也是导致 GC 进行时必须 Stop The World 的一个原因&lt;/p&gt;
&lt;p&gt;基本原理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索走过的路径称为引用链&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/JVM-%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95.png&#34;
	width=&#34;1057&#34;
	height=&#34;710&#34;
	srcset=&#34;https://isheihei.github.io/posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/JVM-%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95_hua2c8e35785c8874fd8d82cf317422726_75374_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/JVM-%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95_hua2c8e35785c8874fd8d82cf317422726_75374_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;JVM-可达性分析算法&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;148&#34;
		data-flex-basis=&#34;357px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;三色标记&#34;&gt;三色标记&lt;/h3&gt;
&lt;h3 id=&#34;标记算法&#34;&gt;标记算法&lt;/h3&gt;
&lt;p&gt;三色标记法把遍历对象图过程中遇到的对象，标记成以下三种颜色：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;白色：尚未访问过&lt;/li&gt;
&lt;li&gt;灰色：本对象已访问过，但是本对象引用到的其他对象尚未全部访问&lt;/li&gt;
&lt;li&gt;黑色：本对象已访问过，而且本对象引用到的其他对象也全部访问完成&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当 Stop The World (STW) 时，对象间的引用是不会发生变化的，可以轻松完成标记，遍历访问过程为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;初始时，所有对象都在白色集合&lt;/li&gt;
&lt;li&gt;将 GC Roots 直接引用到的对象挪到灰色集合&lt;/li&gt;
&lt;li&gt;从灰色集合中获取对象：
&lt;ul&gt;
&lt;li&gt;将本对象引用到的其他对象全部挪到灰色集合中&lt;/li&gt;
&lt;li&gt;将本对象挪到黑色集合里面&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;重复步骤 3，直至灰色集合为空时结束&lt;/li&gt;
&lt;li&gt;结束后，仍在白色集合的对象即为 GC Roots 不可达，可以进行回收&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/JVM-%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95%E8%BF%87%E7%A8%8B.gif&#34;
	width=&#34;706&#34;
	height=&#34;451&#34;
	srcset=&#34;https://isheihei.github.io/posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/JVM-%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95%E8%BF%87%E7%A8%8B_hud33a6cf6e4a2927aebe73fd8a24ced0d_152861_480x0_resize_box.gif 480w, https://isheihei.github.io/posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/JVM-%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95%E8%BF%87%E7%A8%8B_hud33a6cf6e4a2927aebe73fd8a24ced0d_152861_1024x0_resize_box.gif 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;JVM-三色标记法过程&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;156&#34;
		data-flex-basis=&#34;375px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;并发标记&#34;&gt;并发标记&lt;/h3&gt;
&lt;p&gt;并发标记时，对象间的引用可能发生变化，多标和漏标的情况就有可能发生&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多标情况：&lt;strong&gt;当 E 变为灰色或黑色时，其他线程断开的 D 对 E 的引用，导致这部分对象仍会被标记为存活，本轮 GC 不会回收这部分内存，这部分本应该回收但是没有回收到的内存，被称之为&lt;/strong&gt;浮动垃圾&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;针对并发标记开始后的&lt;strong&gt;新对象&lt;/strong&gt;，通常的做法是直接全部当成黑色，也算浮动垃圾&lt;/li&gt;
&lt;li&gt;浮动垃圾并不会影响应用程序的正确性，只是需要等到下一轮垃圾回收中才被清除&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/JVM-%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95%E5%A4%9A%E6%A0%87%E6%83%85%E5%86%B5.png&#34;
	width=&#34;683&#34;
	height=&#34;420&#34;
	srcset=&#34;https://isheihei.github.io/posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/JVM-%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95%E5%A4%9A%E6%A0%87%E6%83%85%E5%86%B5_hu693bfcae16628182766291aa82f4317e_13278_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/JVM-%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95%E5%A4%9A%E6%A0%87%E6%83%85%E5%86%B5_hu693bfcae16628182766291aa82f4317e_13278_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;JVM-三色标记法多标情况&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;162&#34;
		data-flex-basis=&#34;390px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;漏标情况：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;条件一：灰色对象断开了对一个白色对象的引用（直接或间接），即灰色对象原成员变量的引用发生了变化&lt;/li&gt;
&lt;li&gt;条件二：其他线程中修改了黑色对象，插入了一条或多条对该白色对象的新引用&lt;/li&gt;
&lt;li&gt;结果：导致该白色对象当作垃圾被 GC，影响到了程序的正确性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/JVM-%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95%E6%BC%8F%E6%A0%87%E6%83%85%E5%86%B5.png&#34;
	width=&#34;689&#34;
	height=&#34;432&#34;
	srcset=&#34;https://isheihei.github.io/posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/JVM-%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95%E6%BC%8F%E6%A0%87%E6%83%85%E5%86%B5_hub7806eff3b888461f9e8c79abec69ead_14122_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/JVM-%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95%E6%BC%8F%E6%A0%87%E6%83%85%E5%86%B5_hub7806eff3b888461f9e8c79abec69ead_14122_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;JVM-三色标记法漏标情况&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;159&#34;
		data-flex-basis=&#34;382px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;代码角度解释漏标：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;Object&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;G&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;objE&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;fieldG&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 读
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;objE&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;fieldG&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;  	&lt;span class=&#34;c1&#34;&gt;// 写
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;objD&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;fieldG&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;G&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;     	&lt;span class=&#34;c1&#34;&gt;// 写
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;为了解决问题，可以操作上面三步，&lt;strong&gt;将对象 G 记录起来，然后作为灰色对象再进行遍历&lt;/strong&gt;，比如放到一个特定的集合，等初始的 GC Roots 遍历完（并发标记），再遍历该集合（重新标记）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;所以&lt;strong&gt;重新标记需要 STW&lt;/strong&gt;，应用程序一直在运行，该集合可能会一直增加新的对象，导致永远都运行不完&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;解决方法：添加读写屏障，读屏障拦截第一步，写屏障拦截第二三步，在读写前后进行一些后置处理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;写屏障 + 增量更新&lt;/strong&gt;：黑色对象新增引用，会将黑色对象变成灰色对象，最后对该节点重新扫描&lt;/p&gt;
&lt;p&gt;增量更新 (Incremental Update) 破坏了条件二，从而保证了不会漏标&lt;/p&gt;
&lt;p&gt;缺点：对黑色变灰的对象重新扫描所有引用，比较耗费时间&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;写屏障 (Store Barrier) + SATB&lt;/strong&gt;：当原来成员变量的引用发生变化之前，记录下原来的引用对象&lt;/p&gt;
&lt;p&gt;保留 GC 开始时的对象图，即原始快照 SATB，当 GC Roots 确定后，对象图就已经确定，那后续的标记也应该是按照这个时刻的对象图走，如果期间对白色对象有了新的引用会记录下来，并且将白色对象变灰（说明可达了），重新扫描该对象的引用关系&lt;/p&gt;
&lt;p&gt;SATB (Snapshot At The Beginning) 破坏了条件一，从而保证了不会漏标&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;读屏障 (Load Barrier)&lt;/strong&gt;：破坏条件二，黑色对象引用白色对象的前提是获取到该对象，此时读屏障发挥作用&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以 Java HotSpot VM 为例，其并发标记时对漏标的处理方案如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CMS：写屏障 + 增量更新&lt;/li&gt;
&lt;li&gt;G1：写屏障 + SATB&lt;/li&gt;
&lt;li&gt;ZGC：读屏障&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;垃圾回收器&#34;&gt;垃圾回收器&lt;/h2&gt;
&lt;h3 id=&#34;普通&#34;&gt;普通&lt;/h3&gt;
&lt;h4 id=&#34;serial&#34;&gt;Serial&lt;/h4&gt;
&lt;p&gt;Serial：串行垃圾收集器，作用于新生代，是指使用单线程进行垃圾回收，采用&lt;strong&gt;复制算法&lt;/strong&gt;，新生代基本都是复制算法，因为分区了&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;STW（Stop-The-World）&lt;/strong&gt;：垃圾回收时，只有一个线程在工作，并且 Java 应用中的所有线程都要暂停，等待垃圾回收的完成&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Serial old&lt;/strong&gt;：执行老年代垃圾回收的串行收集器，内存回收算法使用的是&lt;strong&gt;标记-整理算法&lt;/strong&gt;，同样也采用了串行回收和 STW 机制&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Serial old 是 Client 模式下默认的老年代的垃圾回收器&lt;/li&gt;
&lt;li&gt;Serial old 在 Server 模式下主要有两个用途：
&lt;ul&gt;
&lt;li&gt;在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用&lt;/li&gt;
&lt;li&gt;作为老年代 CMS 收集器的&lt;strong&gt;后备垃圾回收方案&lt;/strong&gt;，在并发收集发生 Concurrent Mode Failure 时使用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;开启参数：&lt;code&gt;-XX:+UseSerialGC&lt;/code&gt; 等价于新生代用 Serial GC 且老年代用 Serial old GC&lt;/p&gt;
&lt;p&gt;优点：简单而高效（与其他收集器的单线程比），对于限定单个 CPU 的环境来说，Serial 收集器由于没有线程交互的开销，可以获得最高的单线程收集效率&lt;/p&gt;
&lt;p&gt;缺点：对于交互性较强的应用而言，这种垃圾收集器是不能够接受的，比如 JavaWeb 应用&lt;/p&gt;
&lt;h4 id=&#34;parnew&#34;&gt;ParNew&lt;/h4&gt;
&lt;p&gt;Par 是 Parallel 并行的缩写，&lt;strong&gt;New 是只能处理的是新生代&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;并行垃圾收集器在串行垃圾收集器的基础之上做了改进，&lt;strong&gt;采用复制算法&lt;/strong&gt;，将单线程改为了多线程进行垃圾回收，可以缩短垃圾回收的时间&lt;/p&gt;
&lt;p&gt;对于其他的行为（收集算法、stop the world、对象分配规则、回收策略等）同 Serial 收集器一样，应用在年轻代，除 Serial 外，只有&lt;strong&gt;ParNew GC 能与 CMS 收集器配合工作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;相关参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-XX：+UseParNewGC&lt;/code&gt;：表示年轻代使用并行收集器，不影响老年代&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-XX:ParallelGCThreads&lt;/code&gt;：默认开启和 CPU 数量相同的线程数&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ParNew 是很多 JVM 运行在 Server 模式下新生代的默认垃圾收集器&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于新生代，回收次数频繁，使用并行方式高效&lt;/li&gt;
&lt;li&gt;对于老年代，回收次数少，使用串行方式节省资源（CPU 并行需要切换线程，串行可以省去切换线程的资源）&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;parallel&#34;&gt;Parallel&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Parallel Scavenge&lt;/strong&gt; 收集器是应用于新生代的并行垃圾回收器，&lt;strong&gt;采用复制算法&lt;/strong&gt;、并行回收和 Stop the World 机制&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Parallel Old&lt;/strong&gt; 收集器：是一个应用于老年代的并行垃圾回收器，&lt;strong&gt;采用标记-整理算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对比其他回收器：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;其它收集器目标是尽可能缩短垃圾收集时用户线程的停顿时间&lt;/li&gt;
&lt;li&gt;Parallel 目标是达到一个可控制的吞吐量，被称为&lt;strong&gt;吞吐量优先&lt;/strong&gt;收集器&lt;/li&gt;
&lt;li&gt;Parallel Scavenge 对比 ParNew 拥有&lt;strong&gt;自适应调节策略&lt;/strong&gt;，可以通过一个开关参数打开 GC Ergonomics&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;应用场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验&lt;/li&gt;
&lt;li&gt;高吞吐量可以高效率地利用 CPU 时间，尽快完成程序的运算任务，适合在后台运算而不需要太多交互&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;停顿时间和吞吐量的关系：新生代空间变小 → 缩短停顿时间 → 垃圾回收变得频繁 → 导致吞吐量下降&lt;/p&gt;
&lt;p&gt;在注重吞吐量及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge + Parallel Old 收集器，在 Server 模式下的内存回收性能很好，&lt;strong&gt;Java8 默认是此垃圾收集器组合&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;参数配置：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-XX：+UseParallelGC&lt;/code&gt;：手动指定年轻代使用 Paralle 并行收集器执行内存回收任务&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-XX：+UseParalleloldcc&lt;/code&gt;：手动指定老年代使用并行回收收集器执行内存回收任务
&lt;ul&gt;
&lt;li&gt;上面两个参数，默认开启一个，另一个也会被开启（互相激活），默认 JDK8 是开启的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-XX:+UseAdaptivesizepplicy&lt;/code&gt;：设置 Parallel scavenge 收集器具有&lt;strong&gt;自适应调节策略&lt;/strong&gt;，在这种模式下，年轻代的大小、Eden 和 Survivor 的比例、晋升老年代的对象年龄等参数会被自动调整，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-XX:ParallelGcrhreads&lt;/code&gt;：设置年轻代并行收集器的线程数，一般与 CPU 数量相等，以避免过多的线程数影响垃圾收集性能
&lt;ul&gt;
&lt;li&gt;在默认情况下，当 CPU 数量小于 8 个，ParallelGcThreads 的值等于 CPU 数量&lt;/li&gt;
&lt;li&gt;当 CPU 数量大于 8 个，ParallelGCThreads 的值等于 3+[5*CPU Count]/8]&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-XX:MaxGCPauseMillis&lt;/code&gt;：设置垃圾收集器最大停顿时间（即 STW 的时间），单位是毫秒
&lt;ul&gt;
&lt;li&gt;对于用户来讲，停顿时间越短体验越好；在服务器端，注重高并发，整体的吞吐量&lt;/li&gt;
&lt;li&gt;为了把停顿时间控制在 MaxGCPauseMillis 以内，收集器在工作时会调整 Java 堆大小或其他一些参数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-XX:GCTimeRatio&lt;/code&gt;：垃圾收集时间占总时间的比例 =1/(N+1)，用于衡量吞吐量的大小
&lt;ul&gt;
&lt;li&gt;取值范围（0，100）。默认值 99，也就是垃圾回收时间不超过 1&lt;/li&gt;
&lt;li&gt;与 &lt;code&gt;-xx:MaxGCPauseMillis&lt;/code&gt; 参数有一定矛盾性，暂停时间越长，Radio 参数就容易超过设定的比例&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;并发&#34;&gt;并发&lt;/h3&gt;
&lt;h4 id=&#34;cms&#34;&gt;CMS&lt;/h4&gt;
&lt;p&gt;CMS 全称 Concurrent Mark Sweep，是一款&lt;strong&gt;并发的、使用标记-清除&lt;/strong&gt;算法、针对老年代的垃圾回收器，其最大特点是&lt;strong&gt;让垃圾收集线程与用户线程同时工作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;CMS 收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间，停顿时间越短（&lt;strong&gt;低延迟&lt;/strong&gt;）越适合与用户交互的程序，良好的响应速度能提升用户体验&lt;/p&gt;
&lt;p&gt;分为以下四个流程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初始标记：使用 STW 出现短暂停顿，仅标记一下 GC Roots 能直接关联到的对象，速度很快&lt;/li&gt;
&lt;li&gt;并发标记：进行 GC Roots 开始遍历整个对象图，在整个回收过程中耗时最长，不需要 STW，可以与用户线程并发运行&lt;/li&gt;
&lt;li&gt;重新标记：修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，比初始标记时间长但远比并发标记时间短，需要 STW（不停顿就会一直变化，采用写屏障 + 增量更新来避免漏标情况）&lt;/li&gt;
&lt;li&gt;并发清除：清除标记为可以回收对象，&lt;strong&gt;不需要移动存活对象&lt;/strong&gt;，所以这个阶段可以与用户线程同时并发的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Mark Sweep 会造成内存碎片，不把算法换成 Mark Compact 的原因：Mark Compact 算法会整理内存，导致用户线程使用的&lt;strong&gt;对象的地址改变&lt;/strong&gt;，影响用户线程继续执行&lt;/p&gt;
&lt;p&gt;在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/JVM-CMS%E6%94%B6%E9%9B%86%E5%99%A8.png&#34;
	width=&#34;1061&#34;
	height=&#34;328&#34;
	srcset=&#34;https://isheihei.github.io/posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/JVM-CMS%E6%94%B6%E9%9B%86%E5%99%A8_hu56ccf0817be9cd7594dce5ab3d2c7565_171134_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/JVM-CMS%E6%94%B6%E9%9B%86%E5%99%A8_hu56ccf0817be9cd7594dce5ab3d2c7565_171134_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;JVM-CMS收集器&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;323&#34;
		data-flex-basis=&#34;776px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;优点：并发收集、低延迟&lt;/p&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;吞吐量降低：在并发阶段虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，CPU 利用率不够高&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;CMS&lt;/code&gt;是一个很好的并发垃圾收集器,但是使用过程中会产生两个重要的问题。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;promotion failed 晋升失败&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;该问题发生在&lt;code&gt;Minor GC&lt;/code&gt;过程中,&lt;code&gt;Survivor Space&lt;/code&gt;放不下转移的对象,老年代也放不下(promotion failed发生的时候老年代CMS还没有机会进行回收,又放不下转移到老年代的对象,下一步就会产生&lt;code&gt;concurrent mode fialure&lt;/code&gt;,发生STW降级为Serial Old)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;concurrent mode failure 收集器无法处理浮动垃圾&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;concurrent mode failure是CMS特有的错误,CMS的垃圾清理线程和用户线程是并行进行的. 老年代正在清理,从年轻代晋升了新对象，或者分配的大对象在新生代放不下,直接在老年代分配内存,这时老年代也放不下,则会抛出concurrent mode failure。这时老年代的垃圾收集器从&lt;code&gt;CMS&lt;/code&gt;退化成&lt;code&gt;Serial Old&lt;/code&gt;,所有用户线程被暂停,停顿时间变长。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;解决方案&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CMS触发太晚&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;-XX:CMSInitiatingOccupancyFraction=N&lt;/code&gt; 是指设定CMS在对内存占用率达到N%的时候开始GC(因为CMS会有浮动垃圾,所以一般都较早启动GC);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;将:&lt;code&gt;-XX:CMSInitiatingOccupancyFraction=N&lt;/code&gt;调小&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;空间碎片太多&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;开启空间碎片整理,并将空间碎片整理周期设置在合理范围,-&lt;code&gt;XX:CMSFullGCsBeforeCompaction&lt;/code&gt;作用：设置在执行多少次Full GC后对内存空间进行压缩整理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;-XX:+UseCMSCompactAtFullCollection （空间碎片整理）&lt;/li&gt;
&lt;li&gt;-XX:CMSFullGCsBeforeCompaction=n&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;垃圾产生太快&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;晋升阈值太小&lt;/li&gt;
&lt;li&gt;Survivor空间过小&lt;/li&gt;
&lt;li&gt;Eden区过小,导致晋升速率过快&lt;/li&gt;
&lt;li&gt;存在大对象&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;标记 - 清除算法导致的空间碎片，往往出现老年代空间无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC；为新对象分配内存空间时，将无法使用指针碰撞（Bump the Pointer）技术，而只能够选择空闲列表（Free List）执行内存分配&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参数设置：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-XX：+UseConcMarkSweepGC&lt;/code&gt;：手动指定使用 CMS 收集器执行内存回收任务&lt;/p&gt;
&lt;p&gt;开启该参数后会自动将 &lt;code&gt;-XX:+UseParNewGC&lt;/code&gt; 打开，即：ParNew + CMS + Serial old的组合&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-XX:CMSInitiatingoccupanyFraction&lt;/code&gt;：设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JDK5 及以前版本的默认值为 68，即当老年代的空间使用率达到 68% 时，会执行一次CMS回收&lt;/li&gt;
&lt;li&gt;JDK6 及以上版本默认值为 92%&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-XX:+UseCMSCompactAtFullCollection&lt;/code&gt;：用于指定在执行完 Full GC 后对内存空间进行压缩整理，以此避免内存碎片的产生，由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-XX:CMSFullGCsBeforecompaction&lt;/code&gt;：&lt;strong&gt;设置在执行多少次 Full GC 后对内存空间进行压缩整理&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-XX:ParallelCMSThreads&lt;/code&gt;：设置 CMS 的线程数量&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CMS 默认启动的线程数是 (ParallelGCThreads+3)/4，ParallelGCThreads 是年轻代并行收集器的线程数&lt;/li&gt;
&lt;li&gt;收集线程占用的 CPU 资源多于25%，对用户程序影响可能较大；当 CPU 资源比较紧张时，受到 CMS 收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;g1-收集器&#34;&gt;G1 收集器&lt;/h4&gt;
&lt;h5 id=&#34;g1-特点&#34;&gt;G1 特点&lt;/h5&gt;
&lt;p&gt;G1（Garbage-First）是一款面向服务端应用的垃圾收集器，&lt;strong&gt;应用于新生代和老年代&lt;/strong&gt;、采用标记-整理算法、软实时、低延迟、可设定目标（最大 STW 停顿时间）的垃圾回收器，用于代替 CMS，适用于较大的堆（&amp;gt;4 ~ 6G），在 JDK9 之后默认使用 G1&lt;/p&gt;
&lt;p&gt;G1 对比其他处理器的优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;并发与并行：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;并行性：G1 在回收期间，可以有多个 GC 线程同时工作，有效利用多核计算能力，此时用户线程 STW&lt;/li&gt;
&lt;li&gt;并发性：G1 拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此不会在整个回收阶段发生完全阻塞应用程序的情况&lt;/li&gt;
&lt;li&gt;其他的垃圾收集器使用内置的 JVM 线程执行 GC 的多线程操作，而 G1 GC 可以采用应用线程承担后台运行的 GC 工作，JVM 的 GC 线程处理速度慢时，系统会&lt;strong&gt;调用应用程序线程加速垃圾回收&lt;/strong&gt;过程&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;分区算法&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;从分代上看，G1  属于分代型垃圾回收器，区分年轻代和老年代，年轻代依然有 Eden 区和 Survivor 区。从堆结构上看，&lt;strong&gt;新生代和老年代不再物理隔离&lt;/strong&gt;，不用担心每个代内存是否足够，这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次 GC&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将整个堆划分成约 2048 个大小相同的独立 Region 块，每个 Region 块大小根据堆空间的实际大小而定，整体被控制在 1MB 到 32 MB之间且为 2 的 N 次幂，所有 Region 大小相同，在 JVM 生命周期内不会被改变。G1 把堆划分成多个大小相等的独立区域，使得每个小空间可以单独进行垃圾回收&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;新的区域 Humongous&lt;/strong&gt;：本身属于老年代区，当出现了一个巨型对象超出了分区容量的一半，该对象就会进入到该区域。如果一个 H 区装不下一个巨型对象，那么 G1 会寻找连续的 H 分区来存储，为了能找到连续的 H 区，有时候不得不启动 Full GC&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;G1 不会对巨型对象进行拷贝，回收时被优先考虑，G1 会跟踪老年代所有 incoming 引用，这样老年代 incoming 引用为 0 的巨型对象就可以在新生代垃圾回收时处理掉&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Region 结构图：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;​			&lt;img src=&#34;https://isheihei.github.io/posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/JVM-G1-Region%E5%8C%BA%E5%9F%9F.png&#34;
	width=&#34;681&#34;
	height=&#34;280&#34;
	srcset=&#34;https://isheihei.github.io/posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/JVM-G1-Region%E5%8C%BA%E5%9F%9F_huf114de2626066fe03e2f4c8cb0ab4be8_110250_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/JVM-G1-Region%E5%8C%BA%E5%9F%9F_huf114de2626066fe03e2f4c8cb0ab4be8_110250_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;JVM-G1-Region区域&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;243&#34;
		data-flex-basis=&#34;583px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;空间整合：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CMS：标记-清除算法、内存碎片、若干次 GC 后进行一次碎片整理&lt;/li&gt;
&lt;li&gt;G1：整体来看是基于标记 - 整理算法实现的收集器，从局部（Region 之间）上来看是基于复制算法实现的，两种算法都可以避免内存碎片&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;可预测的停顿时间模型（软实时 soft real-time）&lt;/strong&gt;：可以指定在 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由于分块的原因，G1 可以只选取部分区域进行内存回收，这样缩小了回收的范围，对于全局停顿情况也能得到较好的控制&lt;/li&gt;
&lt;li&gt;G1 跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间，通过过去回收的经验获得），在后台维护一个&lt;strong&gt;优先列表&lt;/strong&gt;，每次根据允许的收集时间优先回收价值最大的 Region，保证了 G1 收集器在有限的时间内可以获取尽可能高的收集效率&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;相比于 CMS GC，G1 未必能做到 CMS 在最好情况下的延时停顿，但是最差情况要好很多&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;G1 垃圾收集器的缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;相较于 CMS，G1 还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1 无论是为了垃圾收集产生的内存占用还是程序运行时的额外执行负载都要比 CMS 要高&lt;/li&gt;
&lt;li&gt;从经验上来说，在小内存应用上 CMS 的表现大概率会优于 G1，而 G1 在大内存应用上则发挥其优势，平衡点在 6-8GB 之间&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;应用场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;面向服务端应用，针对具有大内存、多处理器的机器&lt;/li&gt;
&lt;li&gt;需要低 GC 延迟，并具有大堆的应用程序提供解决方案&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;记忆集&#34;&gt;记忆集&lt;/h5&gt;
&lt;p&gt;&lt;em&gt;对象不是孤立的，对象之间会存在跨代引用。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/%E8%B7%A8%E4%BB%A3%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98.png&#34;
	width=&#34;553&#34;
	height=&#34;515&#34;
	srcset=&#34;https://isheihei.github.io/posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/%E8%B7%A8%E4%BB%A3%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98_hu52035108ac6161466b665188b0e3f286_16386_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/%E8%B7%A8%E4%BB%A3%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98_hu52035108ac6161466b665188b0e3f286_16386_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;跨代引用问题&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;107&#34;
		data-flex-basis=&#34;257px&#34;
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;假如只局限于新生代的收集，那么我们将错误的回收E；若想正确回收，那就需要对老年区同样做一次GC搜索，明显效率低下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;假如要现在进行一次只局限于新生代区域内的收集（Minor GC），但新生代中的对象是完全有可能被老年代所引用的，为了找出该区域中的存活对象，不得不在固定的GC Roots之外，再额外遍历整个老年代中所有对象来确保可达性分析结果的正确性，反过来也是一样 。遍历整个老年代所有对象 的方案虽然理论上可行，但无疑会为内存回收带来很大的性能负担。&lt;/p&gt;
&lt;p&gt;记忆集 Remembered Set 在新生代中，每个 Region 都有一个 Remembered Set，用来被哪些其他 Region 里的对象引用（谁引用了我就记录谁）&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/JUC-G1%E8%AE%B0%E5%BF%86%E9%9B%86.png&#34;
	width=&#34;906&#34;
	height=&#34;412&#34;
	srcset=&#34;https://isheihei.github.io/posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/JUC-G1%E8%AE%B0%E5%BF%86%E9%9B%86_hu055b6e68b0ca02d5e7ac9c5083acebb0_81130_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/JUC-G1%E8%AE%B0%E5%BF%86%E9%9B%86_hu055b6e68b0ca02d5e7ac9c5083acebb0_81130_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;JUC-G1记忆集&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;219&#34;
		data-flex-basis=&#34;527px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;程序对 Reference 类型数据写操作时，产生一个 Write Barrier 暂时中断操作，检查该对象和 Reference 类型数据是否在不同的 Region（跨代引用），不同就将相关引用信息记录到 Reference 类型所属的 Region 的 Remembered Set 之中&lt;/li&gt;
&lt;li&gt;进行内存回收时，在 GC 根节点的枚举范围中加入 Remembered Set 即可保证不对全堆扫描也不会有遗漏&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;垃圾收集器在新生代中建立了记忆集这样的数据结构，可以理解为它是一个抽象类，具体实现记忆集的三种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;字长精度&lt;/li&gt;
&lt;li&gt;对象精度&lt;/li&gt;
&lt;li&gt;卡精度(卡表)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;卡表（Card Table）在老年代中，是一种对记忆集的具体实现，主要定义了记忆集的记录精度、与堆内存的映射关系等，卡表中的每一个元素都对应着一块特定大小的内存块，这个内存块称之为卡页（card page），当存在跨代引用时，会将卡页标记为 dirty，JVM 对于卡页的维护也是通过写屏障的方式&lt;/p&gt;
&lt;p&gt;收集集合 CSet 代表每次 GC 暂停时回收的一系列目标分区，在任意一次收集暂停中，CSet 所有分区都会被释放，内部存活的对象都会被转移到分配的空闲分区中。年轻代收集 CSet 只容纳年轻代分区，而混合收集会通过启发式算法，在老年代候选回收分区中，筛选出回收收益最高的分区添加到 CSet 中&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CSet of Young Collection&lt;/li&gt;
&lt;li&gt;CSet of Mix Collection&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;工作原理-1&#34;&gt;工作原理&lt;/h5&gt;
&lt;p&gt;G1 中提供了三种垃圾回收模式：YoungGC、Mixed GC 和 Full GC，在不同的条件下被触发&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当堆内存使用达到一定值（默认 45%）时，开始老年代并发标记过程&lt;/li&gt;
&lt;li&gt;标记完成马上开始混合回收过程&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/JVM-G1%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B.png&#34;
	width=&#34;1129&#34;
	height=&#34;402&#34;
	srcset=&#34;https://isheihei.github.io/posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/JVM-G1%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B_huecccb4369629cd64422785cf13d275a0_99587_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/JVM-G1%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B_huecccb4369629cd64422785cf13d275a0_99587_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;JVM-G1回收过程&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;280&#34;
		data-flex-basis=&#34;674px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;顺时针：Young GC → Young GC + Concurrent Mark → Mixed GC 顺序，进行垃圾回收&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Young GC&lt;/strong&gt;：发生在年轻代的 GC 算法，一般对象（除了巨型对象）都是在 eden region 中分配内存，当所有 eden region 被耗尽无法申请内存时，就会触发一次 Young GC，G1 停止应用程序的执行 STW，把活跃对象放入老年代，垃圾对象回收&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;回收过程&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;扫描根：根引用连同 RSet 记录的外部引用作为扫描存活对象的入口&lt;/li&gt;
&lt;li&gt;更新 RSet：处理 dirty card queue 更新 RS，此后 RSet 准确的反映对象的引用关系
&lt;ul&gt;
&lt;li&gt;dirty card queue：类似缓存，产生了引用先记录在这里，然后更新到 RSet&lt;/li&gt;
&lt;li&gt;作用：产生引用直接更新 RSet 需要线程同步开销很大，使用队列性能好&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;处理 RSet：识别被老年代对象指向的 Eden 中的对象，这些被指向的对象被认为是存活的对象，把需要回收的分区放入 Young CSet 中进行回收&lt;/li&gt;
&lt;li&gt;复制对象：Eden 区内存段中存活的对象会被复制到 survivor 区，survivor 区内存段中存活的对象如果年龄未达阈值，年龄会加1，达到阀值会被会被复制到 old 区中空的内存分段，如果 survivor 空间不够，Eden 空间的部分数据会直接晋升到老年代空间&lt;/li&gt;
&lt;li&gt;处理引用：处理 Soft，Weak，Phantom，JNI Weak  等引用，最终 Eden 空间的数据为空，GC 停止工作&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Concurrent Mark&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初始标记：标记从根节点直接可达的对象，这个阶段是 STW 的，并且会触发一次年轻代 GC&lt;/li&gt;
&lt;li&gt;并发标记 (Concurrent Marking)：在整个堆中进行并发标记（应用程序并发执行），可能被 YoungGC 中断。会计算每个区域的对象活性，即区域中存活对象的比例，若区域中的所有对象都是垃圾，则这个区域会被立即回收（&lt;strong&gt;实时回收&lt;/strong&gt;），给浮动垃圾准备出更多的空间，把需要收集的 Region 放入 CSet 当中&lt;/li&gt;
&lt;li&gt;最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中，这阶段需要停顿线程，但是可并行执行（&lt;strong&gt;防止漏标&lt;/strong&gt;）&lt;/li&gt;
&lt;li&gt;筛选回收：并发清理阶段，首先对 CSet 中各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划，也需要 STW&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/JVM-G1%E6%94%B6%E9%9B%86%E5%99%A8.jpg&#34;
	width=&#34;763&#34;
	height=&#34;249&#34;
	srcset=&#34;https://isheihei.github.io/posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/JVM-G1%E6%94%B6%E9%9B%86%E5%99%A8_hub533c5874b46ffc58619fcd23bdf83e7_37888_480x0_resize_q75_box.jpg 480w, https://isheihei.github.io/posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/JVM-G1%E6%94%B6%E9%9B%86%E5%99%A8_hub533c5874b46ffc58619fcd23bdf83e7_37888_1024x0_resize_q75_box.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;JVM-G1收集器&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;306&#34;
		data-flex-basis=&#34;735px&#34;
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Mixed GC&lt;/strong&gt;：当很多对象晋升到老年代时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即 Mixed GC，除了回收整个 young region，还会回收一部分的 old region，过程同 YGC&lt;/p&gt;
&lt;p&gt;注意：&lt;strong&gt;是一部分老年代，而不是全部老年代&lt;/strong&gt;，可以选择哪些老年代 region 收集，对垃圾回收的时间进行控制&lt;/p&gt;
&lt;p&gt;在 G1 中，Mixed GC 可以通过 &lt;code&gt;-XX:InitiatingHeapOccupancyPercent&lt;/code&gt; 设置阈值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Full GC&lt;/strong&gt;：对象内存分配速度过快，Mixed GC 来不及回收，导致老年代被填满，就会触发一次 Full GC，G1 的 Full GC 算法就是单线程执行的垃圾回收，会导致异常长时间的暂停时间，需要进行不断的调优，尽可能的避免 Full GC&lt;/p&gt;
&lt;p&gt;产生 Full GC 的原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;晋升时没有足够的空间存放晋升的对象&lt;/li&gt;
&lt;li&gt;并发处理过程完成之前空间耗尽，浮动垃圾&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;相关参数&#34;&gt;相关参数&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-XX:+UseG1GC&lt;/code&gt;：手动指定使用 G1 垃圾收集器执行内存回收任务&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-XX:G1HeapRegionSize&lt;/code&gt;：设置每个 Region 的大小。值是 2 的幂，范围是 1MB 到 32MB 之间，目标是根据最小的 Java 堆大小划分出约 2048 个区域，默认是堆内存的 1/2000&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-XX:MaxGCPauseMillis&lt;/code&gt;：设置期望达到的最大 GC 停顿时间指标，JVM会尽力实现，但不保证达到，默认值是 200ms&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-XX:+ParallelGcThread&lt;/code&gt;：设置 STW 时 GC 线程数的值，最多设置为 8&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-XX:ConcGCThreads&lt;/code&gt;：设置并发标记线程数，设置为并行垃圾回收线程数 ParallelGcThreads 的1/4左右&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-XX:InitiatingHeapoccupancyPercent&lt;/code&gt;：设置触发并发 Mixed GC 周期的 Java 堆占用率阈值，超过此值，就触发 GC，默认值是 45&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-XX:+ClassUnloadingWithConcurrentMark&lt;/code&gt;：并发标记类卸载，默认启用，所有对象都经过并发标记后，就可以知道哪些类不再被使用，当一个类加载器的所有类都不再使用，则卸载它所加载的所有类&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-XX:G1NewSizePercent&lt;/code&gt;：新生代占用整个堆内存的最小百分比（默认5％）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-XX:G1MaxNewSizePercent&lt;/code&gt;：新生代占用整个堆内存的最大百分比（默认60％）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-XX:G1ReservePercent=10&lt;/code&gt;：保留内存区域，防止 to space（Survivor中的 to 区）溢出&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备一下特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;并行与并发&lt;/strong&gt;：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分代收集&lt;/strong&gt;：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;空间整合&lt;/strong&gt;：与 CMS 的“标记-清理”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可预测的停顿&lt;/strong&gt;：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;G1 收集器的运作大致分为以下几个步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;初始标记(Initial Marking)&lt;/strong&gt;：这阶段&lt;strong&gt;仅仅只是标记GC Roots能直接关联到的对象并修改TAMS(Next Top at Mark Start)的值&lt;/strong&gt;，让下一阶段用户程序并发运行时，能在正确的可用的Region中创建新对象，这阶段&lt;strong&gt;需要停顿线程，但是耗时很短&lt;/strong&gt;。而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际并没有额外的停顿。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;并发标记(Concurrent Marking)&lt;/strong&gt;：&lt;strong&gt;从GC Roots开始对堆的对象进行可达性分析，递归扫描整个堆里的对象图，找出存活的对象&lt;/strong&gt;，这阶段耗时较长，但是可以与用户程序并发执行。当对象图扫描完成以后，还要&lt;strong&gt;重新处理SATB记录下的在并发时有引用变动的对象。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;最终标记(Final Marking)&lt;/strong&gt;：对用户线程做另一个短暂的暂停，&lt;strong&gt;用于处理并发阶段结束后仍遗留下来的最后那少量的 SATB 记录。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;筛选回收(Live Data Counting and Evacuation)&lt;/strong&gt;：&lt;strong&gt;负责更新 Region 的统计数据，对各个 Region 的回收价值和成本进行排序&lt;/strong&gt;，根据用户所期望的停顿时间来制定回收计划。&lt;strong&gt;可以自由选择多个Region来构成回收集，然后把回收的那一部分Region中的存活对象==复制==到空的Region中，在对那些Region进行清空。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;除了并发标记外，其余过程都要 STW&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)&lt;/strong&gt; 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;不管是G1还是其他分代收集器，JVM都是使用 记忆集(Remembered Set) 来避免全局扫描。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;每个Region都有一个对应的记忆集。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;每次Reference类型数据写操作时，都会产生一个 写屏障（Write Barrier）暂时去终止操作&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;然后检查将要写入的引用 指向的对象是否和该Reference类型数据在不同的 Region（其他收集器：检查老年代对象是否引用了新生代对象）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;如果不同，通过 卡表（Card Table）把相关引用信息记录到引用指向对象的所在Region对应的记忆集(Remembered Set) 中&lt;/strong&gt;，被引用对象记录引用自己的对象，这样被引用对象要可达性分析时候，可以找记忆集中的对象&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;当进行垃圾收集时，在GC Roots枚举范围加上记忆集；就可以保证不进行全局扫描了。&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;《深入理解 Java 虚拟机：JVM 高级特性与最佳实践（第二版》&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://docs.oracle.com/javase/specs/jvms/se8/html/index.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://docs.oracle.com/javase/specs/jvms/se8/html/index.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;参考文章：https://www.jianshu.com/p/12544c0ad5c1&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>线程安全与锁优化</title>
        <link>https://isheihei.github.io/posts/java/jvm-%E9%94%81%E4%BC%98%E5%8C%96/</link>
        <pubDate>Tue, 24 May 2022 14:11:07 +0800</pubDate>
        
        <guid>https://isheihei.github.io/posts/java/jvm-%E9%94%81%E4%BC%98%E5%8C%96/</guid>
        <description>&lt;p&gt;主要参考：《深入理解Java虚拟机》-周志明&lt;/p&gt;
&lt;h2 id=&#34;线程安全&#34;&gt;线程安全&lt;/h2&gt;
&lt;h3 id=&#34;java语言中的线程安全&#34;&gt;Java语言中的线程安全&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;不可变&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Java语言中，如果多线程共享的数据是一个基本数据类型，那么只要在定义时使用final关键字修饰它就可以保证它是不可变的&lt;/p&gt;
&lt;p&gt;只要一个不可变的对象被正确地构建出来（即没有发生this引用逃逸的情况），那其外部的可见状态永远都不会改变，永远都不会看到它在多个线程之中处于不一致的状态。“不可变”带来的安全性是最直接、最纯粹的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;绝对线程安全&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个定义其实是很严格的，一个类要达到“不管运行时环境如何，调用者都不需要任何额外的同步措施”可能需要付出非常高昂的，甚至不切实际的代价。&lt;/p&gt;
&lt;p&gt;在Java API中标注自己是线程安全的类，大多数都不是绝对的线程安全。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;相对线程安全&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;相对线程安全就是我们通常意义上所讲的线程安全，它需要保证对这个对象单次的操作是线程安全的，我们在调用的时候不需要进行额外的保障措施，但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;线程兼容&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;线程对立&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;线程对立是指不管调用端是否采取了同步措施，都无法在多线程环境中并发使用代码。&lt;/p&gt;
&lt;p&gt;一个线程对立的例子是Thread类的suspend()和resume()方法。如果有两个线程同时持有一个线程对象，一个尝试去中断线程，一个尝试去恢复线程，在并发进行的情况下，无论调用时是否进行了同步，目标线程都存在死锁风险——假如suspend()中断的线程就是即将要执行resume()的那个线程，那就肯定要产生死锁了。&lt;/p&gt;
&lt;h3 id=&#34;线程安全的实现方法&#34;&gt;线程安全的实现方法&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;互斥同步&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在Java里面，最基本的互斥同步手段就是synchronized关键字，这是一种块结构（Block Structured）的同步语法。synchronized关键字经过Javac编译之后，会在同步块的前后分别形成monitorenter和monitorexit这两个字节码指令。&lt;/p&gt;
&lt;p&gt;这两个字节码指令都需要一个reference类型的参数来指明要锁定和解锁的对象。如果Java源码中的synchronized明确指定了对象参数，那就以这个对象的引用作为reference；如果没有明确指定，那将根据synchronized修饰的方法类型（如实例方法或类方法），来决定是取代码所在的对象实例还是取类型对应的Class对象来作为线程要持有的锁&lt;/p&gt;
&lt;p&gt;从功能上看，根据以上《Java虚拟机规范》对monitorenter和monitorexit的行为描述，我们可以得出两个关于synchronized的直接推论，这是使用它时需特别注意的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;被synchronized修饰的同步块对同一条线程来说是可重入的。这意味着同一线程反复进入同步块也不会出现自己把自己锁死的情况。&lt;/li&gt;
&lt;li&gt;被synchronized修饰的同步块在持有锁的线程执行完毕并释放锁之前，会无条件地阻塞后面其他线程的进入。这意味着无法像处理某些数据库中的锁那样，强制已获取锁的线程释放锁；也无法强制正在等待锁的线程中断等待或超时退出。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从执行成本的角度看，持有锁是一个重量级（Heavy-Weight）的操作。在主流Java虚拟机实现中，Java的线程是映射到操作系统的原生内核线程之上的，如果要阻塞或唤醒一条线程，则需要操作系统来帮忙完成，这就不可避免地陷入用户态到核心态的转换中，进行这种状态转换需要耗费很多的处理器时间。尤其是对于代码特别简单的同步块（譬如被synchronized修饰的getter()或setter()方法），状态转换消耗的时间甚至会比用户代码本身执行的时间还要长。因此才说，synchronized是Java语言中一个重量级的操作，有经验的程序员都只会在确实必要的情况下才使用这种操作。&lt;/p&gt;
&lt;p&gt;**重入锁（ReentrantLock）**是Lock接口最常见的一种实现，顾名思义，它与synchronized一样是可重入的。在基本用法上，ReentrantLock也与synchronized很相似，只是代码写法上稍有区别而已。不过，ReentrantLock与synchronized相比增加了一些高级功能，主要有以下三项：等待可中断、可实现公平锁及锁可以绑定多个条件。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;等待可中断：是指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。可中断特性对处理执行时间非常长的同步块很有帮助。&lt;/li&gt;
&lt;li&gt;公平锁：是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁；而非公平
锁则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。synchronized中的锁是非公平的，ReentrantLock在默认情况下也是非公平的，但可以通过带布尔值的构造函数要求使用公平锁。不过一旦使用了公平锁，将会导致ReentrantLock的性能急剧下降，会明显影响吞吐量。&lt;/li&gt;
&lt;li&gt;锁绑定多个条件：是指一个ReentrantLock对象可以同时绑定多个Condition对象。在synchronized中，锁对象的wait()跟它的notify()或者notifyAll()方法配合可以实现一个隐含的条件，如果要和多于一个的条件关联的时候，就不得不额外添加一个锁；而ReentrantLock则无须这样做，多次调用newCondition()方法即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ReentrantLock在功能上是synchronized的超集，在性能上又至少不会弱于synchronized，那synchronized修饰符是否应该被直接抛弃，不再使用了呢？当然不是，基于以下理由，笔者仍然推荐在synchronized与ReentrantLock都可满足需要时优先使用synchronized：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;synchronized是在Java语法层面的同步，足够清晰，也足够简单。每个Java程序员都熟悉synchronized，但J.U.C中的Lock接口则并非如此。因此在只需要基础的同步功能时，更推荐synchronized。&lt;/li&gt;
&lt;li&gt;Lock应该确保在finally块中释放锁，否则一旦受同步保护的代码块中抛出异常，则有可能永远不会释放持有的锁。这一点必须由程序员自己来保证，而使用synchronized的话则可以由Java虚拟机来确保即使出现异常，锁也能被自动释放。&lt;/li&gt;
&lt;li&gt;尽管在JDK 5时代ReentrantLock曾经在性能上领先过synchronized，但这已经是十多年之前的胜利了。从长远来看，Java虚拟机更容易针对synchronized来进行优化，因为Java虚拟机可以在线程和对象的元数据中记录synchronized中锁的相关信息，而使用J.U.C中的Lock的话，Java虚拟机是很难得知具体哪些锁对象是由特定线程锁持有的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;非阻塞同步&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;随着硬件指令集的发展，我们已经有了另外一个选择：基于冲突检测的乐观并发策略，通俗地说就是不管风险，先进行操作，如果没有其他线程争用共享数据，那操作就直接成功了；如果共享的数据的确被争用，产生了冲突，那再进行其他的补偿措施，最常用的补偿措施是不断地重试，直到出现没有竞争的共享数据为止。这种乐观并发策略的实现不再需要把线程阻塞挂起，因此这种同步操作被称为非阻塞同步（Non-Blocking Synchronization），使用这种措施的代码也常被称为无锁（Lock-Free）编程。&lt;/p&gt;
&lt;p&gt;硬件保证某些从语义上看起来需要多次操作的行为可以只通过一条处理器指令就能完成，这类指令常用的有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;测试并设置（Test-and-Set）；&lt;/li&gt;
&lt;li&gt;获取并增加（Fetch-and-Increment）；&lt;/li&gt;
&lt;li&gt;交换（Swap）；&lt;/li&gt;
&lt;li&gt;比较并交换（Compare-and-Swap，下文称CAS）；&lt;/li&gt;
&lt;li&gt;加载链接/条件储存（Load-Linked/Store-Conditional，下文称LL/SC）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CAS指令需要有三个操作数，分别是内存位置（在Java中可以简单地理解为变量的内存地址，用V表示）、旧的预期值（用A表示）和准备设置的新值（用B表示）。CAS指令执行时，当且仅当V符合A时，处理器才会用B更新V的值，否则它就不执行更新。但是，不管是否更新了V的值，都会返回V的旧值，上述的处理过程是一个原子操作，执行期间不会被其他线程中断。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;无同步方案&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;要保证线程安全，也并非一定要进行阻塞或非阻塞同步，同步与线程安全两者没有必然的联系。同步只是保障存在共享数据争用时正确性的手段，如果能让一个方法本来就不涉及共享数据，那它自然就不需要任何同步措施去保证其正确性，因此会有一些代码天生就是线程安全的，简单介绍其中的两类。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可重入代码（Reentrant Code）&lt;/strong&gt;：这种代码又称纯代码（Pure Code），是指可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误，也不会对结果有所影响。在特指多线程的上下文语境里（不涉及信号量等因素），我们可以认为可重入代码是线程安全代码的一个真子集，这意味着相对线程安全来说，可重入性是更为基础的特性，它可以保证代码线程安全，即所有可重入的代码都是线程安全的，但并非所有的线程安全的代码都是可重入的。&lt;/p&gt;
&lt;p&gt;可重入代码有一些共同的特征，例如，不依赖全局变量、存储在堆上的数据和公用的系统资源，用到的状态量都由参数中传入，不调用非可重入的方法等。我们可以通过一个比较简单的原则来判断代码是否具备可重入性：如果一个方法的返回结果是可以预测的，只要输入了相同的数据，就都能返回相同的结果，那它就满足可重入性的要求，当然也就是线程安全的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;线程本地存储&lt;/strong&gt;（Thread Local Storage）：如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。&lt;/p&gt;
&lt;h2 id=&#34;锁优化&#34;&gt;锁优化&lt;/h2&gt;
&lt;p&gt;Java虚拟机中，synchronized支持的同步方法和同步语句都是使用monitor来实现的。每个对象都与一个monitor相关联，当一个线程执行到一个monitor监视下的代码块中的第一个指令时，该线程必须在引用的对象上获得一个锁，这个锁是monitor实现的。在HotSpot虚拟机中，monitor是由ObjectMonitor实现，使用C++编写实现，具体代码在HotSpot虚拟机源码ObjectMonitor.hpp文件中。&lt;/p&gt;
&lt;p&gt;查看源码会发现，主要的属性有_count(记录该线程获取锁的次数)、_recursions(锁的重入次数)、_owner(指向持有ObjectMonitor对象的线程)、_WaitSet(处于wait状态的线程集合)、_EntryList(处于等待锁block状态的线程队列)。&lt;/p&gt;
&lt;p&gt;当并发线程执行synchronized修饰的方法或语句块时，先进入_EntryList中，当某个线程获取到对象的monitor后，把monitor对象中的_owner变量设置为当前线程，同时monitor对象中的计数器_count加1，当前线程获取同步锁成功。&lt;/p&gt;
&lt;p&gt;当synchronized修饰的方法或语句块中的线程调用wait()方法时，当前线程将释放持有的monitor对象，monitor对象中的_owner变量赋值为null，同时，monitor对象中的_count值减1，然后当前线程进入_WaitSet集合中等待被唤醒。&lt;/p&gt;
&lt;h3 id=&#34;自旋锁与自适应自旋&#34;&gt;自旋锁与自适应自旋&lt;/h3&gt;
&lt;p&gt;如果物理机器有一个以上的处理器或者处理器核心，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的那个线程“稍等一会”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只须让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁。&lt;/p&gt;
&lt;p&gt;在JDK 6中对自旋锁的优化，引入了自适应的自旋。自适应意味着自旋的时间不再是固定的了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定的。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而允许自旋等待持续相对更长的时间&lt;/p&gt;
&lt;p&gt;如果对于某个锁，自旋很少成功获得过锁，那在以后要获取这个锁时将有可能直接省略掉自旋过程，以避免浪费处理器资源。&lt;/p&gt;
&lt;h3 id=&#34;锁消除&#34;&gt;锁消除&lt;/h3&gt;
&lt;p&gt;锁消除是指虚拟机即时编译器在运行时，对一些代码要求同步，但是对被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持（第11章已经讲解过逃逸分析技术），如果判断到一段代码中，在堆上的所有数据都不会逃逸出去被其他线程访问到，那就可以把它们当作栈上数据对待，认为它们是线程私有的，同步加锁自然就无须再进行。&lt;/p&gt;
&lt;h3 id=&#34;锁粗化&#34;&gt;锁粗化&lt;/h3&gt;
&lt;p&gt;原则上，我们在编写代码的时候，总是推荐将同步块的作用范围限制得尽量小——只在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变少，即使存在锁竞争，等待锁的线程也能尽可能快地拿到锁。&lt;/p&gt;
&lt;p&gt;大多数情况下，上面的原则都是正确的，但是如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体之中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。&lt;/p&gt;
&lt;p&gt;如果虚拟机探测到有这样一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部&lt;/p&gt;
&lt;h3 id=&#34;轻量级锁&#34;&gt;轻量级锁&lt;/h3&gt;
&lt;p&gt;轻量级锁并不是用来代替重量级锁的，它设计的初衷是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/java/jvm-%E9%94%81%E4%BC%98%E5%8C%96/Untitled.png&#34;
	width=&#34;1169&#34;
	height=&#34;395&#34;
	srcset=&#34;https://isheihei.github.io/posts/java/jvm-%E9%94%81%E4%BC%98%E5%8C%96/Untitled_hu7e11831428aef6f9b6ac505529fed6fc_114020_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/java/jvm-%E9%94%81%E4%BC%98%E5%8C%96/Untitled_hu7e11831428aef6f9b6ac505529fed6fc_114020_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;32位HotSpot虚拟机对象头Mark Word&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;295&#34;
		data-flex-basis=&#34;710px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;32位HotSpot虚拟机对象头Mark Word&lt;/p&gt;
&lt;p&gt;接下来介绍轻量级锁的工作过程：在代码即将进入同步块的时候，如果此同步对象没有被锁定（锁标志位为“01”状态），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝（官方为这份拷贝加了一个Displaced前缀，即Displaced Mark Word），这时候线程堆栈与对象头的状态如图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/java/jvm-%E9%94%81%E4%BC%98%E5%8C%96/Untitled1.png&#34;
	width=&#34;668&#34;
	height=&#34;310&#34;
	srcset=&#34;https://isheihei.github.io/posts/java/jvm-%E9%94%81%E4%BC%98%E5%8C%96/Untitled1_huffad5e73d0e6e077613752f5f7dc355b_49676_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/java/jvm-%E9%94%81%E4%BC%98%E5%8C%96/Untitled1_huffad5e73d0e6e077613752f5f7dc355b_49676_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;轻量级锁CAS操作之前堆栈与对象的状态&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;215&#34;
		data-flex-basis=&#34;517px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;然后，虚拟机将使用CAS操作尝试把对象的Mark Word更新为指向Lock Record的指针。如果这个更新动作成功了，即代表该线程拥有了这个对象的锁，并且对象Mark Word的锁标志位（Mark Word的最后两个比特）将转变为“00”，表示此对象处于轻量级锁定状态。这时候线程堆栈与对象头的状态如图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/java/jvm-%E9%94%81%E4%BC%98%E5%8C%96/Untitled2.png&#34;
	width=&#34;460&#34;
	height=&#34;309&#34;
	srcset=&#34;https://isheihei.github.io/posts/java/jvm-%E9%94%81%E4%BC%98%E5%8C%96/Untitled2_hu6534f21b5d87ddca44d307db7517c0ca_39489_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/java/jvm-%E9%94%81%E4%BC%98%E5%8C%96/Untitled2_hu6534f21b5d87ddca44d307db7517c0ca_39489_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;轻量级锁CAS操作之后堆栈与对象的状态&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;148&#34;
		data-flex-basis=&#34;357px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;如果这个更新操作失败了，那就意味着至少存在一条线程与当前线程竞争获取该对象的锁。虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是，说明当前线程已经拥有了这个对象的锁，那直接进入同步块继续执行就可以了，否则就说明这个锁对象已经被其他线程抢占了。如果出现两条以上的线程争用同一个锁的情况，那轻量级锁就不再有效，必须要膨胀为重量级锁，锁标志的状态值变为“10”，此时Mark Word中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也必须进入阻塞状态。&lt;/p&gt;
&lt;p&gt;上面描述的是轻量级锁的加锁过程，它的解锁过程也同样是通过CAS操作来进行的，如果对象的Mark Word仍然指向线程的锁记录，那就用CAS操作把对象当前的Mark Word和线程中复制DisplacedMark Word替换回来。假如能够成功替换，那整个同步过程就顺利完成了；如果替换失败，则说明有其他线程尝试过获取该锁，就要在释放锁的同时，唤醒被挂起的线程。&lt;/p&gt;
&lt;p&gt;轻量级锁能提升程序同步性能的依据是“对于绝大部分的锁，在整个同步周期内都是不存在竞争的”这一经验法则。如果没有竞争，轻量级锁便通过CAS操作成功避免了使用互斥量的开销；但如果确实存在锁竞争，除了互斥量的本身开销外，还额外发生了CAS操作的开销。因此在有竞争的情况下，轻量级锁反而会比传统的重量级锁更慢。&lt;/p&gt;
&lt;h3 id=&#34;偏向锁&#34;&gt;偏向锁&lt;/h3&gt;
&lt;p&gt;偏向锁的思想是偏向于让第一个获取锁对象的线程，这个线程在之后获取该锁就不再需要进行同步操作，甚至连 CAS 操作也不再需要。&lt;/p&gt;
&lt;p&gt;当锁对象第一次被线程获得的时候，进入偏向状态，标记为 |1|01|（前面内存布局图中说明了，这属于偏向锁状态）。同时使用 CAS 操作将线程 ID （ThreadID）记录到 Mark Word 中，如果 CAS 操作成功，这个线程以后每次进入这个锁相关的同步块就不需要再进行任何同步操作。&lt;/p&gt;
&lt;p&gt;当有另外一个线程去尝试获取这个锁对象时，偏向状态就宣告结束，此时撤销偏向（Revoke Bias）后恢复到未锁定状态或者轻量级锁状态。&lt;/p&gt;
&lt;p&gt;偏向锁是为了在资源没有被多线程竞争的情况下尽量减少锁带来的性能开销。&lt;/p&gt;
&lt;p&gt;在锁对象的对象头中有一个ThreadId字段，当第一个线程访问锁时，如果该锁没有被其他线程访问过，即&lt;strong&gt;ThreadId字段为空&lt;/strong&gt;，那么JVM让其持有偏向锁，并将ThreadId字段的值设置为该线程的ID。当下一次获取锁的时候，会判断ThreadId是否相等，如果一致就不会重复获取锁，从而提高了运行率&lt;/p&gt;
&lt;p&gt;如果存在锁的竞争情况，偏向锁就会被撤销并升级为轻量级锁。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;synchronized的执行过程：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;检测Mark Word里面是不是当前线程的ID，如果是，表示当前线程处于偏向锁&lt;/li&gt;
&lt;li&gt;如果不是，则使用CAS将当前线程的ID替换Mark Word，如果成功则表示当前线程获得偏向锁，置偏向标志位1&lt;/li&gt;
&lt;li&gt;如果失败，则说明发生竞争，撤销偏向锁，进而升级为轻量级锁。&lt;/li&gt;
&lt;li&gt;当前线程使用CAS将对象头的Mark Word替换为锁记录指针，如果成功，当前线程获得锁&lt;/li&gt;
&lt;li&gt;如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。&lt;/li&gt;
&lt;li&gt;如果自旋成功则依然处于轻量级状态。&lt;/li&gt;
&lt;li&gt;如果自旋失败，则升级为重量级锁。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;偏向锁、轻量级锁、重量级锁的区别&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;偏向锁的优点是加解锁不需要额外消耗，和执行非同步方法比仅存在纳秒级差距，缺点是如果存在锁竞争会带来额外锁撤销的消耗，适用只有一个线程访问同步代码块的场景。&lt;/p&gt;
&lt;p&gt;轻量级锁的优点是竞争线程不阻塞，程序响应速度快，缺点是如果线程始终得不到锁会自旋消耗 CPU，适用追求响应时间、同步代码块执行快的场景。&lt;/p&gt;
&lt;p&gt;重量级锁的优点是线程竞争不使用自旋不消耗CPU，缺点是线程会阻塞，响应时间慢，适应追求吞吐量、同步代码块执行慢的场景。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Jdk环境变量配置</title>
        <link>https://isheihei.github.io/posts/tips/jdk%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE/</link>
        <pubDate>Fri, 29 Jan 2021 23:21:58 +0800</pubDate>
        
        <guid>https://isheihei.github.io/posts/tips/jdk%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE/</guid>
        <description>&lt;h3 id=&#34;新建java_home变量填写jdk安装路径bin目录的上一级&#34;&gt;新建JAVA_HOME变量，填写jdk安装路径：bin目录的上一级&lt;/h3&gt;
&lt;h3 id=&#34;path变量添加两个&#34;&gt;PATH变量添加两个：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;%JAVA_HOME%\bin&lt;/li&gt;
&lt;li&gt;%JAVA_HOME%\jre\bin&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;新建classpath变量&#34;&gt;新建CLASSPATH变量：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\tools.jar&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        
    </channel>
</rss>
