<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>操作系统 on isheihei&#39;s blog</title>
        <link>https://isheihei.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</link>
        <description>Recent content in 操作系统 on isheihei&#39;s blog</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <lastBuildDate>Wed, 20 Jul 2022 23:06:44 +0800</lastBuildDate><atom:link href="https://isheihei.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Linux常见命令</title>
        <link>https://isheihei.github.io/posts/tips/linux%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/</link>
        <pubDate>Wed, 20 Jul 2022 23:06:44 +0800</pubDate>
        
        <guid>https://isheihei.github.io/posts/tips/linux%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/</guid>
        <description></description>
        </item>
        <item>
        <title>操作系统04-文件管理</title>
        <link>https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F04-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/</link>
        <pubDate>Wed, 20 Jul 2022 20:41:40 +0800</pubDate>
        
        <guid>https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F04-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/</guid>
        <description>&lt;h2 id=&#34;文件系统的基本组成&#34;&gt;文件系统的基本组成&lt;/h2&gt;
&lt;p&gt;Linux 最经典的一句话是：「&lt;strong&gt;一切皆文件&lt;/strong&gt;」，不仅普通的文件和目录，就连块设备、管道、socket 等，也都是统一交给文件系统管理的。&lt;/p&gt;
&lt;p&gt;Linux 文件系统会为每个文件分配两个数据结构：&lt;strong&gt;索引节点（index node）和目录项（directory entry）&lt;/strong&gt;，它们主要用来记录文件的元信息和目录层次结构。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;索引节点，也就是 &lt;em&gt;inode&lt;/em&gt;，用来记录文件的元信息，比如 inode 编号、文件大小、访问权限、创建时间、修改时间、&lt;strong&gt;数据在磁盘的位置&lt;/strong&gt;等等。索引节点是文件的&lt;strong&gt;唯一&lt;/strong&gt;标识，它们之间一一对应，也同样都会被存储在硬盘中，所以&lt;strong&gt;索引节点同样占用磁盘空间&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;目录项，也就是 &lt;em&gt;dentry&lt;/em&gt;，用来记录文件的名字、&lt;strong&gt;索引节点指针&lt;/strong&gt;以及与其他目录项的层级关联关系。多个目录项关联起来，就会形成目录结构，但它与索引节点不同的是，&lt;strong&gt;目录项是由内核维护的一个数据结构，不存放于磁盘，而是缓存在内存&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于索引节点唯一标识一个文件，而目录项记录着文件的名，所以目录项和索引节点的关系是多对一，也就是说，一个文件可以有多个别字。比如，硬链接的实现就是多个目录项中的索引节点指向同一个文件。&lt;/p&gt;
&lt;p&gt;注意，目录也是文件，也是用索引节点唯一标识，和普通文件不同的是，普通文件在磁盘里面保存的是文件数据，而目录文件在磁盘里面保存子目录或文件。&lt;/p&gt;
&lt;h3 id=&#34;文件数据是如何存储在磁盘的呢&#34;&gt;文件数据是如何存储在磁盘的呢？&lt;/h3&gt;
&lt;p&gt;磁盘读写的最小单位是&lt;strong&gt;扇区&lt;/strong&gt;，扇区的大小只有 &lt;code&gt;512B&lt;/code&gt; 大小，很明显，如果每次读写都以这么小为单位，那这读写的效率会非常低。&lt;/p&gt;
&lt;p&gt;所以，文件系统把多个扇区组成了一个&lt;strong&gt;逻辑块&lt;/strong&gt;，每次读写的最小单位就是逻辑块（数据块），Linux 中的逻辑块大小为 &lt;code&gt;4KB&lt;/code&gt;，也就是一次性读写 8 个扇区，这将大大提高了磁盘的读写的效率。&lt;/p&gt;
&lt;p&gt;以上就是索引节点、目录项以及文件数据的关系，下面这个图就很好的展示了它们之间的关系：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F04-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/image-20220720220904704.png&#34;
	width=&#34;1172&#34;
	height=&#34;842&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F04-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/image-20220720220904704_hu3cd366e0dcf74c0e534ffb410c2a9a9e_87193_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F04-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/image-20220720220904704_hu3cd366e0dcf74c0e534ffb410c2a9a9e_87193_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;文件系统&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;139&#34;
		data-flex-basis=&#34;334px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;索引节点是存储在硬盘上的数据，那么为了加速文件的访问，通常会把索引节点加载到内存中。&lt;/p&gt;
&lt;p&gt;另外，磁盘进行格式化的时候，会被分成三个存储区域，分别是超级块、索引节点区和数据块区。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;超级块&lt;/em&gt;，用来存储文件系统的详细信息，比如块个数、块大小、空闲块等等。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;索引节点区&lt;/em&gt;，用来存储索引节点；&lt;/li&gt;
&lt;li&gt;&lt;em&gt;数据块区&lt;/em&gt;，用来存储文件或目录数据；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们不可能把超级块和索引节点区全部加载到内存，这样内存肯定撑不住，所以只有当需要使用的时候，才将其加载进内存，它们加载进内存的时机是不同的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;超级块：当文件系统挂载时进入内存；&lt;/li&gt;
&lt;li&gt;索引节点区：当文件被访问时进入内存&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;虚拟文件系统&#34;&gt;虚拟文件系统&lt;/h2&gt;
&lt;p&gt;文件系统的种类众多，而操作系统希望&lt;strong&gt;对用户提供一个统一的接口&lt;/strong&gt;，于是在用户层与文件系统层引入了中间层，这个中间层就称为&lt;strong&gt;虚拟文件系统（Virtual File System，VFS）。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;VFS 定义了一组所有文件系统都支持的数据结构和标准接口，这样程序员不需要了解文件系统的工作原理，只需要了解 VFS 提供的统一接口即可。&lt;/p&gt;
&lt;p&gt;在 Linux 文件系统中，用户空间、系统调用、虚拟机文件系统、缓存、文件系统以及存储之间的关系如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F04-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/image-20220720221037422.png&#34;
	width=&#34;962&#34;
	height=&#34;1262&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F04-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/image-20220720221037422_hu411593b8f87bb7e329570bc5870f5b29_103036_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F04-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/image-20220720221037422_hu411593b8f87bb7e329570bc5870f5b29_103036_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;虚拟文件系统&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;76&#34;
		data-flex-basis=&#34;182px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;文件的使用&#34;&gt;文件的使用&lt;/h2&gt;
&lt;p&gt;我们从用户角度来看文件的话，就是我们要怎么使用文件？首先，我们得通过系统调用来打开一个文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F04-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/image-20220720221159824.png&#34;
	width=&#34;1031&#34;
	height=&#34;200&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F04-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/image-20220720221159824_hu00cd86208c69479ee96066c24fb3a012_27261_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F04-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/image-20220720221159824_hu00cd86208c69479ee96066c24fb3a012_27261_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;打开文件&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;515&#34;
		data-flex-basis=&#34;1237px&#34;
	
&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;fd&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; open&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;name, flag&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;# 打开文件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;write&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;fd,...&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;         &lt;span class=&#34;c1&#34;&gt;# 写数据&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;close&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;fd&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;             &lt;span class=&#34;c1&#34;&gt;# 关闭文件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;上面简单的代码是读取一个文件的过程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先用 &lt;code&gt;open&lt;/code&gt; 系统调用打开文件，&lt;code&gt;open&lt;/code&gt; 的参数中包含文件的路径名和文件名。&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;write&lt;/code&gt; 写数据，其中 &lt;code&gt;write&lt;/code&gt; 使用 &lt;code&gt;open&lt;/code&gt; 所返回的&lt;strong&gt;文件描述符&lt;/strong&gt;，并不使用文件名作为参数。&lt;/li&gt;
&lt;li&gt;使用完文件后，要用 &lt;code&gt;close&lt;/code&gt; 系统调用关闭文件，避免资源的泄露。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们打开了一个文件后，操作系统会跟踪进程打开的所有文件，所谓的跟踪呢，就是操作系统为每个进程维护一个打开文件表，文件表里的每一项代表「&lt;strong&gt;文件描述符&lt;/strong&gt;」，所以说文件描述符是打开文件的标识。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F04-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/image-20220720221214017.png&#34;
	width=&#34;407&#34;
	height=&#34;332&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F04-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/image-20220720221214017_hu0abec45de03367375af5d364f657894d_8433_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F04-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/image-20220720221214017_hu0abec45de03367375af5d364f657894d_8433_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;打开文件表&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;122&#34;
		data-flex-basis=&#34;294px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;操作系统在打开文件表中维护着打开文件的状态和信息：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文件指针：系统跟踪上次读写位置作为当前文件位置指针，这种指针对打开文件的某个进程来说是唯一的；&lt;/li&gt;
&lt;li&gt;文件打开计数器：文件关闭时，操作系统必须重用其打开文件表条目，否则表内空间不够用。因为多个进程可能打开同一个文件，所以系统在删除打开文件条目之前，必须等待最后一个进程关闭文件，该计数器跟踪打开和关闭的数量，当该计数为 0 时，系统关闭文件，删除该条目；&lt;/li&gt;
&lt;li&gt;文件磁盘位置：绝大多数文件操作都要求系统修改文件数据，该信息保存在内存中，以免每个操作都从磁盘中读取；&lt;/li&gt;
&lt;li&gt;访问权限：每个进程打开文件都需要有一个访问模式（创建、只读、读写、添加等），该信息保存在进程的打开文件表中，以便操作系统能允许或拒绝之后的 I/O 请求；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;户和操作系统对文件的读写操作是有差异的，用户习惯以字节的方式读写文件，而操作系统则是以数据块来读写文件，那屏蔽掉这种差异的工作就是文件系统了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文件系统的基本操作单位是数据块&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;文件的存储&#34;&gt;文件的存储&lt;/h2&gt;
&lt;h3 id=&#34;连续空间存放方式&#34;&gt;连续空间存放方式&lt;/h3&gt;
&lt;p&gt;连续空间存放方式顾名思义，&lt;strong&gt;文件存放在磁盘「连续的」物理空间中&lt;/strong&gt;。这种模式下，文件的数据都是紧密相连，&lt;strong&gt;读写效率很高&lt;/strong&gt;，因为一次磁盘寻道就可以读出整个文件。&lt;/p&gt;
&lt;p&gt;使用连续存放的方式有一个前提，必须先知道一个文件的大小，这样文件系统才会根据文件的大小在磁盘上找到一块连续的空间分配给文件。&lt;/p&gt;
&lt;p&gt;所以，&lt;strong&gt;文件头里需要指定「起始块的位置」和「长度」&lt;/strong&gt;，有了这两个信息就可以很好的表示文件存放方式是一块连续的磁盘空间。&lt;/p&gt;
&lt;p&gt;注意，此处说的文件头，就类似于 Linux 的 inode。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F04-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/image-20220720221539944.png&#34;
	width=&#34;602&#34;
	height=&#34;377&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F04-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/image-20220720221539944_hu51650a284614f6843ca9e41e592d496b_17458_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F04-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/image-20220720221539944_hu51650a284614f6843ca9e41e592d496b_17458_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;连续空间存放&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;159&#34;
		data-flex-basis=&#34;383px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;连续空间存放的方式虽然读写效率高，&lt;strong&gt;但是有「磁盘空间碎片」和「文件长度不易扩展」的缺陷。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;非连续空间存放方式&#34;&gt;非连续空间存放方式&lt;/h3&gt;
&lt;h4 id=&#34;链表方式&#34;&gt;链表方式&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;隐式链表方式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;链表的方式存放是&lt;strong&gt;离散的，不用连续的&lt;/strong&gt;，于是就可以&lt;strong&gt;消除磁盘碎片&lt;/strong&gt;，可大大提高磁盘空间的利用率，同时&lt;strong&gt;文件的长度可以动态扩展&lt;/strong&gt;。根据实现的方式的不同，链表可分为「&lt;strong&gt;隐式链表&lt;/strong&gt;」和「&lt;strong&gt;显式链接&lt;/strong&gt;」两种形式。&lt;/p&gt;
&lt;p&gt;文件要以「&lt;strong&gt;隐式链表&lt;/strong&gt;」的方式存放的话，&lt;strong&gt;实现的方式是文件头要包含「第一块」和「最后一块」的位置，并且每个数据块里面留出一个指针空间，用来存放下一个数据块的位置&lt;/strong&gt;，这样一个数据块连着一个数据块，从链头开是就可以顺着指针找到所有的数据块，所以存放的方式可以是不连续的。&lt;/p&gt;
&lt;p&gt;隐式链表的存放方式的&lt;strong&gt;缺点在于无法直接访问数据块，只能通过指针顺序访问文件，以及数据块指针消耗了一定的存储空间&lt;/strong&gt;。隐式链接分配的&lt;strong&gt;稳定性较差&lt;/strong&gt;，系统在运行过程中由于软件或者硬件错误&lt;strong&gt;导致链表中的指针丢失或损坏，会导致文件数据的丢失。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F04-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/image-20220720221654858.png&#34;
	width=&#34;1067&#34;
	height=&#34;407&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F04-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/image-20220720221654858_hu35b665d951d4b8fabf3aa1c94d9db199_13383_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F04-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/image-20220720221654858_hu35b665d951d4b8fabf3aa1c94d9db199_13383_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;隐式链表方式&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;262&#34;
		data-flex-basis=&#34;629px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;显式链表方式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;取出每个磁盘块的指针，把它放在内存的一个表中，就可以解决上述隐式链表的两个不足。那么，这种实现方式是「&lt;strong&gt;显式链接&lt;/strong&gt;」，它指&lt;strong&gt;把用于链接文件各数据块的指针，显式地存放在内存的一张链接表中&lt;/strong&gt;，该表在整个磁盘仅设置一张，&lt;strong&gt;每个表项中存放链接指针，指向下一个数据块号&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;内存中的这样一个表格称为&lt;strong&gt;文件分配表（File Allocation Table，FAT）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于查找记录的过程是在内存中进行的，因而不仅显著地&lt;strong&gt;提高了检索速度&lt;/strong&gt;，而且&lt;strong&gt;大大减少了访问磁盘的次数&lt;/strong&gt;。但也正是整个表都存放在内存中的关系，它的主要的缺点是&lt;strong&gt;不适用于大磁盘&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F04-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/image-20220720222031787.png&#34;
	width=&#34;489&#34;
	height=&#34;1007&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F04-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/image-20220720222031787_hu242c934c80ff24a5fa59491c5c85b7ac_30819_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F04-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/image-20220720222031787_hu242c934c80ff24a5fa59491c5c85b7ac_30819_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;显式链表方式&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;48&#34;
		data-flex-basis=&#34;116px&#34;
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;索引方式&#34;&gt;索引方式&lt;/h4&gt;
&lt;p&gt;链表的方式解决了连续分配的磁盘碎片和文件动态扩展的问题，但是不能有效支持直接访问（FAT除外），索引的方式可以解决这个问题。&lt;/p&gt;
&lt;p&gt;索引的实现是为每个文件创建一个「&lt;strong&gt;索引数据块&lt;/strong&gt;」，里面存放的是&lt;strong&gt;指向文件数据块的指针列表&lt;/strong&gt;，说白了就像书的目录一样，要找哪个章节的内容，看目录查就可以。&lt;/p&gt;
&lt;p&gt;另外，&lt;strong&gt;文件头需要包含指向「索引数据块」的指针&lt;/strong&gt;，这样就可以通过文件头知道索引数据块的位置，再通过索引数据块里的索引信息找到对应的数据块。&lt;/p&gt;
&lt;p&gt;创建文件时，索引块的所有指针都设为空。当首次写入第 i 块时，先从空闲空间中取得一个块，再将其地址写到索引块的第 i 个条目。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F04-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/image-20220720222302091.png&#34;
	width=&#34;1067&#34;
	height=&#34;527&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F04-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/image-20220720222302091_hud703d2c88033c5eb38cc293b54670ed1_38769_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F04-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/image-20220720222302091_hud703d2c88033c5eb38cc293b54670ed1_38769_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;索引方式&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;202&#34;
		data-flex-basis=&#34;485px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;索引的方式优点在于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文件的创建、增大、缩小很方便；&lt;/li&gt;
&lt;li&gt;不会有碎片的问题；&lt;/li&gt;
&lt;li&gt;支持顺序读写和随机读写；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于索引数据也是存放在磁盘块的，如果文件很小，明明只需一块就可以存放的下，但还是需要额外分配一块来存放索引数据，所以缺陷之一就是存储索引带来的开销。&lt;/p&gt;
&lt;p&gt;如果文件很大，大到一个索引数据块放不下索引信息，这时又要如何处理大文件的存放呢？我们可以通过组合的方式，来处理大文件的存。&lt;/p&gt;
&lt;p&gt;先来看看链表 + 索引的组合，这种组合称为「&lt;strong&gt;链式索引块&lt;/strong&gt;」，它的实现方式是&lt;strong&gt;在索引数据块留出一个存放下一个索引数据块的指针&lt;/strong&gt;，于是当一个索引数据块的索引信息用完了，就可以通过指针的方式，找到下一个索引数据块的信息。那这种方式也会出现前面提到的链表方式的问题，万一某个指针损坏了，后面的数据也就会无法读取了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F04-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/image-20220720222402714.png&#34;
	width=&#34;1068&#34;
	height=&#34;302&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F04-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/image-20220720222402714_huffaca09dd32077484faf3b7278ea4041_19952_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F04-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/image-20220720222402714_huffaca09dd32077484faf3b7278ea4041_19952_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;链表&amp;#43;索引&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;353&#34;
		data-flex-basis=&#34;848px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;还有另外一种组合方式是索引 + 索引的方式，这种组合称为「&lt;strong&gt;多级索引块&lt;/strong&gt;」，实现方式是&lt;strong&gt;通过一个索引块来存放多个索引数据块&lt;/strong&gt;，一层套一层索引，像极了俄罗斯套娃是吧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F04-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/image-20220720222413748.png&#34;
	width=&#34;1067&#34;
	height=&#34;332&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F04-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/image-20220720222413748_hu3b5636eec8539623524ab19eca07b6af_29951_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F04-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/image-20220720222413748_hu3b5636eec8539623524ab19eca07b6af_29951_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;多级索引块&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;321&#34;
		data-flex-basis=&#34;771px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;文件存放方式对比&#34;&gt;文件存放方式对比&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F04-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/image-20220720222457865.png&#34;
	width=&#34;977&#34;
	height=&#34;452&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F04-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/image-20220720222457865_huf602c0bf2d28f1bef876403e62420f96_114900_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F04-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/image-20220720222457865_huf602c0bf2d28f1bef876403e62420f96_114900_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;文件存放方式对比&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;216&#34;
		data-flex-basis=&#34;518px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;空闲空间管理&#34;&gt;空闲空间管理&lt;/h2&gt;
&lt;h3 id=&#34;空闲表法&#34;&gt;空闲表法&lt;/h3&gt;
&lt;p&gt;空闲表法就是为所有空闲空间建立一张表，表内容包括空闲区的第一个块号和该空闲区的块个数，注意，这个方式是连续分配的。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F04-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/image-20220720223722892.png&#34;
	width=&#34;1449&#34;
	height=&#34;557&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F04-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/image-20220720223722892_hu2d1de61b80e241ab581694154a8519a5_122268_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F04-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/image-20220720223722892_hu2d1de61b80e241ab581694154a8519a5_122268_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;空闲表&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;260&#34;
		data-flex-basis=&#34;624px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;当请求分配磁盘空间时，系统依次扫描空闲表里的内容，直到找到一个合适的空闲区域为止。当用户撤销一个文件时，系统回收文件空间。这时，也需顺序扫描空闲表，寻找一个空闲表条目并将释放空间的第一个物理块号及它占用的块数填到这个条目中。&lt;/p&gt;
&lt;p&gt;这种方法仅当有少量的空闲区时才有较好的效果。因为，如果存储空间中有着大量的小的空闲区，则空闲表变得很大，这样查询效率会很低。另外，这种分配技术适用于建立连续文件。&lt;/p&gt;
&lt;h3 id=&#34;空闲链表法&#34;&gt;空闲链表法&lt;/h3&gt;
&lt;p&gt;我们也可以使用「链表」的方式来管理空闲空间，每一个空闲块里有一个指针指向下一个空闲块，这样也能很方便的找到空闲块并管理起来。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F04-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/image-20220720223908658.png&#34;
	width=&#34;707&#34;
	height=&#34;287&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F04-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/image-20220720223908658_hu3f879d882c5e9252c646af90a1f6569f_21003_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F04-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/image-20220720223908658_hu3f879d882c5e9252c646af90a1f6569f_21003_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;空闲链表&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;246&#34;
		data-flex-basis=&#34;591px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;当创建文件需要一块或几块时，就从链头上依次取下一块或几块。反之，当回收空间时，把这些空闲块依次接到链头上。&lt;/p&gt;
&lt;p&gt;这种技术只要在主存中保存一个指针，令它指向第一个空闲块。其特点是简单，但不能随机访问，工作效率低，因为每当在链上增加或移动空闲块时需要做很多 I/O 操作，同时数据块的指针消耗了一定的存储空间。&lt;/p&gt;
&lt;p&gt;空闲表法和空闲链表法都不适合用于大型文件系统，因为这会使空闲表或空闲链表太大。&lt;/p&gt;
&lt;h3 id=&#34;位图法&#34;&gt;位图法&lt;/h3&gt;
&lt;p&gt;位图是利用二进制的一位来表示磁盘中一个盘块的使用情况，磁盘上所有的盘块都有一个二进制位与之对应。&lt;/p&gt;
&lt;p&gt;当值为 0 时，表示对应的盘块空闲，值为 1 时，表示对应的盘块已分配。它形式如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;1111110011111110001110110111111100111 ...
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;在 Linux 文件系统就采用了位图的方式来管理空闲空间，不仅用于数据空闲块的管理，还用于 inode 空闲块的管理，因为 inode 也是存储在磁盘的，自然也要有对其管理。&lt;/p&gt;
&lt;h2 id=&#34;文件系统的结构&#34;&gt;文件系统的结构&lt;/h2&gt;
&lt;p&gt;数据块的位图是放在磁盘块里的，假设是放在一个块里，一个块 4K，每位表示一个数据块，共可以表示 &lt;code&gt;4 * 1024 * 8 = 2^15&lt;/code&gt;个空闲块，由于 1 个数据块是 4K 大小，那么最大可以表示的空间为 &lt;code&gt;2^15 * 4 * 1024 = 2^27&lt;/code&gt; 个 byte，也就是 128M。&lt;/p&gt;
&lt;p&gt;也就是说按照上面的结构，如果采用「一个块的位图 + 一系列的块」，外加「一个块的 inode 的位图 + 一系列的 inode 的结构」能表示的最大空间也就 128M，这太少了，现在很多文件都比这个大。&lt;/p&gt;
&lt;p&gt;在 Linux 文件系统，把这个结构称为一个&lt;strong&gt;块组&lt;/strong&gt;，那么有 N 多的块组，就能够表示 N 大的文件。&lt;/p&gt;
&lt;p&gt;下图给出了 Linux Ext2 整个文件系统的结构和块组的内容，文件系统都由大量块组组成，在硬盘上相继排布：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F04-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/image-20220720224158302.png&#34;
	width=&#34;1220&#34;
	height=&#34;410&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F04-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/image-20220720224158302_hu72dd70be56a410eb872439a19cc0407c_45774_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F04-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/image-20220720224158302_hu72dd70be56a410eb872439a19cc0407c_45774_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;linux文件系统结构&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;297&#34;
		data-flex-basis=&#34;714px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;最前面的第一个块是引导块，在系统启动时用于启用引导，接着后面就是一个一个连续的块组了，块组的内容如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;超级块&lt;/em&gt;，包含的是文件系统的重要信息，比如 inode 总个数、块总个数、每个块组的 inode 个数、每个块组的块个数等等。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;块组描述符&lt;/em&gt;，包含文件系统中各个块组的状态，比如块组中空闲块和 inode 的数目等，每个块组都包含了文件系统中「所有块组的组描述符信息」。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;数据位图和 inode 位图&lt;/em&gt;， 用于表示对应的数据块或 inode 是空闲的，还是被使用中。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;inode 列表&lt;/em&gt;，包含了块组中所有的 inode，inode 用于保存文件系统中与各个文件和目录相关的所有元数据。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;数据块&lt;/em&gt;，包含文件的有用数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;超级块和块组描述符表，这两个都是全局信息，而且非常的重要&lt;/strong&gt;，这么做是有两个原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果系统崩溃破坏了超级块或块组描述符，有关文件系统结构和内容的所有信息都会丢失。如果有冗余的副本，该信息是可能恢复的。&lt;/li&gt;
&lt;li&gt;通过使文件和管理数据尽可能接近，减少了磁头寻道和旋转，这可以提高文件系统的性能。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;目录的存储&#34;&gt;目录的存储&lt;/h2&gt;
&lt;p&gt;基于 Linux 一切皆文件的设计思想，目录其实也是个文件，你甚至可以通过 &lt;code&gt;vim&lt;/code&gt; 打开它，它也有 inode，inode 里面也是指向一些块。&lt;/p&gt;
&lt;p&gt;和普通文件不同的是，&lt;strong&gt;普通文件的块里面保存的是文件数据，而目录文件的块里面保存的是目录里面一项一项的文件信息。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在目录文件的块中，最简单的保存格式就是&lt;strong&gt;列表&lt;/strong&gt;，就是一项一项地将目录下的文件信息（如文件名、文件 inode、文件类型等）列在表里。&lt;/p&gt;
&lt;p&gt;列表中每一项就代表该目录下的文件的文件名和对应的 inode，通过这个 inode，就可以找到真正的文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F04-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/image-20220720224351058.png&#34;
	width=&#34;1427&#34;
	height=&#34;882&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F04-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/image-20220720224351058_hu34362f8c3ad42f93da89fcc48e1ad69c_730549_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F04-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/image-20220720224351058_hu34362f8c3ad42f93da89fcc48e1ad69c_730549_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;目录数据块&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;161&#34;
		data-flex-basis=&#34;388px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;通常，第一项是「&lt;code&gt;.&lt;/code&gt;」，表示当前目录，第二项是「&lt;code&gt;..&lt;/code&gt;」，表示上一级目录，接下来就是一项一项的文件名和 inode。&lt;/p&gt;
&lt;p&gt;如果一个目录有超级多的文件，我们要想在这个目录下找文件，按照列表一项一项的找，效率就不高了。&lt;/p&gt;
&lt;p&gt;于是，保存目录的格式改成&lt;strong&gt;哈希表&lt;/strong&gt;，对文件名进行哈希计算，把哈希值保存起来，如果我们要查找一个目录下面的文件名，可以通过名称取哈希。如果哈希能够匹配上，就说明这个文件的信息在相应的块里面。&lt;/p&gt;
&lt;h2 id=&#34;硬链接和软连接&#34;&gt;硬链接和软连接&lt;/h2&gt;
&lt;p&gt;有时候我们希望给某个文件取个别名，那么在 Linux 中可以通过&lt;strong&gt;硬链接（Hard Link）&lt;/strong&gt; 和&lt;strong&gt;软链接（Symbolic Link）&lt;/strong&gt; 的方式来实现，它们都是比较特殊的文件，但是实现方式也是不相同的。&lt;/p&gt;
&lt;h3 id=&#34;硬连接&#34;&gt;硬连接&lt;/h3&gt;
&lt;p&gt;硬链接是&lt;strong&gt;多个目录项中的「索引节点」指向一个文件&lt;/strong&gt;，也就是指向同一个 inode，但是 inode 是不可能跨越文件系统的，每个文件系统都有各自的 inode 数据结构和列表，所以&lt;strong&gt;硬链接是不可用于跨文件系统的&lt;/strong&gt;。由于多个目录项都是指向一个 inode，那么&lt;strong&gt;只有删除文件的所有硬链接以及源文件时，系统才会彻底删除该文件。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F04-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/image-20220720224539724.png&#34;
	width=&#34;1154&#34;
	height=&#34;624&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F04-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/image-20220720224539724_hu9ea82e3b3da66c24ddaa8dc53ecabafa_35447_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F04-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/image-20220720224539724_hu9ea82e3b3da66c24ddaa8dc53ecabafa_35447_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;硬连接&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;184&#34;
		data-flex-basis=&#34;443px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;软连接&#34;&gt;软连接&lt;/h3&gt;
&lt;p&gt;软链接相当于重新创建一个文件，这个文件有&lt;strong&gt;独立的 inode&lt;/strong&gt;，但是这个&lt;strong&gt;文件的内容是另外一个文件的路径&lt;/strong&gt;，所以访问软链接的时候，实际上相当于访问到了另外一个文件，所以&lt;strong&gt;软链接是可以跨文件系统的&lt;/strong&gt;，甚至&lt;strong&gt;目标文件被删除了，链接文件还是在的，只不过指向的文件找不到了而已。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F04-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/image-20220720224624867.png&#34;
	width=&#34;1232&#34;
	height=&#34;642&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F04-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/image-20220720224624867_hu13cf62f41e12c6e2c9e2852121aa4b23_48052_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F04-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/image-20220720224624867_hu13cf62f41e12c6e2c9e2852121aa4b23_48052_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;软连接&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;191&#34;
		data-flex-basis=&#34;460px&#34;
	
&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>操作系统02-进程管理</title>
        <link>https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F02-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</link>
        <pubDate>Tue, 19 Jul 2022 19:28:08 +0800</pubDate>
        
        <guid>https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F02-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</guid>
        <description>&lt;h2 id=&#34;进程&#34;&gt;进程&lt;/h2&gt;
&lt;h3 id=&#34;进程的状态&#34;&gt;进程的状态&lt;/h3&gt;
&lt;p&gt;进程共有五个状态&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建状态（&lt;em&gt;new&lt;/em&gt;）：进程正在被创建时的状态；&lt;/li&gt;
&lt;li&gt;就绪状态（&lt;em&gt;Ready&lt;/em&gt;）：可运行，由于其他进程处于运行状态而暂时停止运行；&lt;/li&gt;
&lt;li&gt;运行状态（&lt;em&gt;Runing&lt;/em&gt;）：该时刻进程占用 CPU；&lt;/li&gt;
&lt;li&gt;阻塞状态（&lt;em&gt;Blocked&lt;/em&gt;）：该进程正在等待某一事件发生（如等待输入/输出操作的完成）而暂时停止运行，这时，即使给它CPU控制权，它也无法运行；&lt;/li&gt;
&lt;li&gt;阻塞挂起状态：进程在外存（硬盘）并等待某个事件的出现；&lt;/li&gt;
&lt;li&gt;就绪挂起状态：进程在外存（硬盘），但只要进入内存，即刻立刻运行；&lt;/li&gt;
&lt;li&gt;结束状态（&lt;em&gt;Exit&lt;/em&gt;）：进程正在从系统中消失时的状态；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;于是，一个完整的进程状态的变迁如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F02-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/image-20220719194409025.png&#34;
	width=&#34;1166&#34;
	height=&#34;722&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F02-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/image-20220719194409025_hu6e34d7aee6d1c15d45f66045adaf77e2_98372_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F02-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/image-20220719194409025_hu6e34d7aee6d1c15d45f66045adaf77e2_98372_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;进程状态&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;161&#34;
		data-flex-basis=&#34;387px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;再来详细说明一下进程的状态变迁：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;NULL -&amp;gt; 创建状态&lt;/em&gt;：一个新进程被创建时的第一个状态；&lt;/li&gt;
&lt;li&gt;&lt;em&gt;创建状态 -&amp;gt; 就绪状态&lt;/em&gt;：当进程被创建完成并初始化后，一切就绪准备运行时，变为就绪状态，这个过程是很快的；&lt;/li&gt;
&lt;li&gt;&lt;em&gt;就绪态 -&amp;gt; 运行状态&lt;/em&gt;：处于就绪状态的进程被操作系统的进程调度器选中后，就分配给 CPU 正式运行该进程；&lt;/li&gt;
&lt;li&gt;&lt;em&gt;运行状态 -&amp;gt; 结束状态&lt;/em&gt;：当进程已经运行完成或出错时，会被操作系统作结束状态处理；&lt;/li&gt;
&lt;li&gt;&lt;em&gt;运行状态 -&amp;gt; 就绪状态&lt;/em&gt;：处于运行状态的进程在运行过程中，由于分配给它的运行时间片用完，操作系统会把该进程变为就绪态，接着从就绪态选中另外一个进程运行；&lt;/li&gt;
&lt;li&gt;&lt;em&gt;运行状态 -&amp;gt; 阻塞状态&lt;/em&gt;：当进程请求某个事件且必须等待时，例如请求 I/O 事件；&lt;/li&gt;
&lt;li&gt;&lt;em&gt;阻塞状态 -&amp;gt; 就绪状态&lt;/em&gt;：当进程要等待的事件完成时，它从阻塞状态变到就绪状态；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果有大量处于阻塞状态的进程，进程可能会占用着物理内存空间，显然不是我们所希望的，毕竟物理内存空间是有限的，被阻塞状态的进程占用着物理内存就一种浪费物理内存的行为。&lt;/p&gt;
&lt;p&gt;所以，在虚拟内存管理的操作系统中，通常会把阻塞状态的进程的物理内存空间换出到硬盘，等需要再次运行的时候，再从硬盘换入到物理内存。&lt;/p&gt;
&lt;p&gt;那么，就需要一个新的状态，来&lt;strong&gt;描述进程没有占用实际的物理内存空间的情况，这个状态就是挂起状态&lt;/strong&gt;。这跟阻塞状态是不一样，阻塞状态是等待某个事件的返回。&lt;/p&gt;
&lt;h3 id=&#34;pcb进程控制块&#34;&gt;PCB（进程控制块）&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;PCB 是进程存在的唯一标识&lt;/strong&gt;，这意味着一个进程的存在，必然会有一个 PCB，如果进程消失了，那么 PCB 也会随之消失。&lt;/p&gt;
&lt;h4 id=&#34;pcb-具体包含信息&#34;&gt;PCB 具体包含信息&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;进程描述信息：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;进程标识符：标识各个进程，每个进程都有一个并且唯一的标识符；&lt;/li&gt;
&lt;li&gt;用户标识符：进程归属的用户，用户标识符主要为共享和保护服务；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;进程控制和管理信息：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;进程当前状态，如 new、ready、running、waiting 或 blocked 等；&lt;/li&gt;
&lt;li&gt;进程优先级：进程抢占 CPU 时的优先级；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;资源分配清单：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有关内存地址空间或虚拟地址空间的信息，所打开文件的列表和所使用的 I/O 设备信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;CPU 相关信息：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CPU 中各个寄存器的值，当进程被切换时，CPU 的状态信息都会被保存在相应的 PCB 中，以便进程重新执行时，能从断点处继续执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;pcb-组织结构&#34;&gt;PCB 组织结构&lt;/h4&gt;
&lt;p&gt;通常是通过&lt;strong&gt;链表&lt;/strong&gt;的方式进行组织，把具有&lt;strong&gt;相同状态的进程链在一起，组成各种队列&lt;/strong&gt;。比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将所有处于就绪状态的进程链在一起，称为&lt;strong&gt;就绪队列&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;把所有因等待某事件而处于等待状态的进程链在一起就组成各种&lt;strong&gt;阻塞队列&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;另外，对于运行队列在单核 CPU 系统中则只有一个运行指针了，因为单核 CPU 在某个时间，只能运行一个程序。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那么，就绪队列和阻塞队列链表的组织形式如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F02-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/image-20220720140749661.png&#34;
	width=&#34;1052&#34;
	height=&#34;572&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F02-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/image-20220720140749661_hu1f46986af5e8023ed4239022c32dd4fe_23895_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F02-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/image-20220720140749661_hu1f46986af5e8023ed4239022c32dd4fe_23895_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;就绪队列和阻塞队列&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;183&#34;
		data-flex-basis=&#34;441px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;除了链接的组织方式，还有索引方式，它的工作原理：将同一状态的进程组织在一个索引表中，索引表项指向相应的 PCB，不同状态对应不同的索引表。&lt;/p&gt;
&lt;p&gt;一般会选择链表，因为可能面临进程创建，销毁等调度导致进程状态发生变化，所以链表能够更加灵活的插入和删除。&lt;/p&gt;
&lt;h3 id=&#34;进程的控制&#34;&gt;进程的控制&lt;/h3&gt;
&lt;p&gt;我们熟知了进程的状态变迁和进程的数据结构 PCB 后，再来看看进程的&lt;strong&gt;创建、终止、阻塞、唤醒&lt;/strong&gt;的过程，这些过程也就是进程的控制。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;01 创建进程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;操作系统允许一个进程创建另一个进程，而且允许子进程继承父进程所拥有的资源，当子进程被终止时，其在父进程处继承的资源应当还给父进程。同时，终止父进程时同时也会终止其所有的子进程。&lt;/p&gt;
&lt;p&gt;注意：Linux 操作系统对于终止有子进程的父进程，会把子进程交给 1 号进程接管。本文所指出的进程终止概念是宏观操作系统的一种观点，最后怎么实现当然是看具体的操作系统。&lt;/p&gt;
&lt;p&gt;创建进程的过程如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为新进程分配一个唯一的进程标识号，并申请一个空白的 PCB，PCB 是有限的，若申请失败则创建失败；&lt;/li&gt;
&lt;li&gt;为进程分配资源，此处如果资源不足，进程就会进入等待状态，以等待资源；&lt;/li&gt;
&lt;li&gt;初始化 PCB；&lt;/li&gt;
&lt;li&gt;如果进程的调度队列能够接纳新进程，那就将进程插入到就绪队列，等待被调度运行；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;02 终止进程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;进程可以有 3 种终止方式：正常结束、异常结束以及外界干预（信号 &lt;code&gt;kill&lt;/code&gt; 掉）。&lt;/p&gt;
&lt;p&gt;终止进程的过程如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;查找需要终止的进程的 PCB；&lt;/li&gt;
&lt;li&gt;如果处于执行状态，则立即终止该进程的执行，然后将 CPU 资源分配给其他进程；&lt;/li&gt;
&lt;li&gt;如果其还有子进程，则应将其所有子进程终止；&lt;/li&gt;
&lt;li&gt;将该进程所拥有的全部资源都归还给父进程或操作系统；&lt;/li&gt;
&lt;li&gt;将其从 PCB 所在队列中删除；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;03 阻塞进程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当进程需要等待某一事件完成时，它可以调用阻塞语句把自己阻塞等待。而一旦被阻塞等待，它只能由另一个进程唤醒。&lt;/p&gt;
&lt;p&gt;阻塞进程的过程如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;找到将要被阻塞进程标识号对应的 PCB；&lt;/li&gt;
&lt;li&gt;如果该进程为运行状态，则保护其现场，将其状态转为阻塞状态，停止运行；&lt;/li&gt;
&lt;li&gt;将该 PCB 插入到阻塞队列中去；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;04 唤醒进程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;进程由「运行」转变为「阻塞」状态是由于进程必须等待某一事件的完成，所以处于阻塞状态的进程是绝对不可能叫醒自己的。&lt;/p&gt;
&lt;p&gt;如果某进程正在等待 I/O 事件，需由别的进程发消息给它，则只有当该进程所期待的事件出现时，才由发现者进程用唤醒语句叫醒它。&lt;/p&gt;
&lt;p&gt;唤醒进程的过程如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在&lt;strong&gt;该事件的阻塞队列&lt;/strong&gt;中找到相应进程的 PCB；&lt;/li&gt;
&lt;li&gt;将其从阻塞队列中移出，并置其状态为就绪状态；&lt;/li&gt;
&lt;li&gt;把该 PCB 插入到就绪队列中，等待调度程序调度；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;进程的阻塞和唤醒是一对功能相反的语句，如果某个进程调用了阻塞语句，则必有一个与之对应的唤醒语句。&lt;/p&gt;
&lt;h3 id=&#34;进程的上下文切换&#34;&gt;进程的上下文切换&lt;/h3&gt;
&lt;p&gt;各个进程之间是共享 CPU 资源的，在不同的时候进程之间需要切换，让不同的进程可以在 CPU 执行，那么这个&lt;strong&gt;一个进程切换到另一个进程运行，称为进程的上下文切换&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;CPU 上下文切换就是先把前一个任务的 CPU 上下文（CPU 寄存器和程序计数器）保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务。&lt;/p&gt;
&lt;p&gt;系统内核会存储保持下来的上下文信息，当此任务再次被分配给 CPU 运行时，CPU 会重新加载这些上下文，这样就能保证任务原来的状态不受影响，让任务看起来还是连续运行。&lt;/p&gt;
&lt;p&gt;进程是由内核管理和调度的，所以进程的切换只能发生在内核态。&lt;/p&gt;
&lt;p&gt;所以，&lt;strong&gt;进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通常，会把交换的信息保存在进程的 PCB，当要运行另外一个进程的时候，我们需要从这个进程的 PCB 取出上下文，然后恢复到 CPU 中，这使得这个进程可以继续执行，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F02-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/image-20220720144039605.png&#34;
	width=&#34;870&#34;
	height=&#34;191&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F02-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/image-20220720144039605_huf3946d48492702f2dbca68d54ae7a7f7_22706_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F02-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/image-20220720144039605_huf3946d48492702f2dbca68d54ae7a7f7_22706_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;进程上下文切换&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;455&#34;
		data-flex-basis=&#34;1093px&#34;
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;发生进程上下文切换有哪些场景？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;为了保证所有进程可以得到公平调度，CPU 时间被划分为一段段的时间片，这些时间片再被轮流分配给各个进程。这样，当某个进程的时间片耗尽了，进程就从运行状态变为就绪状态，系统从就绪队列选择另外一个进程运行；&lt;/li&gt;
&lt;li&gt;进程在系统资源不足（比如内存不足）时，要等到资源满足后才可以运行，这个时候进程也会被挂起，并由系统调度其他进程运行；&lt;/li&gt;
&lt;li&gt;当进程通过睡眠函数 sleep 这样的方法将自己主动挂起时，自然也会重新调度；&lt;/li&gt;
&lt;li&gt;当有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行；&lt;/li&gt;
&lt;li&gt;发生硬件中断时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;线程&#34;&gt;线程&lt;/h2&gt;
&lt;h3 id=&#34;什么是线程&#34;&gt;什么是线程？&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;线程是进程当中的一条执行流程。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;同一个进程内多个线程之间可以共享代码段、数据段、打开的文件等资源，但每个线程各自都有一套独立的寄存器和栈，这样可以确保线程的控制流是相对独立的。&lt;/p&gt;
&lt;h3 id=&#34;线程与进程的比较&#34;&gt;线程与进程的比较&lt;/h3&gt;
&lt;p&gt;线程与进程的比较如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;进程是资源（包括内存、打开的文件等）分配的单位，线程是 CPU 调度的单位；&lt;/li&gt;
&lt;li&gt;进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈；&lt;/li&gt;
&lt;li&gt;线程同样具有就绪、阻塞、执行三种基本状态，同样具有状态之间的转换关系；&lt;/li&gt;
&lt;li&gt;线程能减少并发执行的时间和空间开销；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于，线程相比进程能减少开销，体现在：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线程的&lt;strong&gt;创建时间&lt;/strong&gt;比进程快，因为进程在创建的过程中，还需要资源管理信息，比如内存管理信息、文件管理信息，而线程在创建的过程中，不会涉及这些资源管理信息，而是共享它们；&lt;/li&gt;
&lt;li&gt;线程的&lt;strong&gt;终止时间&lt;/strong&gt;比进程快，因为线程释放的资源相比进程少很多；&lt;/li&gt;
&lt;li&gt;同一个进程内的线程切换比进程切换快，因为线程具有相同的地址空间（虚拟内存共享），这意味着同一个进程的线程都具有同一个页表，那么在切换的时候&lt;strong&gt;不需要切换页表&lt;/strong&gt;。而对于进程之间的切换，切换的时候要把页表给切换掉，而页表的切换过程开销是比较大的；&lt;/li&gt;
&lt;li&gt;由于同一进程的各线程间共享内存和文件资源，那么在&lt;strong&gt;线程之间数据传递&lt;/strong&gt;的时候，就不需要经过内核了，这就使得线程之间的数据交互效率更高了；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以，不管是时间效率，还是空间效率线程比进程都要高。&lt;/p&gt;
&lt;h3 id=&#34;线程的上下文切换&#34;&gt;线程的上下文切换&lt;/h3&gt;
&lt;p&gt;线程与进程最大的区别在于：&lt;strong&gt;线程是调度的基本单位，而进程则是资源拥有的基本单位&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;所以，所谓操作系统的任务调度，实际上的调度对象是线程，而进程只是给线程提供了虚拟内存、全局变量等资源。&lt;/p&gt;
&lt;p&gt;对于线程和进程，我们可以这么理解：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当进程只有一个线程时，可以认为进程就等于线程；&lt;/li&gt;
&lt;li&gt;当进程拥有多个线程时，这些线程会共享相同的虚拟内存和全局变量等资源，这些资源在上下文切换时是不需要修改的；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外，线程也有自己的私有数据，比如栈和寄存器等，这些在上下文切换时也是需要保存的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;线程上下文切换的是什么？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这还得看线程是不是属于同一个进程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当两个线程不是属于同一个进程，则切换的过程就跟进程上下文切换一样；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;当两个线程是属于同一个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据&lt;/strong&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以，线程的上下文切换相比进程，开销要小很多。&lt;/p&gt;
&lt;h3 id=&#34;线程的实现&#34;&gt;线程的实现&lt;/h3&gt;
&lt;p&gt;主要有三种线程的实现方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;用户线程（User Thread）&lt;/strong&gt;：在用户空间实现的线程，不是由内核管理的线程，是由用户态的线程库来完成线程的管理；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内核线程（Kernel Thread）&lt;/strong&gt;：在内核中实现的线程，是由内核管理的线程；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;轻量级进程（LightWeight Process）&lt;/strong&gt;：在内核中来支持用户线程；&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;用户线程&#34;&gt;用户线程&lt;/h4&gt;
&lt;p&gt;用户线程是基于用户态的线程管理库来实现的，那么&lt;strong&gt;线程控制块（Thread Control Block, TCB）&lt;/strong&gt; 也是在库里面来实现的，对于操作系统而言是看不到这个 TCB 的，它只能看到整个进程的 PCB。&lt;/p&gt;
&lt;p&gt;所以，&lt;strong&gt;用户线程的整个线程管理和调度，操作系统是不直接参与的，而是由用户级线程库函数来完成线程的管理，包括线程的创建、终止、同步和调度等。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用户级线程的模型，是&lt;strong&gt;多对一&lt;/strong&gt;的关系，即&lt;strong&gt;多个用户线程对应同一个内核线程&lt;/strong&gt;，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F02-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/image-20220720145706336.png&#34;
	width=&#34;1160&#34;
	height=&#34;749&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F02-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/image-20220720145706336_huc2a06889ebcd64a5c065f85d5ece94ae_71295_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F02-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/image-20220720145706336_huc2a06889ebcd64a5c065f85d5ece94ae_71295_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;用户线程&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;154&#34;
		data-flex-basis=&#34;371px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;用户线程的&lt;strong&gt;优点&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个进程都需要有它私有的线程控制块（TCB）列表，用来跟踪记录它各个线程状态信息（PC、栈指针、寄存器），TCB 由用户级线程库函数来维护，可用于不支持线程技术的操作系统；&lt;/li&gt;
&lt;li&gt;用户线程的切换也是由线程库函数来完成的，无需用户态与内核态的切换，所以速度特别快；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用户线程的&lt;strong&gt;缺点&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;由于操作系统不参与线程的调度，如果一个线程发起了系统调用而阻塞，那进程所包含的用户线程都不能执行了。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;当一个线程开始运行后，除非它主动地交出 CPU 的使用权，否则它所在的进程当中的其他线程无法运行，因为用户态的线程&lt;strong&gt;没法打断当前运行中的线程&lt;/strong&gt;，它没有这个特权，只有操作系统才有，但是用户线程不是由操作系统管理的。&lt;/li&gt;
&lt;li&gt;由于时间片分配给进程，故与其他进程比，在多线程执行时，每个线程得到的时间片较少，执行会比较慢；&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;内核线程&#34;&gt;内核线程&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;内核线程是由操作系统管理的，线程对应的 TCB 自然是放在操作系统里的，这样线程的创建、终止和管理都是由操作系统负责。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;内核线程的模型，是&lt;strong&gt;一对一&lt;/strong&gt;的关系，即一个用户线程对应一个内核线程，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F02-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/image-20220720150008835.png&#34;
	width=&#34;890&#34;
	height=&#34;659&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F02-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/image-20220720150008835_hu90d29bc0c66e07c04503c342299b9e56_60769_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F02-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/image-20220720150008835_hu90d29bc0c66e07c04503c342299b9e56_60769_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;内核线程&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;135&#34;
		data-flex-basis=&#34;324px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;内核线程的&lt;strong&gt;优点&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在一个进程当中，如果某个内核线程发起系统调用而被阻塞，并不会影响其他内核线程的运行；&lt;/li&gt;
&lt;li&gt;分配给线程，多线程的进程获得更多的 CPU 运行时间；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;内核线程的&lt;strong&gt;缺点&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在支持内核线程的操作系统中，由内核来维护进程和线程的上下文信息，如 PCB 和 TCB；&lt;/li&gt;
&lt;li&gt;线程的创建、终止和切换都是通过系统调用的方式来进行，因此对于系统来说，系统开销比较大；&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;轻量级进程&#34;&gt;轻量级进程&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;轻量级进程（Light-weight process，LWP）是内核支持的用户线程，一个进程可有一个或多个 LWP，每个 LWP 是跟内核线程一对一映射的，也就是 LWP 都是由一个内核线程支持。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;另外，LWP 只能由内核管理并像普通进程一样被调度，Linux 内核是支持 LWP 的典型例子。&lt;/p&gt;
&lt;p&gt;在大多数系统中，&lt;strong&gt;LWP与普通进程的区别也在于它只有一个最小的执行上下文和调度程序所需的统计信息&lt;/strong&gt;。一般来说，一个进程代表程序的一个实例，而 LWP 代表程序的执行线程，因为一个执行线程不像进程那样需要那么多状态信息，所以 LWP 也不带有这样的信息。&lt;/p&gt;
&lt;h2 id=&#34;调度&#34;&gt;调度&lt;/h2&gt;
&lt;h3 id=&#34;调度时机&#34;&gt;调度时机&lt;/h3&gt;
&lt;p&gt;比如，以下状态的变化都会触发操作系统的调度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;从就绪态 -&amp;gt; 运行态&lt;/em&gt;：当进程被创建时，会进入到就绪队列，操作系统会从就绪队列选择一个进程运行；&lt;/li&gt;
&lt;li&gt;&lt;em&gt;从运行态 -&amp;gt; 阻塞态&lt;/em&gt;：当进程发生 I/O 事件而阻塞时，操作系统必须另外一个进程运行；&lt;/li&gt;
&lt;li&gt;&lt;em&gt;从运行态 -&amp;gt; 结束态&lt;/em&gt;：当进程退出结束后，操作系统得从就绪队列选择另外一个进程运行；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果硬件时钟提供某个频率的周期性中断，那么可以根据如何处理时钟中断，把调度算法分为两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;非抢占式调度算法&lt;/strong&gt;挑选一个进程，然后让该进程运行直到被阻塞，或者直到该进程退出，才会调用另外一个进程，也就是说不会理时钟中断这个事情。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;抢占式调度算法&lt;/strong&gt;挑选一个进程，然后让该进程只运行某段时间，如果在该时段结束时，该进程仍然在运行时，则会把它挂起，接着调度程序从就绪队列挑选另外一个进程。这种抢占式调度处理，需要在时间间隔的末端发生&lt;strong&gt;时钟中断&lt;/strong&gt;，以便把 CPU 控制返回给调度程序进行调度，也就是常说的&lt;strong&gt;时间片机制&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;调度原则&#34;&gt;调度原则&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;CPU 利用率&lt;/strong&gt;：调度程序应确保 CPU 是始终匆忙的状态，这可提高 CPU 的利用率；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;系统吞吐量&lt;/strong&gt;：吞吐量表示的是单位时间内 CPU 完成进程的数量，长作业的进程会占用较长的 CPU 资源，因此会降低吞吐量，相反，短作业的进程会提升系统吞吐量；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;周转时间&lt;/strong&gt;：周转时间是进程运行和阻塞时间总和，一个进程的周转时间越小越好；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;等待时间&lt;/strong&gt;：这个等待时间不是阻塞状态的时间，而是进程处于就绪队列的时间，等待的时间越长，用户越不满意；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;响应时间&lt;/strong&gt;：用户提交请求到系统第一次产生响应所花费的时间，在交互式系统中，响应时间是衡量调度算法好坏的主要标准。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;调度算法单核cpu&#34;&gt;调度算法（单核CPU）&lt;/h3&gt;
&lt;h4 id=&#34;先来先服务调度算法&#34;&gt;先来先服务调度算法&lt;/h4&gt;
&lt;p&gt;最简单的一个调度算法，就是非抢占式的&lt;strong&gt;先来先服务（First Come First Seved, FCFS）算法&lt;/strong&gt;了。&lt;/p&gt;
&lt;p&gt;顾名思义，先来后到，&lt;strong&gt;每次从就绪队列选择最先进入队列的进程，然后一直运行，直到进程退出或被阻塞，才会继续从队列中选择第一个进程接着运行。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这似乎很公平，但是当一个长作业先运行了，那么后面的短作业等待的时间就会很长，不利于短作业。&lt;/p&gt;
&lt;p&gt;FCFS 对长作业有利，适用于 CPU 繁忙型作业的系统，而不适用于 I/O 繁忙型作业的系统。&lt;/p&gt;
&lt;h4 id=&#34;最短作业优先调度算法&#34;&gt;最短作业优先调度算法&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;最短作业优先（Shortest Job First, SJF）调度算法&lt;/strong&gt;同样也是顾名思义，它会&lt;strong&gt;优先选择运行时间最短的进程来运行&lt;/strong&gt;，这有助于提高系统的吞吐量&lt;/p&gt;
&lt;p&gt;这显然对长作业不利，很容易造成一种极端现象。&lt;/p&gt;
&lt;p&gt;比如，一个长作业在就绪队列等待运行，而这个就绪队列有非常多的短作业，那么就会使得长作业不断的往后推，周转时间变长，致使长作业长期不会被运行。&lt;/p&gt;
&lt;h4 id=&#34;高响应比优先调度算法&#34;&gt;高响应比优先调度算法&lt;/h4&gt;
&lt;p&gt;前面的「先来先服务调度算法」和「最短作业优先调度算法」都没有很好的权衡短作业和长作业。&lt;/p&gt;
&lt;p&gt;那么，&lt;strong&gt;高响应比优先（Highest Response Ratio Next, HRRN）调度算法&lt;/strong&gt;主要是权衡了短作业和长作业。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;每次进行进程调度时，先计算「响应比优先级」，然后把「响应比优先级」最高的进程投入运行&lt;/strong&gt;，「响应比优先级」的计算公式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F02-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/image-20220720153850738.png&#34;
	width=&#34;572&#34;
	height=&#34;173&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F02-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/image-20220720153850738_hu72ccdc27fdf2570721259285a4ca7086_13715_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F02-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/image-20220720153850738_hu72ccdc27fdf2570721259285a4ca7086_13715_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;响应比&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;330&#34;
		data-flex-basis=&#34;793px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;从上面的公式，可以发现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果两个进程的「等待时间」相同时，「要求的服务时间」越短，「响应比」就越高，这样短作业的进程容易被选中运行；&lt;/li&gt;
&lt;li&gt;如果两个进程「要求的服务时间」相同时，「等待时间」越长，「响应比」就越高，这就兼顾到了长作业进程，因为进程的响应比可以随时间等待的增加而提高，当其等待时间足够长时，其响应比便可以升到很高，从而获得运行的机会；&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;时间片轮转调度算法&#34;&gt;时间片轮转调度算法&lt;/h4&gt;
&lt;p&gt;最古老、最简单、最公平且使用最广的算法就是&lt;strong&gt;时间片轮转（Round Robin, RR）调度算法&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;每个进程被分配一个时间段，称为时间片（Quantum），即允许该进程在该时间段中运行。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果时间片用完，进程还在运行，那么将会把此进程从 CPU 释放出来，并把 CPU 分配给另外一个进程；&lt;/li&gt;
&lt;li&gt;如果该进程在时间片结束前阻塞或结束，则 CPU 立即进行切换；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外，时间片的长度就是一个很关键的点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果时间片设得太短会导致过多的进程上下文切换，降低了 CPU 效率；&lt;/li&gt;
&lt;li&gt;如果设得太长又可能引起对短作业进程的响应时间变长。将&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一般来说，时间片设为 &lt;code&gt;20ms~50ms&lt;/code&gt; 通常是一个比较合理的折中值。&lt;/p&gt;
&lt;h4 id=&#34;最高优先级调度算法&#34;&gt;最高优先级调度算法&lt;/h4&gt;
&lt;p&gt;前面的「时间片轮转算法」做了个假设，即让所有的进程同等重要，也不偏袒谁，大家的运行时间都一样。&lt;/p&gt;
&lt;p&gt;但是，对于多用户计算机系统就有不同的看法了，它们希望调度是有优先级的，即希望调度程序能&lt;strong&gt;从就绪队列中选择最高优先级的进程进行运行，这称为最高优先级（Highest Priority First，HPF）调度算法&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;进程的优先级可以分为，静态优先级和动态优先级：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;静态优先级：创建进程时候，就已经确定了优先级了，然后整个运行时间优先级都不会变化；&lt;/li&gt;
&lt;li&gt;动态优先级：根据进程的动态变化调整优先级，比如如果进程运行时间增加，则降低其优先级，如果进程等待时间（就绪队列的等待时间）增加，则升高其优先级，也就是&lt;strong&gt;随着时间的推移增加等待进程的优先级&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;该算法也有两种处理优先级高的方法，非抢占式和抢占式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;非抢占式：当就绪队列中出现优先级高的进程，运行完当前进程，再选择优先级高的进程。&lt;/li&gt;
&lt;li&gt;抢占式：当就绪队列中出现优先级高的进程，当前进程挂起，调度优先级高的进程运行。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但是依然有缺点，可能会导致低优先级的进程永远不会运行。&lt;/p&gt;
&lt;h4 id=&#34;多级反馈队列调度算法&#34;&gt;多级反馈队列调度算法&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;多级反馈队列（Multilevel Feedback Queue）调度算法&lt;/strong&gt;是「时间片轮转算法」和「最高优先级算法」的综合和发展。&lt;/p&gt;
&lt;p&gt;顾名思义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;「多级」表示有多个队列，每个队列优先级从高到低，同时优先级越高时间片越短。&lt;/li&gt;
&lt;li&gt;「反馈」表示如果有新的进程加入优先级高的队列时，立刻停止当前正在运行的进程，转而去运行优先级高的队&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F02-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/image-20220720155249358.png&#34;
	width=&#34;878&#34;
	height=&#34;650&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F02-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/image-20220720155249358_hu3bc6ed05eee3a747a8685112f4d8cb8b_47955_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F02-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/image-20220720155249358_hu3bc6ed05eee3a747a8685112f4d8cb8b_47955_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;多级反馈队列调度算法&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;135&#34;
		data-flex-basis=&#34;324px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;来看看，它是如何工作的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设置了多个队列，赋予每个队列不同的优先级，每个&lt;strong&gt;队列优先级从高到低&lt;/strong&gt;，同时&lt;strong&gt;优先级越高时间片越短&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;新的进程会被放入到第一级队列的末尾，按先来先服务的原则排队等待被调度，如果在第一级队列规定的时间片没运行完成，则将其转入到第二级队列的末尾，以此类推，直至完成；&lt;/li&gt;
&lt;li&gt;当较高优先级的队列为空，才调度较低优先级的队列中的进程运行。如果进程运行时，有新进程进入较高优先级的队列，则停止当前运行的进程并将其移入到原队列末尾，接着让较高优先级的进程运行；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以发现，对于短作业可能可以在第一级队列很快被处理完。对于长作业，如果在第一级队列处理不完，可以移入下次队列等待被执行，虽然等待的时间变长了，但是运行时间也变更长了，所以该算法很好的&lt;strong&gt;兼顾了长短作业，同时有较好的响应时间。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;进程间通信&#34;&gt;进程间通信&lt;/h2&gt;
&lt;h3 id=&#34;管道&#34;&gt;管道&lt;/h3&gt;
&lt;h4 id=&#34;匿名管道&#34;&gt;匿名管道&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ ps auxf &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; grep mysql
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;上面命令行里的「&lt;code&gt;|&lt;/code&gt;」竖线就是一个&lt;strong&gt;管道&lt;/strong&gt;，它的功能是将前一个命令（&lt;code&gt;ps auxf&lt;/code&gt;）的输出，作为后一个命令（&lt;code&gt;grep mysql&lt;/code&gt;）的输入，从这功能描述，可以看出&lt;strong&gt;管道传输数据是单向的&lt;/strong&gt;，如果想相互通信，我们需要创建两个管道才行。&lt;/p&gt;
&lt;p&gt;匿名管道是特殊的文件，只存在于内存，不存于文件系统中。&lt;/p&gt;
&lt;p&gt;同时，我们得知上面这种管道是没有名字，所以「&lt;code&gt;|&lt;/code&gt;」表示的管道称为&lt;strong&gt;匿名管道&lt;/strong&gt;，用完了就销毁。&lt;/p&gt;
&lt;h4 id=&#34;命名管道&#34;&gt;命名管道&lt;/h4&gt;
&lt;p&gt;管道还有另外一个类型是&lt;strong&gt;命名管道&lt;/strong&gt;，也被叫做 &lt;code&gt;FIFO&lt;/code&gt;，因为数据是先进先出的传输方式。&lt;/p&gt;
&lt;p&gt;在使用命名管道前，先需要通过 &lt;code&gt;mkfifo&lt;/code&gt; 命令来创建，并且指定管道名字：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ mkfifo myPipe
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;myPipe 就是这个管道的名称，基于 Linux 一切皆文件的理念，所以命名管道也是以文件的方式存在，我们可以用 ls 看一下，这个文件的类型是 p，也就是 pipe（管道） 的意思：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ ls -l
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;prw-r--r--. &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt; root    root         &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; Jul &lt;span class=&#34;m&#34;&gt;17&lt;/span&gt; 02:45 myPipe
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;接下来，我们往 myPipe 这个管道写入数据：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ &lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;hello&amp;#34;&lt;/span&gt; &amp;gt; myPipe  // 将数据写进管道
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                         // 停住了 ...
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;你操作了后，你会发现命令执行后就停在这了，这是因为管道里的内容没有被读取，只有当管道里的数据被读完后，命令才可以正常退出。&lt;/p&gt;
&lt;p&gt;于是，我们执行另外一个命令来读取这个管道里的数据：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ cat &amp;lt; myPipe  // 读取管道里的数据
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;hello
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;可以看到，管道里的内容被读取出来了，并打印在了终端上，另外一方面，echo 那个命令也正常退出了。&lt;/p&gt;
&lt;h4 id=&#34;管道创建的原理&#34;&gt;管道创建的原理&lt;/h4&gt;
&lt;p&gt;匿名管道的创建，需要通过下面这个系统调用：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;int pipe&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;int fd&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;2&lt;span class=&#34;o&#34;&gt;])&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;这里表示创建一个&lt;strong&gt;匿名管道&lt;/strong&gt;，并返回了两个描述符，一个是管道的读取端描述符 &lt;code&gt;fd[0]&lt;/code&gt;，另一个是管道的写入端描述符 &lt;code&gt;fd[1]&lt;/code&gt;。注意，这个匿名管道是特殊的文件，只存在于内存，不存于文件系统中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F02-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/image-20220720160859304.png&#34;
	width=&#34;602&#34;
	height=&#34;570&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F02-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/image-20220720160859304_hua610424b2e1543ab7086ce67ee4521f0_28027_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F02-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/image-20220720160859304_hua610424b2e1543ab7086ce67ee4521f0_28027_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;管道的创建&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;105&#34;
		data-flex-basis=&#34;253px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;其实，&lt;strong&gt;所谓的管道，就是内核里面的一串缓存&lt;/strong&gt;。从管道的一段写入的数据，实际上是缓存在内核中的，另一端读取，也就是从内核中读取这段数据。另外，管道传输的数据是无格式的流且大小受限。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;父子进程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们可以使用 &lt;code&gt;fork&lt;/code&gt; 创建子进程，&lt;strong&gt;创建的子进程会复制父进程的文件描述符&lt;/strong&gt;，这样就做到了两个进程各有两个「 &lt;code&gt;fd[0]&lt;/code&gt; 与 &lt;code&gt;fd[1]&lt;/code&gt;」，两个进程就可以通过各自的 fd 写入和读取同一个管道文件实现跨进程通信了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F02-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/image-20220720160924975.png&#34;
	width=&#34;677&#34;
	height=&#34;977&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F02-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/image-20220720160924975_hu298c1dec29698f2bfd0720292499a4ac_50054_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F02-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/image-20220720160924975_hu298c1dec29698f2bfd0720292499a4ac_50054_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;父子进程管道通信&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;69&#34;
		data-flex-basis=&#34;166px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;管道只能一端写入，另一端读出，所以上面这种模式容易造成混乱，因为父进程和子进程都可以同时写入，也都可以读出。那么，为了避免这种情况，通常的做法是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;父进程关闭读取的 fd[0]，只保留写入的 fd[1]；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;子进程关闭写入的 fd[1]，只保留读取的 fd[0]；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以说如果需要双向通信，则应该创建两个管道。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;非父子进程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;到这里，我们仅仅解析了使用管道进行父进程与子进程之间的通信，但是在我们 shell 里面并不是这样的。&lt;/p&gt;
&lt;p&gt;在 shell 里面执行 &lt;code&gt;A | B&lt;/code&gt;命令的时候，A 进程和 B 进程都是 shell 创建出来的子进程，A 和 B 之间不存在父子关系，它俩的父进程都是 shell。&lt;/p&gt;
&lt;p&gt;所以说，在 shell 里通过「&lt;code&gt;|&lt;/code&gt;」匿名管道将多个命令连接在一起，实际上也就是创建了多个子进程，通过关闭某些读端和写端实现两个子进程之间的通信，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F02-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/image-20220720161211719.png&#34;
	width=&#34;1307&#34;
	height=&#34;1037&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F02-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/image-20220720161211719_hu6cf9614efc6d7225734e7ab452bf2b5d_79576_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F02-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/image-20220720161211719_hu6cf9614efc6d7225734e7ab452bf2b5d_79576_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;shell里的管道符命令原理&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;126&#34;
		data-flex-basis=&#34;302px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;我们可以得知，&lt;strong&gt;对于匿名管道，它的通信范围是存在父子关系的进程&lt;/strong&gt;。因为管道没有实体，也就是没有管道文件，只能通过 fork 来复制父进程 fd 文件描述符，来达到通信的目的。&lt;/p&gt;
&lt;p&gt;另外，&lt;strong&gt;对于命名管道，它可以在不相关的进程间也能相互通信&lt;/strong&gt;。因为命令管道，提前创建了一个类型为管道的设备文件，在进程里只要使用这个设备文件，就可以相互通信。&lt;/p&gt;
&lt;p&gt;不管是匿名管道还是命名管道，进程写入的数据都是缓存在内核中，另一个进程读取数据时候自然也是从内核中获取，同时通信数据都遵循&lt;strong&gt;先进先出&lt;/strong&gt;原则，不支持 lseek 之类的文件定位操作。&lt;/p&gt;
&lt;h3 id=&#34;消息队列&#34;&gt;消息队列&lt;/h3&gt;
&lt;p&gt;前面说到管道的通信方式是效率低的，因此管道不适合进程间频繁地交换数据。&lt;/p&gt;
&lt;p&gt;对于这个问题，&lt;strong&gt;消息队列&lt;/strong&gt;的通信模式就可以解决。比如，A 进程要给 B 进程发送消息，A 进程把数据放在对应的消息队列后就可以正常返回了，B 进程需要的时候再去读取数据就可以了。同理，B 进程要给 A 进程发送消息也是如此。&lt;/p&gt;
&lt;p&gt;再来，&lt;strong&gt;消息队列是保存在内核中的消息链表&lt;/strong&gt;，在发送数据时，会分成一个一个独立的数据单元，也就是消息体（数据块），消息体是用户自定义的数据类型，消息的发送方和接收方要约定好消息体的数据类型，所以每个消息体都是固定大小的存储块，不像管道是无格式的字节流数据。如果进程从消息队列中读取了消息体，内核就会把这个消息体删除。&lt;/p&gt;
&lt;p&gt;消息队列生命周期随内核，如果没有释放消息队列或者没有关闭操作系统，消息队列会一直存在，而前面提到的&lt;strong&gt;匿名管道&lt;/strong&gt;的生命周期，是随进程的创建而建立，随进程的结束而销毁。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;消息队列不适合比较大数据的传输&lt;/strong&gt;，因为在内核中每个消息体都有一个最大长度的限制，同时所有队列所包含的全部消息体的总长度也是有上限。在 Linux 内核中，会有两个宏定义 &lt;code&gt;MSGMAX&lt;/code&gt; 和 &lt;code&gt;MSGMNB&lt;/code&gt;，它们以字节为单位，分别定义了一条消息的最大长度和一个队列的最大长度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销&lt;/strong&gt;，因为进程写入数据到内核中的消息队列时，会发生从用户态拷贝数据到内核态的过程，同理另一进程读取内核中的消息数据时，会发生从内核态拷贝数据到用户态的过程。&lt;/p&gt;
&lt;h3 id=&#34;共享内存&#34;&gt;共享内存&lt;/h3&gt;
&lt;p&gt;消息队列的读取和写入的过程，都会有发生用户态与内核态之间的消息拷贝过程。那&lt;strong&gt;共享内存&lt;/strong&gt;的方式，就很好的解决了这一问题。&lt;/p&gt;
&lt;p&gt;现代操作系统，对于内存管理，采用的是虚拟内存技术，也就是每个进程都有自己独立的虚拟内存空间，不同进程的虚拟内存映射到不同的物理内存中。所以，即使进程 A 和 进程 B 的虚拟地址是一样的，其实访问的是不同的物理内存地址，对于数据的增删查改互不影响。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中&lt;/strong&gt;。这样这个进程写入的东西，另外一个进程马上就能看到了，都不需要拷贝来拷贝去，传来传去，大大提高了进程间通信的速度。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F02-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/image-20220720162544015.png&#34;
	width=&#34;714&#34;
	height=&#34;609&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F02-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/image-20220720162544015_hu106753bb37647ce4ea03b027cf254138_27525_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F02-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/image-20220720162544015_hu106753bb37647ce4ea03b027cf254138_27525_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;共享内存&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;117&#34;
		data-flex-basis=&#34;281px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;信号量&#34;&gt;信号量&lt;/h3&gt;
&lt;p&gt;用了共享内存通信方式，带来新的问题，那就是如果多个进程同时修改同一个共享内存，很有可能就冲突了。例如两个进程都同时写一个地址，那先写的那个进程会发现内容被别人覆盖了。&lt;/p&gt;
&lt;p&gt;为了防止多进程竞争共享资源，而造成的数据错乱，所以需要保护机制，使得共享的资源，在任意时刻只能被一个进程访问。正好，&lt;strong&gt;信号量&lt;/strong&gt;就实现了这一保护机制。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;信号量其实是一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;信号量表示资源的数量，控制信号量的方式有两种原子操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;一个是 &lt;strong&gt;P 操作&lt;/strong&gt;，这个操作会把信号量减去 1，相减后如果信号量 &amp;lt; 0，则表明资源已被占用，进程需阻塞等待；相减后如果信号量 &amp;gt;= 0，则表明还有资源可使用，进程可正常继续执行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;另一个是 &lt;strong&gt;V 操作&lt;/strong&gt;，这个操作会把信号量加上 1，相加后如果信号量 &amp;lt;= 0，则表明当前有阻塞中的进程，于是会将该进程唤醒运行；相加后如果信号量 &amp;gt; 0，则表明当前没有阻塞中的进程；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;P 操作是用在进入共享资源之前，V 操作是用在离开共享资源之后，这两个操作是必须成对出现的。&lt;/p&gt;
&lt;p&gt;接下来，举个例子，如果要使得两个进程互斥访问共享内存，我们可以初始化信号量为 &lt;code&gt;1&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;信号初始化为 &lt;code&gt;1&lt;/code&gt;，就代表着是&lt;strong&gt;互斥信号量&lt;/strong&gt;，它可以保证共享内存在任何时刻只有一个进程在访问，这就很好的保护了共享内存。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F02-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/image-20220720164142326.png&#34;
	width=&#34;452&#34;
	height=&#34;591&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F02-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/image-20220720164142326_hucc352da9cd5670822a1a3c3350e27ca2_16487_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F02-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/image-20220720164142326_hucc352da9cd5670822a1a3c3350e27ca2_16487_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;互斥信号量&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;76&#34;
		data-flex-basis=&#34;183px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;信号初始化为 &lt;code&gt;0&lt;/code&gt;，就代表着是&lt;strong&gt;同步信号量&lt;/strong&gt;，它可以保证进程 A 应在进程 B 之前执行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F02-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/image-20220720164152725.png&#34;
	width=&#34;467&#34;
	height=&#34;389&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F02-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/image-20220720164152725_hu0c037a73a933e4a8d1671e849925169e_15120_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F02-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/image-20220720164152725_hu0c037a73a933e4a8d1671e849925169e_15120_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;同步信号量&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;120&#34;
		data-flex-basis=&#34;288px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;信号&#34;&gt;信号&lt;/h3&gt;
&lt;p&gt;信号和信号量毫无关系！&lt;/p&gt;
&lt;p&gt;上面说的进程间通信，都是常规状态下的工作模式。&lt;strong&gt;对于异常情况下的工作模式，就需要用「信号」的方式来通知进程。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 Linux 操作系统中， 为了响应各种各样的事件，提供了几十种信号，分别代表不同的意义。我们可以通过 &lt;code&gt;kill -l&lt;/code&gt; 命令，查看所有的信号：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kill -l
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;63) SIGRTMAX-1  64) SIGRTMAX
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;运行在 shell 终端的进程，我们可以通过键盘输入某些组合键的时候，给进程发送信号。例如&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ctrl+C 产生 &lt;code&gt;SIGINT&lt;/code&gt; 信号，表示终止该进程；&lt;/li&gt;
&lt;li&gt;Ctrl+Z 产生 &lt;code&gt;SIGTSTP&lt;/code&gt; 信号，表示停止该进程，但还未结束；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果进程在后台运行，可以通过 &lt;code&gt;kill&lt;/code&gt; 命令的方式给进程发送信号，但前提需要知道运行中的进程 PID 号，例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;kill -9 1050 ，表示给 PID 为 1050 的进程发送 &lt;code&gt;SIGKILL&lt;/code&gt; 信号，用来立即结束该进程；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以，信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令）。&lt;/p&gt;
&lt;p&gt;信号是进程间通信机制中&lt;strong&gt;唯一的异步通信机制&lt;/strong&gt;，因为可以在任何时候发送信号给某一进程，一旦有信号产生，我们就有下面这几种，用户进程对信号的处理方式。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;执行默认操作&lt;/strong&gt;。Linux 对每种信号都规定了默认操作，例如，上面列表中的 SIGTERM 信号，就是终止进程的意思。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;捕捉信号&lt;/strong&gt;。我们可以为信号定义一个信号处理函数。当信号发生时，我们就执行相应的信号处理函数。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;忽略信号&lt;/strong&gt;。当我们不希望处理某些信号的时候，就可以忽略该信号，不做任何处理。有两个信号是应用进程无法捕捉和忽略的，即 &lt;code&gt;SIGKILL&lt;/code&gt; 和 &lt;code&gt;SEGSTOP&lt;/code&gt;，它们用于在任何时候中断或结束某一进程。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;socket&#34;&gt;Socket&lt;/h3&gt;
&lt;p&gt;前面提到的管道、消息队列、共享内存、信号量和信号都是在同一台主机上进行进程间通信，那要想&lt;strong&gt;跨网络与不同主机上的进程之间通信，就需要 Socket 通信了。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;实际上，Socket 通信不仅可以跨网络与不同主机的进程间通信，还可以在同主机上进程间通信。&lt;/p&gt;
&lt;p&gt;我们来看看创建 socket 的系统调用：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;int socket&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;int domain, int type, int protocal&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;三个参数分别代表：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;domain 参数用来指定协议族，比如 AF&lt;em&gt;INET 用于 IPV4、AF&lt;/em&gt;INET6 用于 IPV6、AF&lt;em&gt;LOCAL/AF&lt;/em&gt;UNIX 用于本机；&lt;/li&gt;
&lt;li&gt;type 参数用来指定通信特性，比如 SOCK&lt;em&gt;STREAM 表示的是字节流，对应 TCP、SOCK&lt;/em&gt;DGRAM 表示的是数据报，对应 UDP、SOCK_RAW 表示的是原始套接字；&lt;/li&gt;
&lt;li&gt;protocal 参数原本是用来指定通信协议的，但现在基本废弃。因为协议已经通过前面两个参数指定完成，protocol 目前一般写成 0 即可；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;根据创建 socket 类型的不同，通信的方式也就不同：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实现 TCP 字节流通信： socket 类型是 AF&lt;em&gt;INET 和 SOCK&lt;/em&gt;STREAM；&lt;/li&gt;
&lt;li&gt;实现 UDP 数据报通信：socket 类型是 AF&lt;em&gt;INET 和 SOCK&lt;/em&gt;DGRAM；&lt;/li&gt;
&lt;li&gt;实现本地进程间通信： 「本地字节流 socket 」类型是 AF&lt;em&gt;LOCAL 和 SOCK&lt;/em&gt;STREAM，「本地数据报 socket 」类型是 AF&lt;em&gt;LOCAL 和 SOCK&lt;/em&gt;DGRAM。另外，AF&lt;em&gt;UNIX 和 AF&lt;/em&gt;LOCAL 是等价的，所以 AF_UNIX 也属于本地 socket；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来，简单说一下这三种通信的编程模式。&lt;/p&gt;
&lt;h4 id=&#34;针对-tcp-协议通信的-socket-编程模型&#34;&gt;针对 TCP 协议通信的 socket 编程模型&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F02-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/image-20220720165415984.png&#34;
	width=&#34;1188&#34;
	height=&#34;1007&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F02-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/image-20220720165415984_hu8a0c36c9d773cafe1f7be26ff7eda02c_69211_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F02-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/image-20220720165415984_hu8a0c36c9d773cafe1f7be26ff7eda02c_69211_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;TCP协议的Socket&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;117&#34;
		data-flex-basis=&#34;283px&#34;
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;针对-udp-协议通信的-socket-编程模型&#34;&gt;针对 UDP 协议通信的 socket 编程模型&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F02-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/image-20220720165707328.png&#34;
	width=&#34;513&#34;
	height=&#34;671&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F02-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/image-20220720165707328_hu0fdf2a8a63317f7d6951bf2f5d51a830_29932_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F02-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/image-20220720165707328_hu0fdf2a8a63317f7d6951bf2f5d51a830_29932_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;UDP协议的Socket&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;76&#34;
		data-flex-basis=&#34;183px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;UDP 是没有连接的，所以不需要三次握手，也就不需要像 TCP 调用 listen 和 connect，但是 UDP 的交互仍然需要 IP 地址和端口号，因此也需要 bind。&lt;/p&gt;
&lt;p&gt;对于 UDP 来说，不需要要维护连接，那么也就没有所谓的发送方和接收方，甚至都不存在客户端和服务端的概念，只要有一个 socket 多台机器就可以任意通信，因此每一个 UDP 的 socket 都需要 bind。&lt;/p&gt;
&lt;p&gt;另外，每次通信时，调用 sendto 和 recvfrom，都要传入目标主机的 IP 地址和端口。&lt;/p&gt;
&lt;h4 id=&#34;针对本地进程间通信的-socket-编程模型&#34;&gt;针对本地进程间通信的 socket 编程模型&lt;/h4&gt;
&lt;p&gt;本地 socket 被用于在&lt;strong&gt;同一台主机上进程间通信&lt;/strong&gt;的场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;本地 socket 的编程接口和 IPv4 、IPv6 套接字编程接口是一致的，可以支持「字节流」和「数据报」两种协议；&lt;/li&gt;
&lt;li&gt;本地 socket 的实现效率大大高于 IPv4 和 IPv6 的字节流、数据报 socket 实现；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;本地字节流 socket 和 本地数据报 socket 在 bind 的时候，不像 TCP 和 UDP 要绑定 IP 地址和端口，而是绑定一个本地文件，这也就是它们之间的最大区别。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;多线程同步&#34;&gt;多线程同步&lt;/h2&gt;
&lt;h3 id=&#34;互斥&#34;&gt;互斥&lt;/h3&gt;
&lt;p&gt;上面展示的情况称为&lt;strong&gt;竞争条件（race condition）&lt;/strong&gt;，当多线程相互竞争操作共享变量时，由于运气不好，即在执行过程中发生了上下文切换，我们得到了错误的结果，事实上，每次运行都可能得到不同的结果，因此输出的结果存在&lt;strong&gt;不确定性（indeterminate）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;由于多线程执行操作共享变量的这段代码可能会导致竞争状态，因此我们将此段代码称为&lt;strong&gt;临界区（critical section），它是访问共享资源的代码片段，一定不能给多线程同时执行。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们希望这段代码是&lt;strong&gt;互斥（mutualexclusion）的，也就说保证一个线程在临界区执行时，其他线程应该被阻止进入临界区&lt;/strong&gt;，说白了，就是这段代码执行过程中，最多只能出现一个线程。&lt;/p&gt;
&lt;h3 id=&#34;同步&#34;&gt;同步&lt;/h3&gt;
&lt;p&gt;互斥解决了并发进程/线程对临界区的使用问题。这种基于临界区控制的交互作用是比较简单的，只要一个进程/线程进入了临界区，其他试图想进入临界区的进程/线程都会被阻塞着，直到第一个进程/线程离开了临界区。&lt;/p&gt;
&lt;p&gt;我们都知道在多线程里，每个线程并不一定是顺序执行的，它们基本是以各自独立的、不可预知的速度向前推进，但有时候我们又希望多个线程能密切合作，以实现一个共同的任务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所谓同步，就是并发进程/线程在一些关键点上可能需要互相等待与互通消息，这种相互制约的等待与互通信息称为进程/线程同步&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;互斥与同步的实现和使用&#34;&gt;互斥与同步的实现和使用&lt;/h3&gt;
&lt;p&gt;在进程/线程并发执行的过程中，进程/线程之间存在协作的关系，例如有互斥、同步的关系。&lt;/p&gt;
&lt;p&gt;为了实现进程/线程间正确的协作，操作系统必须提供实现进程协作的措施和方法，主要的方法有两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;锁&lt;/em&gt;：加锁、解锁操作；&lt;/li&gt;
&lt;li&gt;&lt;em&gt;信号量&lt;/em&gt;：P、V 操作；&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;哲学家就餐问题&#34;&gt;哲学家就餐问题&lt;/h4&gt;
&lt;p&gt;解决方案一：限制四个人同时就餐（信号量初始化为4）&lt;/p&gt;
&lt;p&gt;解决方案二：仅当哲学家的左右手筷子都拿起时才允许进餐（拿起左右叉子原子操作）。&lt;/p&gt;
&lt;p&gt;解决方案二：即让偶数编号的哲学家「先拿左边的叉子后拿右边的叉子」，奇数编号的哲学家「先拿右边的叉子后拿左边的叉子」。&lt;/p&gt;
&lt;p&gt;解决方案三：另一个简单的解法是为资源（这里是筷子）分配一个偏序或者分级的关系，并约定所有资源都按照这种顺序获取，按相反顺序释放，而且保证不会有两个无关资源同时被同一项工作所需要。在哲学家就餐问题中，筷子按照某种规则编号为1至5，每一个工作单元（哲学家）总是先拿起左右两边编号较低的筷子，再拿编号较高的。用完筷子后，他总是先放下编号较高的筷子，再放下编号较低的。在这种情况下，当四位哲学家同时拿起他们手边编号较低的筷子时，只有编号最高的筷子留在桌上，从而第五位哲学家就不能使用任何一只筷子了。而且，只有一位哲学家能使用最高编号的筷子，所以他能使用两只筷子用餐。当他吃完后，他会先放下编号最高的筷子，再放下编号较低的筷子，从而让另一位哲学家拿起后边的这只开始吃东西。&lt;/p&gt;
&lt;h2 id=&#34;死锁&#34;&gt;死锁&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;两个线程都在等待对方释放锁&lt;/strong&gt;，在没有外力的作用下，这些线程会一直相互等待，就没办法继续运行，这种情况就是发生了&lt;strong&gt;死锁&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;死锁只有&lt;strong&gt;同时满足&lt;/strong&gt;以下四个条件才会发生：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;互斥条件：互斥条件是指&lt;strong&gt;多个线程不能同时使用同一个资源&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;持有并等待条件：&lt;strong&gt;线程 A 在等待资源 2 的同时并不会释放自己已经持有的资源 1&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;不可剥夺条件：当线程已经持有了资源 ，&lt;strong&gt;在自己使用完之前不能被其他线程获取&lt;/strong&gt;，线程 B 如果也想使用此资源，则只能在线程 A 使用完并释放后才能获取。&lt;/li&gt;
&lt;li&gt;环路等待条件：环路等待条件指都是，在死锁发生的时候，&lt;strong&gt;两个线程获取资源的顺序构成了环形链&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;互斥锁与自旋锁&#34;&gt;互斥锁与自旋锁&lt;/h2&gt;
&lt;h3 id=&#34;互斥锁&#34;&gt;互斥锁&lt;/h3&gt;
&lt;p&gt;加锁失败后，线程会&lt;strong&gt;释放 CPU&lt;/strong&gt; ，给其他线程；&lt;/p&gt;
&lt;p&gt;互斥锁加锁失败时，会从用户态陷入到内核态，让内核帮我们切换线程，虽然简化了使用锁的难度，但是存在一定的性能开销成本。&lt;/p&gt;
&lt;p&gt;那这个开销成本是什么呢？会有&lt;strong&gt;两次线程上下文切换的成本&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当线程加锁失败时，内核会把线程的状态从「运行」状态设置为「睡眠」状态，然后把 CPU 切换给其他线程运行；&lt;/li&gt;
&lt;li&gt;接着，当锁被释放时，之前「睡眠」状态的线程会变为「就绪」状态，然后内核会在合适的时间，把 CPU 切换给该线程运行。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;自旋锁&#34;&gt;自旋锁&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;加锁失败后，线程会&lt;/strong&gt;忙等待，直到它拿到锁&lt;/p&gt;
&lt;p&gt;自旋锁是通过 CPU 提供的 &lt;code&gt;CAS&lt;/code&gt; 函数（&lt;em&gt;Compare And Swap&lt;/em&gt;），在「用户态」完成加锁和解锁操作，不会主动产生线程上下文切换，所以相比互斥锁来说，会快一些，开销也小一些。&lt;/p&gt;
&lt;p&gt;一般加锁的过程，包含两个步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一步，查看锁的状态，如果锁是空闲的，则执行第二步；&lt;/li&gt;
&lt;li&gt;第二步，将锁设置为当前线程持有；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CAS 函数就把这两个步骤合并成一条硬件级指令，形成&lt;strong&gt;原子指令&lt;/strong&gt;，这样就保证了这两个步骤是不可分割的，要么一次性执行完两个步骤，要么两个步骤都不执行。&lt;/p&gt;
&lt;p&gt;使用自旋锁的时候，当发生多线程竞争锁的情况，加锁失败的线程会「忙等待」，直到它拿到锁。这里的「忙等待」可以用 &lt;code&gt;while&lt;/code&gt; 循环等待实现，不过最好是使用 CPU 提供的 &lt;code&gt;PAUSE&lt;/code&gt; 指令来实现「忙等待」，因为可以减少循环等待时的耗电量。&lt;/p&gt;
&lt;p&gt;自旋锁是最比较简单的一种锁，一直自旋，利用 CPU 周期，直到锁可用。&lt;strong&gt;需要注意，在单核 CPU 上，需要抢占式的调度器（即不断通过时钟中断一个线程，运行其他线程）。否则，自旋锁在单 CPU 上无法使用，因为一个自旋的线程永远不会放弃 CPU。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;自旋锁开销少，在多核系统下一般不会主动产生线程切换，适合异步、协程等在用户态切换请求的编程方式，但如果被锁住的代码执行时间过长，自旋的线程会长时间占用 CPU 资源，所以自旋的时间和被锁住的代码执行的时间是成「正比」的关系，我们需要清楚的知道这一点。&lt;/p&gt;
&lt;p&gt;自旋锁与互斥锁使用层面比较相似，但实现层面上完全不同：&lt;strong&gt;当加锁失败时，互斥锁用「线程切换」来应对，自旋锁则用「忙等待」来应对&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;悲观锁与乐观锁&#34;&gt;悲观锁与乐观锁&lt;/h2&gt;
&lt;p&gt;悲观锁做事比较悲观，它认为&lt;strong&gt;多线程同时修改共享资源的概率比较高，于是很容易出现冲突，所以访问共享资源前，先要上锁&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;那相反的，如果多线程同时修改共享资源的概率比较低，就可以采用乐观锁。&lt;/p&gt;
&lt;p&gt;乐观锁做事比较乐观，它假定冲突的概率很低，它的工作方式是：&lt;strong&gt;先修改完共享资源，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;乐观锁的应用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多人在线编辑，先修改，再判断是否发生冲突&lt;/li&gt;
&lt;li&gt;SVG，Git也是提交时才判断冲突&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>操作系统03-内存管理</title>
        <link>https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F03-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</link>
        <pubDate>Tue, 19 Jul 2022 17:05:50 +0800</pubDate>
        
        <guid>https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F03-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</guid>
        <description>&lt;h2 id=&#34;虚拟地址&#34;&gt;虚拟地址&lt;/h2&gt;
&lt;p&gt;我们可以把进程所使用的地址「隔离」开来，即让操作系统为每个进程分配独立的一套「&lt;strong&gt;虚拟地址&lt;/strong&gt;」，人人都有，大家自己玩自己的地址就行，互不干涉。但是有个前提每个进程都不能访问物理地址，至于虚拟地址最终怎么落到物理内存里，对进程来说是透明的，操作系统已经把这些都安排的明明白白了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;操作系统会提供一种机制，将不同进程的虚拟地址和不同内存的物理地址映射起来。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果程序要访问虚拟地址的时候，由操作系统转换成不同的物理地址，这样不同的进程运行的时候，写入的是不同的物理地址，这样就不会冲突了。&lt;/p&gt;
&lt;p&gt;于是，这里就引出了两种地址的概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们程序所使用的内存地址叫做&lt;strong&gt;虚拟内存地址&lt;/strong&gt;（&lt;em&gt;Virtual Memory Address&lt;/em&gt;）&lt;/li&gt;
&lt;li&gt;实际存在硬件里面的空间地址叫&lt;strong&gt;物理内存地址&lt;/strong&gt;（&lt;em&gt;Physical Memory Address&lt;/em&gt;）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;操作系统引入了虚拟内存，进程持有的虚拟地址会通过 CPU 芯片中的内存管理单元（MMU）的映射关系，来转换变成物理地址，然后再通过物理地址访问内存，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F03-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20220719163405369.png&#34;
	width=&#34;831&#34;
	height=&#34;539&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F03-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20220719163405369_hu7771ba620034419cf90013ba5e2f7c80_28128_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F03-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20220719163405369_hu7771ba620034419cf90013ba5e2f7c80_28128_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;虚拟地址转换&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;154&#34;
		data-flex-basis=&#34;370px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;内存分段&#34;&gt;内存分段&lt;/h3&gt;
&lt;p&gt;虚拟地址是通过&lt;strong&gt;段表&lt;/strong&gt;与物理地址进行映射的，分段机制会把程序的虚拟地址分成 4 个段，每个段在段表中有一个项，在这一项找到段的基地址，再加上偏移量，于是就能找到物理内存中的地址，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F03-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20220719163644039.png&#34;
	width=&#34;1055&#34;
	height=&#34;651&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F03-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20220719163644039_hu7d2dfa21e90472fda57e4fc2927f0621_73250_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F03-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20220719163644039_hu7d2dfa21e90472fda57e4fc2927f0621_73250_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;段地址转换&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;162&#34;
		data-flex-basis=&#34;388px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;分段的办法很好，解决了程序本身不需要关心具体的物理内存地址的问题，但它也有一些不足之处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一个就是&lt;strong&gt;内存碎片&lt;/strong&gt;的问题。&lt;/li&gt;
&lt;li&gt;第二个就是&lt;strong&gt;内存交换的效率低&lt;/strong&gt;的问题（内存交换粒度太大）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;内存分页&#34;&gt;内存分页&lt;/h3&gt;
&lt;p&gt;分段的好处就是能产生连续的内存空间，但是会出现内存碎片和内存交换的空间太大的问题。&lt;/p&gt;
&lt;p&gt;要解决这些问题，那么就要想出能少出现一些内存碎片的办法。另外，当需要进行内存交换的时候，让需要交换写入或者从磁盘装载的数据更少一点，这样就可以解决问题了。这个办法，也就是&lt;strong&gt;内存分页&lt;/strong&gt;（&lt;em&gt;Paging&lt;/em&gt;）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小&lt;/strong&gt;。这样一个连续并且尺寸固定的内存空间，我们叫&lt;strong&gt;页&lt;/strong&gt;（&lt;em&gt;Page&lt;/em&gt;）。在 Linux 下，每一页的大小为 &lt;code&gt;4KB&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;虚拟地址与物理地址之间通过&lt;strong&gt;页表&lt;/strong&gt;来映射，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F03-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20220719164053124.png&#34;
	width=&#34;935&#34;
	height=&#34;561&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F03-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20220719164053124_hu331ef90abbb4fa0ddd009260d43d66c3_50154_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F03-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20220719164053124_hu331ef90abbb4fa0ddd009260d43d66c3_50154_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;内存分页&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;166&#34;
		data-flex-basis=&#34;400px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;缺页中断：而当进程访问的虚拟地址在页表中查不到时，系统会产生一个&lt;strong&gt;缺页异常&lt;/strong&gt;，进入系统内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分页是怎么解决分段的内存碎片、内存交换效率低的问题？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于内存空间都是预先划分好的，也就不会像分段会产生间隙非常小的内存，这正是分段会产生内存碎片的原因。而&lt;strong&gt;采用了分页，那么释放的内存都是以页为单位释放的，也就不会产生无法给进程使用的小内存。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果内存空间不够，操作系统会把其他正在运行的进程中的「最近没被使用」的内存页面给释放掉，也就是暂时写在硬盘上，称为&lt;strong&gt;换出&lt;/strong&gt;（&lt;em&gt;Swap Out&lt;/em&gt;）。一旦需要的时候，再加载进来，称为&lt;strong&gt;换入&lt;/strong&gt;（&lt;em&gt;Swap In&lt;/em&gt;）。所以，一次性写入磁盘的也只有少数的一个页或者几个页，不会花太多时间，&lt;strong&gt;内存交换的效率就相对比较高。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F03-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20220719170234253.png&#34;
	width=&#34;1406&#34;
	height=&#34;857&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F03-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20220719170234253_hube0ae2631e29792aa932e471333f94e7_64247_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F03-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20220719170234253_hube0ae2631e29792aa932e471333f94e7_64247_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;内存分页换入换出&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;164&#34;
		data-flex-basis=&#34;393px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;在分页机制下，虚拟地址分为两部分，&lt;strong&gt;页号&lt;/strong&gt;和&lt;strong&gt;页内偏移&lt;/strong&gt;。页号作为页表的索引，&lt;strong&gt;页表&lt;/strong&gt;包含物理页每页所在&lt;strong&gt;物理内存的基地址&lt;/strong&gt;，这个基地址与页内偏移的组合就形成了物理内存地址，见下图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F03-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20220719170308722.png&#34;
	width=&#34;1067&#34;
	height=&#34;797&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F03-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20220719170308722_huf423f7529ea661758fee94eee70e2892_41014_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F03-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20220719170308722_huf423f7529ea661758fee94eee70e2892_41014_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;分页地址映射&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;133&#34;
		data-flex-basis=&#34;321px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;总结一下，对于一个内存地址转换，其实就是这样三个步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;把虚拟内存地址，切分成页号和偏移量；&lt;/li&gt;
&lt;li&gt;根据页号，从页表里面，查询对应的物理页号；&lt;/li&gt;
&lt;li&gt;直接拿物理页号，加上前面的偏移量，就得到了物理内存地址。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;多级页表&#34;&gt;多级页表&lt;/h4&gt;
&lt;p&gt;因为操作系统是可以同时运行非常多的进程的，那这不就意味着页表会非常的庞大。&lt;/p&gt;
&lt;p&gt;在 32 位的环境下，虚拟地址空间共有 4GB，假设一个页的大小是 4KB（2^12），那么就需要大约 100 万 （2^20） 个页，每个「页表项」需要 4 个字节大小来存储，那么整个 4GB 空间的映射就需要有 &lt;code&gt;4MB&lt;/code&gt; 的内存来存储页表。&lt;/p&gt;
&lt;p&gt;这 4MB 大小的页表，看起来也不是很大。但是要知道每个进程都是有自己的虚拟地址空间的，也就说都有自己的页表。&lt;/p&gt;
&lt;p&gt;那么，&lt;code&gt;100&lt;/code&gt; 个进程的话，就需要 &lt;code&gt;400MB&lt;/code&gt; 的内存来存储页表，这是非常大的内存了，更别说 64 位的环境了&lt;/p&gt;
&lt;p&gt;要解决上面的问题，就需要采用一种叫作&lt;strong&gt;多级页表&lt;/strong&gt;（&lt;em&gt;Multi-Level Page Table&lt;/em&gt;）的解决方案。&lt;/p&gt;
&lt;p&gt;在前面我们知道了，对于单页表的实现方式，在 32 位和页大小 &lt;code&gt;4KB&lt;/code&gt; 的环境下，一个进程的页表需要装下 100 多万个「页表项」，并且每个页表项是占用 4 字节大小的，于是相当于每个页表需占用 4MB 大小的空间。&lt;/p&gt;
&lt;p&gt;我们把这个 100 多万个「页表项」的单级页表再分页，将页表（一级页表）分为 &lt;code&gt;1024&lt;/code&gt; 个页表（二级页表），每个表（二级页表）中包含 &lt;code&gt;1024&lt;/code&gt; 个「页表项」，形成&lt;strong&gt;二级分页&lt;/strong&gt;。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F03-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20220719170441463.png&#34;
	width=&#34;1686&#34;
	height=&#34;1146&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F03-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20220719170441463_hu3a57298840d906de5d656e76c57869dd_154508_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F03-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20220719170441463_hu3a57298840d906de5d656e76c57869dd_154508_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;多级页表&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;147&#34;
		data-flex-basis=&#34;353px&#34;
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;你可能会问，分了二级表，映射 4GB 地址空间就需要 4KB（一级页表）+ 4MB（二级页表）的内存，这样占用空间不是更大了吗？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当然如果 4GB 的虚拟地址全部都映射到了物理内存上的话，二级分页占用空间确实是更大了，但是，我们往往不会为一个进程分配那么多内存。&lt;/p&gt;
&lt;p&gt;其实我们应该换个角度来看问题，还记得计算机组成原理里面无处不在的&lt;strong&gt;局部性原理&lt;/strong&gt;么？&lt;/p&gt;
&lt;p&gt;每个进程都有 4GB 的虚拟地址空间，而显然对于大多数程序来说，其使用到的空间远未达到 4GB，因为会存在部分对应的页表项都是空的，根本没有分配，对于已分配的页表项，如果存在最近一定时间未访问的页表，在物理内存紧张的情况下，操作系统会将页面换出到硬盘，也就是说不会占用物理内存。&lt;/p&gt;
&lt;p&gt;如果使用了二级分页，一级页表就可以覆盖整个 4GB 虚拟地址空间，但&lt;strong&gt;如果某个一级页表的页表项没有被用到，也就不需要创建这个页表项对应的二级页表了，即可以在需要时才创建二级页表&lt;/strong&gt;。做个简单的计算，假设只有 20% 的一级页表项被用到了，那么页表占用的内存空间就只有 4KB（一级页表） + 20% * 4MB（二级页表）= &lt;code&gt;0.804MB&lt;/code&gt;，这对比单级页表的 &lt;code&gt;4MB&lt;/code&gt; 是不是一个巨大的节约？&lt;/p&gt;
&lt;p&gt;那么为什么不分级的页表就做不到这样节约内存呢？我们从页表的性质来看，保存在内存中的页表承担的职责是将虚拟地址翻译成物理地址。假如虚拟地址在页表中找不到对应的页表项，计算机系统就不能工作了。所以&lt;strong&gt;页表一定要覆盖全部虚拟地址空间，不分级的页表就需要有 100 多万个页表项来映射，而二级分页则只需要 1024 个页表项&lt;/strong&gt;（此时一级页表覆盖到了全部虚拟地址空间，二级页表在需要时创建）。&lt;/p&gt;
&lt;h4 id=&#34;tlb快表&#34;&gt;TLB（快表）&lt;/h4&gt;
&lt;p&gt;多级页表虽然解决了空间上的问题，但是虚拟地址到物理地址的转换就多了几道转换的工序，这显然就降低了这俩地址转换的速度，也就是带来了时间上的开销。&lt;/p&gt;
&lt;p&gt;程序是有局部性的，即在一段时间内，整个程序的执行仅限于程序中的某一部分。相应地，执行所访问的存储空间也局限于某个内存区域。&lt;/p&gt;
&lt;p&gt;我们就可以利用这一特性，把最常访问的几个页表项存储到访问速度更快的硬件，于是计算机科学家们，就在 CPU 芯片中，加入了一个专门存放程序最常访问的页表项的 Cache，这个 Cache 就是 &lt;strong&gt;TLB（&lt;em&gt;Translation Lookaside Buffer&lt;/em&gt;）&lt;/strong&gt; ，通常称为页表缓存、转址旁路缓存、快表等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F03-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20220719170955312.png&#34;
	width=&#34;1008&#34;
	height=&#34;509&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F03-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20220719170955312_hu74f27f6e3fd7010e7fa9f8b67f1ea605_31693_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F03-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20220719170955312_hu74f27f6e3fd7010e7fa9f8b67f1ea605_31693_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;TLB&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;198&#34;
		data-flex-basis=&#34;475px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;在 CPU 芯片里面，封装了内存管理单元（&lt;em&gt;Memory Management Unit&lt;/em&gt;）芯片，它用来完成地址转换和 TLB 的访问与交互。&lt;/p&gt;
&lt;p&gt;有了 TLB 后，那么 CPU 在寻址时，会先查 TLB，如果没找到，才会继续查常规的页表。&lt;/p&gt;
&lt;p&gt;TLB 的命中率其实是很高的，因为程序最常访问的页就那么几个。&lt;/p&gt;
&lt;h3 id=&#34;段页式内存管理&#34;&gt;段页式内存管理&lt;/h3&gt;
&lt;p&gt;内存分段和内存分页并不是对立的，它们是可以组合起来在同一个系统中使用的，那么组合起来后，通常称为&lt;strong&gt;段页式内存管理&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;段页式内存管理实现的方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先将程序划分为多个有逻辑意义的段，也就是前面提到的分段机制；&lt;/li&gt;
&lt;li&gt;接着再把每个段划分为多个页，也就是对分段划分出来的连续空间，再划分固定大小的页；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这样，地址结构就由&lt;strong&gt;段号、段内页号和页内位移&lt;/strong&gt;三部分组成。&lt;/p&gt;
&lt;p&gt;用于段页式地址变换的数据结构是每一个程序一张段表，每个段又建立一张页表，段表中的地址是页表的起始地址，而页表中的地址则为某页的物理页号，如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F03-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20220719171112512.png&#34;
	width=&#34;1452&#34;
	height=&#34;699&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F03-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20220719171112512_hub1a9609121469a957ca2d95b1f9e49ab_84793_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F03-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20220719171112512_hub1a9609121469a957ca2d95b1f9e49ab_84793_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;段页式内存管理&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;207&#34;
		data-flex-basis=&#34;498px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;段页式地址变换中要得到物理地址须经过三次内存访问：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一次访问段表，得到页表起始地址；&lt;/li&gt;
&lt;li&gt;第二次访问页表，得到物理页号；&lt;/li&gt;
&lt;li&gt;第三次将物理页号与页内位移组合，得到物理地址。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可用软、硬件相结合的方法实现段页式地址变换，这样虽然增加了硬件成本和系统开销，但提高了内存的利用率。&lt;/p&gt;
&lt;h2 id=&#34;内存页面置换算法&#34;&gt;内存页面置换算法&lt;/h2&gt;
&lt;p&gt;在了解内存页面置换算法前，我们得先谈一下&lt;strong&gt;缺页异常（缺页中断）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;当 CPU 访问的页面不在物理内存时，便会产生一个缺页中断，请求操作系统将所缺页调入到物理内存。那它与一般中断的主要区别在于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;缺页中断在指令执行「期间」产生和处理中断信号，而一般中断在一条指令执行「完成」后检查和处理中断信号。&lt;/li&gt;
&lt;li&gt;缺页中断返回到该指令的开始重新执行「该指令」，而一般中断返回回到该指令的「下一个指令」执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们来看一下缺页中断的处理流程，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F03-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20220720203505314.png&#34;
	width=&#34;1112&#34;
	height=&#34;950&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F03-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20220720203505314_hu64cfc6ff8f575c07b3f0cdce31679c47_86419_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F03-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20220720203505314_hu64cfc6ff8f575c07b3f0cdce31679c47_86419_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;缺页中断&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;117&#34;
		data-flex-basis=&#34;280px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;找不到空闲页的话，就说明此时内存已满了，这时候，就需要「页面置换算法」选择一个物理页，如果该物理页有被修改过（脏页），则把它换出到磁盘，然后把该被置换出去的页表项的状态改成「无效的」，最后把正在访问的页面装入到这个物理页中。&lt;/p&gt;
&lt;p&gt;页表项通常有如下图的字段：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F03-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20220720203551692.png&#34;
	width=&#34;1083&#34;
	height=&#34;93&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F03-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20220720203551692_hu6387822acf02b2c8592fbe00b633377d_23018_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F03-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20220720203551692_hu6387822acf02b2c8592fbe00b633377d_23018_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;页表项字段&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;1164&#34;
		data-flex-basis=&#34;2794px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;状态位&lt;/em&gt;：用于表示该页是否有效，也就是说是否在物理内存中，供程序访问时参考。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;访问字段&lt;/em&gt;：用于记录该页在一段时间被访问的次数，供页面置换算法选择出页面时参考。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;修改位&lt;/em&gt;：表示该页在调入内存后是否有被修改过，由于内存中的每一页都在磁盘上保留一份副本，因此，如果没有修改，在置换该页时就不需要将该页写回到磁盘上，以减少系统的开销；如果已经被修改，则将该页重写到磁盘上，以保证磁盘中所保留的始终是最新的副本。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;硬盘地址&lt;/em&gt;：用于指出该页在硬盘上的地址，通常是物理块号，供调入该页时使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F03-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20220720203620516.png&#34;
	width=&#34;1190&#34;
	height=&#34;1980&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F03-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20220720203620516_hu0bbd89a7992cbfdcb694c6a62682495e_205180_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F03-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20220720203620516_hu0bbd89a7992cbfdcb694c6a62682495e_205180_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;虚拟内存管理流程&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;60&#34;
		data-flex-basis=&#34;144px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;最佳页面置换算法&#34;&gt;最佳页面置换算法&lt;/h3&gt;
&lt;p&gt;最佳页面置换算法基本思路是，&lt;strong&gt;置换在「未来」最长时间不访问的页面&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这很理想，但是实际系统中无法实现，因为程序访问页面时是动态的，我们是无法预知每个页面在「下一次」访问前的等待时间。&lt;/p&gt;
&lt;p&gt;所以，最佳页面置换算法作用是为了衡量你的算法的效率，你的算法效率越接近该算法的效率，那么说明你的算法是高效的。&lt;/p&gt;
&lt;h3 id=&#34;先进先出置换算法&#34;&gt;先进先出置换算法&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;选择在内存驻留时间很长的页面进行中置换&lt;/strong&gt;，这个就是「先进先出置换」算法的思想&lt;/p&gt;
&lt;h3 id=&#34;最近最久未使用的置换算法&#34;&gt;最近最久未使用的置换算法&lt;/h3&gt;
&lt;p&gt;最近最久未使用（&lt;em&gt;LRU&lt;/em&gt;）的置换算法的基本思路是，发生缺页时，&lt;strong&gt;选择最长时间没有被访问的页面进行置换&lt;/strong&gt;，也就是说，该算法假设已经很久没有使用的页面很有可能在未来较长的一段时间内仍然不会被使用。&lt;/p&gt;
&lt;p&gt;这种算法近似最优置换算法，最优置换算法是通过「未来」的使用情况来推测要淘汰的页面，而 LRU 则是通过「历史」的使用情况来推测要淘汰的页面。&lt;/p&gt;
&lt;p&gt;虽然 LRU 在理论上是可以实现的，但代价很高。为了完全实现 LRU，需要在内存中维护一个所有页面的链表，最近最多使用的页面在表头，最近最少使用的页面在表尾。&lt;/p&gt;
&lt;p&gt;困难的是，在每次访问内存时都必须要更新「整个链表」。在链表中找到一个页面，删除它，然后把它移动到表头是一个非常费时的操作。&lt;/p&gt;
&lt;p&gt;所以，LRU 虽然看上去不错，但是由于开销比较大，实际应用中比较少使用。&lt;/p&gt;
&lt;h3 id=&#34;时钟页面置换算法&#34;&gt;时钟页面置换算法&lt;/h3&gt;
&lt;p&gt;那有没有一种即能优化置换的次数，也能方便实现的算法呢？&lt;/p&gt;
&lt;p&gt;时钟页面置换算法就可以两者兼得，它跟 LRU 近似，又是对 FIFO 的一种改进。&lt;/p&gt;
&lt;p&gt;该算法的思路是，把所有的页面都保存在一个类似钟面的「环形链表」中，一个表针指向最老的页面。&lt;/p&gt;
&lt;p&gt;当发生缺页中断时，算法首先检查表针指向的页面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果它的访问位是 0 就淘汰该页面，并把新的页面插入这个位置，然后把表针前移一个位置；&lt;/li&gt;
&lt;li&gt;如果访问位是 1 就清除访问位，并把表针前移一个位置，重复这个过程直到找到了一个访问位为 0 的页面为止；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F03-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20220720203922297.png&#34;
	width=&#34;1166&#34;
	height=&#34;1352&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F03-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20220720203922297_hu5c4777e07b0c5cf530eb644218ab2f1a_135280_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F03-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20220720203922297_hu5c4777e07b0c5cf530eb644218ab2f1a_135280_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;时钟页面置换算法&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;86&#34;
		data-flex-basis=&#34;206px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;最不常用算法&#34;&gt;最不常用算法&lt;/h3&gt;
&lt;p&gt;最不常用（&lt;em&gt;LFU&lt;/em&gt;）算法，这名字听起来很调皮，但是它的意思不是指这个算法不常用，而是&lt;strong&gt;当发生缺页中断时，选择「访问次数」最少的那个页面，并将其淘汰&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;它的实现方式是，对每个页面设置一个「访问计数器」，每当一个页面被访问时，该页面的访问计数器就累加 1。在发生缺页中断时，淘汰计数器值最小的那个页面。&lt;/p&gt;
&lt;p&gt;看起来很简单，每个页面加一个计数器就可以实现了，但是在操作系统中实现的时候，我们需要考虑效率和硬件成本的。&lt;/p&gt;
&lt;p&gt;要增加一个计数器来实现，这个硬件成本是比较高的，另外如果要对这个计数器查找哪个页面访问次数最小，查找链表本身，如果链表长度很大，是非常耗时的，效率不高。&lt;/p&gt;
&lt;p&gt;但还有个问题，LFU 算法只考虑了频率问题，没考虑时间的问题，比如有些页面在过去时间里访问的频率很高，但是现在已经没有访问了，而当前频繁访问的页面由于没有这些页面访问的次数高，在发生缺页中断时，就会可能会误伤当前刚开始频繁访问，但访问次数还不高的页面。&lt;/p&gt;
&lt;p&gt;那这个问题的解决的办法还是有的，可以定期减少访问的次数，比如当发生时间中断时，把过去时间访问的页面的访问次数除以 2，也就说，随着时间的流失，以前的高访问次数的页面会慢慢减少，相当于加大了被置换的概率。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>操作系统01-硬件原理</title>
        <link>https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F01-%E7%A1%AC%E4%BB%B6%E5%8E%9F%E7%90%86/</link>
        <pubDate>Tue, 19 Jul 2022 15:05:03 +0800</pubDate>
        
        <guid>https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F01-%E7%A1%AC%E4%BB%B6%E5%8E%9F%E7%90%86/</guid>
        <description>&lt;h2 id=&#34;冯诺伊曼模型&#34;&gt;冯诺伊曼模型&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F01-%E7%A1%AC%E4%BB%B6%E5%8E%9F%E7%90%86/image-20220719150904126.png&#34;
	width=&#34;920&#34;
	height=&#34;407&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F01-%E7%A1%AC%E4%BB%B6%E5%8E%9F%E7%90%86/image-20220719150904126_hu22670e02696e25176fb6f555a18fe966_42048_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F01-%E7%A1%AC%E4%BB%B6%E5%8E%9F%E7%90%86/image-20220719150904126_hu22670e02696e25176fb6f555a18fe966_42048_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;冯诺依曼模型&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;226&#34;
		data-flex-basis=&#34;542px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;线路位宽与cpu位宽&#34;&gt;线路位宽与CPU位宽&lt;/h2&gt;
&lt;p&gt;数据是如何通过线路传输的呢？其实是通过操作电压，低电压表示 0，高压电压则表示 1。如果构造了高低高这样的信号，其实就是 101 二进制数据，十进制则表示 5，如果只有⼀条线路，就意味着每次只能传递 1 bit 的数据，即 0 或 1，那么传输 101 这个数据，就需要 3 次才能传输完成，这样的效率非常低。&lt;/p&gt;
&lt;p&gt;这样⼀位⼀位传输的方式，称为串行，下⼀个 bit 必须等待上⼀个 bit 传输完成才能进行传输。当然，想⼀次多传⼀些数据，增加线路即可，这时数据就可以并行传输。
为了避免低效率的串行传输的⽅式，线路的位宽最好⼀次就能访问到所有的内存地址。 CPU 要想操作的内存地址就需要地址总线，如果地址总线只有 1 条，那每次只能表示 「0 或 1」这两种情况，所以 CPU ⼀次只能操作 2 个内存地址，如果想要 CPU 操作 4G 的内存，那么就需要 32 条地址总线，因为 2 ^ 32 =4G 。&lt;/p&gt;
&lt;p&gt;知道了线路位宽的意义后，我们再来看看 CPU 位宽。&lt;/p&gt;
&lt;p&gt;CPU 的位宽最好不要小于线路位宽，比如 32 位 CPU 控制 40 位宽的地址总线和数据总线的话，工作起来就会非常复杂且麻烦，所以 32 位的 CPU 最好和 32 位宽的线路搭配，因为 32 位 CPU ⼀次最多只能操作32 位宽的地址总线和数据总线。&lt;/p&gt;
&lt;p&gt;但是并不代表 64 位 CPU 性能比32 位 CPU 高很多，很少应用需要算超过 32 位的数字，所以如果计算的数额不超过 32 位数字的情况下，32 位和 64 位 CPU 之间没什么区别的，只有当计算超过 32 位数字的情况下，64 位的优势才能体现出来。&lt;/p&gt;
&lt;p&gt;另外，32 位 CPU 最大只能操作 4GB 内存，就算你装了 8 GB 内存条，也没用。而 64 位 CPU 寻址范围则很大，理论最大的寻址空间为 2^64 。&lt;/p&gt;
&lt;h2 id=&#34;存储器的层次&#34;&gt;存储器的层次&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F01-%E7%A1%AC%E4%BB%B6%E5%8E%9F%E7%90%86/image-20220719153300329.png&#34;
	width=&#34;1007&#34;
	height=&#34;485&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F01-%E7%A1%AC%E4%BB%B6%E5%8E%9F%E7%90%86/image-20220719153300329_hu8bb09d7dcf0aa5190db316bc507ae8b8_62691_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F01-%E7%A1%AC%E4%BB%B6%E5%8E%9F%E7%90%86/image-20220719153300329_hu8bb09d7dcf0aa5190db316bc507ae8b8_62691_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;存储金字塔&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;207&#34;
		data-flex-basis=&#34;498px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;CPU Cache 用的是⼀种叫 SRAM（Static Random-Access Memory，静态随机存储器） 的芯片。SRAM 之所以叫「静态」存储器，是因为只要有电，数据就可以保持存在，而⼀旦断电，数据就会丢失了。&lt;/p&gt;
&lt;p&gt;在 SRAM 里面，⼀个 bit 的数据，通常需要 6 个晶体管，所以 SRAM 的存储密度不高，同样的物理空间下，能存储的数据是有限的，不过也因为 SRAM 的电路简单，所以访问速度非常快。&lt;/p&gt;
&lt;p&gt;内存用的芯片和 CPU Cache 有所不同，它使用的是⼀种叫作 DRAM （Dynamic Random AccessMemory，动态随机存取存储器） 的芯片。&lt;/p&gt;
&lt;p&gt;相比 SRAM，DRAM 的密度更高，功耗更低，有更大的容量，而且造价比 SRAM 芯片便宜很多。DRAM 存储⼀个 bit 数据，只需要⼀个晶体管和⼀个电容就能存储，但是因为数据会被存储在电容里，电容会不断漏电，所以需要「定时刷新」电容，才能保证数据不会被丢失，这就是 DRAM 之所以被称为「动态」存储器的原因，只有不断刷新，数据才能被存储起来。&lt;/p&gt;
&lt;h2 id=&#34;cache伪共享&#34;&gt;Cache伪共享&lt;/h2&gt;
&lt;p&gt;相邻的数据可能会被两个线程同时访问，这样每个线程都会将这个两个数据加入cache，但是这两个数据又相邻很近，会被记载进同一个cache Line中，这样另一个线程修改一个数据会造成cache的刷新，这样就失去了cache的意义，叫做伪共享。&lt;/p&gt;
&lt;p&gt;避免伪共享：数据对齐，每个cache Line大约为64字节，填充一个不足64字节的数据，就可以独占一个 cache Line。&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
