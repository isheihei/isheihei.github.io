<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Spring on isheihei&#39;s blog</title>
        <link>https://isheihei.github.io/tags/spring/</link>
        <description>Recent content in Spring on isheihei&#39;s blog</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <lastBuildDate>Tue, 23 Aug 2022 22:42:50 +0800</lastBuildDate><atom:link href="https://isheihei.github.io/tags/spring/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Spring常见题目</title>
        <link>https://isheihei.github.io/posts/java/spring%E5%B8%B8%E8%A7%81%E9%A2%98%E7%9B%AE/</link>
        <pubDate>Tue, 23 Aug 2022 22:42:50 +0800</pubDate>
        
        <guid>https://isheihei.github.io/posts/java/spring%E5%B8%B8%E8%A7%81%E9%A2%98%E7%9B%AE/</guid>
        <description>&lt;h2 id=&#34;ioc&#34;&gt;IOC&lt;/h2&gt;
&lt;p&gt;Spring IoC有什么好处呢？ - 知乎 &lt;a class=&#34;link&#34; href=&#34;https://www.zhihu.com/question/23277575&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.zhihu.com/question/23277575&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;容器启动过程&#34;&gt;容器启动过程&lt;/h2&gt;
&lt;h3 id=&#34;beandefination&#34;&gt;BeanDefination&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;字段名（加粗的字段同时支持属性的写入读取，其他字段支持字段的读取）&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;parentName&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;BeanDefination 的父节点，用于相关属性的继承 ，可以为空&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;beanClassName&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;bean的Class名称，可以为空&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;scope&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;bean的scope，IoC容器提供singleton和prototype两种scope，支持业务拓展，默认为singleton&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;lazyInit&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;是否支持懒加载：默认为false，即在IoC容器初始化是进行Bean的初始化，而不是等到应用获取bean时才进行初始化&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;dependsOn&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;描述当前bean初始化前依赖的Spring bean，BeanFactory 确保该初始化顺序&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;autowireCandidate&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;当用户未指明具体引用时，是否将当前bean作为其他bean的类型注入的候选对象集，默认为true&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;primary&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;结合上一个字段&lt;code&gt;autowireCandidate&lt;/code&gt;，当该bean出现在候选对象集中，该bean是否为优先选择的对象，默认为false&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;factoryBeanName&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;用于实例化Bean的工厂类的Bean Name，可为空&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;factoryMethodName&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;用于实例化Bean的工厂类的方法名称，可为空&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;constructorArgumentValues&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;描述Bean初始化的相关函数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;propertyValues&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;描述Bean 相关属性的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;initMethodName&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;描述Bean 内部的自定义的初始化方法&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;destroyMethodName&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;描述Bean 内部的自定义的销毁方法&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;role&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Bean的角色，一般分为&lt;code&gt;APPLICATION&lt;/code&gt;、&lt;code&gt;SUPPORT&lt;/code&gt;、&lt;code&gt;INFRASTRUCTURE&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;description&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Bean描述&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ResolvableType&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Type对象在Spring中的抽象表达，提供较为友好的泛型类型提取&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Abstract&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;是否为Abstract类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ResourceDescription&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;对于BeanDefination定义来源的描述，用于日志等信息展示场景&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;refersh() 流程&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;AppliacationContext.refresh()&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;synchronized加锁，准备工作, 记录容器的启动时间, 标记已启动状态, 处理配置文件种的占位符&lt;/li&gt;
&lt;li&gt;将配置文件解析成一个个bean definition,注册到重建的beanFactory中,(只是提取了配置信息,bean并没有初始化)，同时还设置两个配置属性：1、是否允许bean覆盖2、是否允许循环引用&lt;/li&gt;
&lt;li&gt;设置beanFactory的类加载器, 添加几个beanPostProcessor&lt;/li&gt;
&lt;li&gt;如果bean实现了beanFactoryPostProcessor 将会执行postProcessBeanFactory方法  提供子类的扩展点,到这bean都加载、注册完成,但没有初始化,具体的子类可以在这步添加特殊bfpp实现类做事&lt;/li&gt;
&lt;li&gt;调用beanFactoryPostProcessor 的各个实现类的ppbf方法&lt;/li&gt;
&lt;li&gt;注册BeanPostProcessor的实现类,BeanPostProcessor将在bean初始化前后执行&lt;/li&gt;
&lt;li&gt;初始化当前 ApplicationContext 的 MessageSource，国际化&lt;/li&gt;
&lt;li&gt;初始化当前 ApplicationContext 的事件广播器&lt;/li&gt;
&lt;li&gt;模板方法(钩子方法，具体的子类可以在这里初始化一些特殊的 Bean（在初始化 singleton beans 之前）&lt;/li&gt;
&lt;li&gt;实例化+初始化所有的非懒加载的单例bean&lt;/li&gt;
&lt;li&gt;广播事件，ApplicationContext 初始化完成&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/java/spring%E5%B8%B8%E8%A7%81%E9%A2%98%E7%9B%AE/1771072-20200909164014978-2077560080.png&#34;
	width=&#34;1311&#34;
	height=&#34;1073&#34;
	srcset=&#34;https://isheihei.github.io/posts/java/spring%E5%B8%B8%E8%A7%81%E9%A2%98%E7%9B%AE/1771072-20200909164014978-2077560080_hu5c28096d6537fbaadcd9c813d5f1e9aa_139822_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/java/spring%E5%B8%B8%E8%A7%81%E9%A2%98%E7%9B%AE/1771072-20200909164014978-2077560080_hu5c28096d6537fbaadcd9c813d5f1e9aa_139822_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;img&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;122&#34;
		data-flex-basis=&#34;293px&#34;
	
&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;53
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;refresh&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;throws&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;BeansException&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;IllegalStateException&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;//保证容器启动销毁操作的并发安全
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kd&#34;&gt;synchronized&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;startupShutdownMonitor&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;//准备工作, 记录容器的启动时间, 标记已启动状态, 处理配置文件种的占位符
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;n&#34;&gt;prepareRefresh&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;//这步用于将配置文件解析成一个个bean definition,注册到重建的beanFactory中,(只是提取了配置信息,bean并没有初始化)，同时还设置两个配置属性：1、是否允许bean覆盖2、是否允许循环引用
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;n&#34;&gt;ConfigurableListableBeanFactory&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;beanFactory&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;obtainFreshBeanFactory&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;//设置beanFactory的类加载器, 添加几个beanPostProcessor ,手动注册几个特殊的bean
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;n&#34;&gt;prepareBeanFactory&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;beanFactory&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;try&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;c1&#34;&gt;//如果bean实现了beanFactoryPostProcessor 将会执行postProcessBeanFactory方法  提供子类的扩展点,到这bean都加载、注册完成,但没有初始化,具体的子类可以在这步添加特殊bfpp实现类做事
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;n&#34;&gt;postProcessBeanFactory&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;beanFactory&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;c1&#34;&gt;//调用bfpp的各个实现类的ppbf方法
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;n&#34;&gt;invokeBeanFactoryPostProcessors&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;beanFactory&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;c1&#34;&gt;//注册BeanPostProcessor的实现类,BeanPostProcessor将在bean初始化前后执行
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;n&#34;&gt;registerBeanPostProcessors&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;beanFactory&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;c1&#34;&gt;//初始化当前 ApplicationContext 的 MessageSource，国际化
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;n&#34;&gt;initMessageSource&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;c1&#34;&gt;//初始化当前 ApplicationContext 的事件广播器
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;n&#34;&gt;initApplicationEventMulticaster&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;c1&#34;&gt;//模板方法(钩子方法，具体的子类可以在这里初始化一些特殊的 Bean（在初始化 singleton beans 之前）
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;n&#34;&gt;onRefresh&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;c1&#34;&gt;//注册事件监听器，监听器需要实现 ApplicationListener 接口。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;n&#34;&gt;registerListeners&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;c1&#34;&gt;//实例化+初始化所有的非懒加载的单例bean
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;n&#34;&gt;finishBeanFactoryInitialization&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;beanFactory&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;c1&#34;&gt;//广播事件，ApplicationContext 初始化完成
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;n&#34;&gt;finishRefresh&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;catch&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;BeansException&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ex&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;c1&#34;&gt;// Destroy already created singletons to avoid dangling resources.销毁已经初始化的 singleton 的 Beans，以免有些 bean 会一直占用资源
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;n&#34;&gt;destroyBeans&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;n&#34;&gt;cancelRefresh&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ex&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;c1&#34;&gt;// Propagate exception to caller.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;k&#34;&gt;throw&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ex&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;finally&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;n&#34;&gt;resetCommonCaches&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;bean的生命周期&#34;&gt;Bean的生命周期&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/java/spring%E5%B8%B8%E8%A7%81%E9%A2%98%E7%9B%AE/1771072-20200909164026351-1683760583.png&#34;
	width=&#34;1172&#34;
	height=&#34;1097&#34;
	srcset=&#34;https://isheihei.github.io/posts/java/spring%E5%B8%B8%E8%A7%81%E9%A2%98%E7%9B%AE/1771072-20200909164026351-1683760583_huf17aa757a5484a9a1425c0b492126cc8_107592_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/java/spring%E5%B8%B8%E8%A7%81%E9%A2%98%E7%9B%AE/1771072-20200909164026351-1683760583_huf17aa757a5484a9a1425c0b492126cc8_107592_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;img&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;106&#34;
		data-flex-basis=&#34;256px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;这里不会对Bean的生命周期进行详细的描述，只描述一下大概的过程。&lt;/p&gt;
&lt;p&gt;因此Bean的生命流程大概可以是这样的:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;postProcessBeforeInstantiation&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;实例化（创建）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Aware&lt;/code&gt;接口&lt;/li&gt;
&lt;li&gt;&lt;code&gt;postProcessProperties&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;属性赋值（依赖注入)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;postProcessBeforeInitialization&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果 Bean 实现了&lt;code&gt;InitializingBean&lt;/code&gt;接口，执行&lt;code&gt;afterPropertiesSet()&lt;/code&gt;方法&lt;/li&gt;
&lt;li&gt;初始化(如果 Bean 在配置文件中的定义包含 &lt;code&gt;init-method&lt;/code&gt; 属性，执行指定的方法&lt;/li&gt;
&lt;li&gt;&lt;code&gt;postProcessAfterInitialization&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;使用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;postProcessBeforeDestruction&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;随着&lt;code&gt;BeanFactory&lt;/code&gt;销毁&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;mermaid&#34; align=center&gt;graph LR

创建 --&gt; 依赖注入
依赖注入 --&gt; 初始化
初始化 --&gt; 可用
可用 --&gt; 销毁
  &lt;/div&gt;
  
  &lt;h3 id=&#34;bean后处理器&#34;&gt;Bean后处理器&lt;/h3&gt;
&lt;p&gt;创建前后的增强&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;postProcessBeforeInstantiation
&lt;ul&gt;
&lt;li&gt;这里返回的对象若不为 null 会替换掉原本的 bean，并且仅会走 postProcessAfterInitialization 流程&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;postProcessAfterInstantiation
&lt;ul&gt;
&lt;li&gt;这里如果返回 false 会跳过依赖注入阶段&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;依赖注入前的增强&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;postProcessProperties
&lt;ul&gt;
&lt;li&gt;如 @Autowired、@Value、@Resource&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;初始化前后的增强&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;postProcessBeforeInitialization
&lt;ul&gt;
&lt;li&gt;这里返回的对象会替换掉原本的 bean&lt;/li&gt;
&lt;li&gt;如 @PostConstruct、@ConfigurationProperties&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;postProcessAfterInitialization （&lt;strong&gt;生成代理对象&lt;/strong&gt;）
&lt;ul&gt;
&lt;li&gt;这里返回的对象会替换掉原本的 bean&lt;/li&gt;
&lt;li&gt;如&lt;strong&gt;代理增强&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;销毁之前的增强&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;postProcessBeforeDestruction
&lt;ul&gt;
&lt;li&gt;如 @PreDestroy&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;aware-接口及-initializingbean-接口&#34;&gt;Aware 接口及 InitializingBean 接口&lt;/h3&gt;
&lt;p&gt;收获💡&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Aware 接口提供了一种【内置】 的注入手段，可以将一些 Spring 内部的类根据需要注入，例如
&lt;ul&gt;
&lt;li&gt;BeanNameAware 注入 bean 的名字&lt;/li&gt;
&lt;li&gt;BeanFactoryAware 注入 BeanFactory 容器&lt;/li&gt;
&lt;li&gt;ApplicationContextAware 注入 ApplicationContext 容器&lt;/li&gt;
&lt;li&gt;EmbeddedValueResolverAware 注入 ${} 解析器&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;InitializingBean 接口提供了一种【内置】的初始化手段&lt;/li&gt;
&lt;li&gt;对比
&lt;ul&gt;
&lt;li&gt;内置的注入和初始化不受扩展功能的影响，总会被执行&lt;/li&gt;
&lt;li&gt;而扩展功能受某些情况影响可能会失效（需要配合后置处理器使用，没有后置处理器就会失效）&lt;/li&gt;
&lt;li&gt;因此 Spring 框架内部的类常用内置注入和初始化&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;p&gt;代理的创建时机&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无循环依赖时：初始化之后 (初始化后)&lt;/li&gt;
&lt;li&gt;有循环依赖时：实例创建后, 依赖注入前 , 并暂存于二级缓存&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;依赖注入与初始化不应该被增强, 仍应被施加于原始对象&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Bean的生命周期指的就是：在Spring中，Bean是如何生成的？&lt;/p&gt;
&lt;p&gt;被Spring管理的对象叫做Bean。Bean的生成步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Spring扫描class得到BeanDefinition&lt;/li&gt;
&lt;li&gt;根据得到的BeanDefinition去生成bean&lt;/li&gt;
&lt;li&gt;首先根据class推断构造方法&lt;/li&gt;
&lt;li&gt;根据推断出来的构造方法，反射，得到一个对象（暂时叫做原始对象）&lt;/li&gt;
&lt;li&gt;如果 Bean 实现了 &lt;code&gt;BeanNameAware&lt;/code&gt; 接口，调用 &lt;code&gt;setBeanName()&lt;/code&gt;方法，传入 Bean 的名字。&lt;/li&gt;
&lt;li&gt;如果 Bean 实现了 &lt;code&gt;BeanClassLoaderAware&lt;/code&gt; 接口，调用 &lt;code&gt;setBeanClassLoader()&lt;/code&gt;方法，传入 &lt;code&gt;ClassLoader&lt;/code&gt;对象的实例。&lt;/li&gt;
&lt;li&gt;如果 Bean 实现了 &lt;code&gt;BeanFactoryAware&lt;/code&gt; 接口，调用 &lt;code&gt;setBeanFactory()&lt;/code&gt;方法，传入 &lt;code&gt;BeanFactory&lt;/code&gt;对象的实例。&lt;/li&gt;
&lt;li&gt;与上面的类似，如果实现了其他 &lt;code&gt;*.Aware&lt;/code&gt;接口，就调用相应的方法。&lt;/li&gt;
&lt;li&gt;填充原始对象中的属性（依赖注入）&lt;/li&gt;
&lt;li&gt;如果原始对象中的某个方法被AOP了，那么则需要根据原始对象生成一个代理对象&lt;/li&gt;
&lt;li&gt;把最终生成的代理对象放入单例池（源码中叫做singletonObjects）中，下次getBean时就直接从单例池拿即可&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;springmvc-和-spring&#34;&gt;SpringMVC 和 Spring&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/qfikh/article/details/80507011&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;(49条消息) spring容器和springmvc容器，以及web容器的关系_人鱼线的博客-CSDN博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/java/spring%E5%B8%B8%E8%A7%81%E9%A2%98%E7%9B%AE/v2-88e5d76acf470ac0c8419f402082c873_720w.jpg&#34;
	width=&#34;720&#34;
	height=&#34;522&#34;
	srcset=&#34;https://isheihei.github.io/posts/java/spring%E5%B8%B8%E8%A7%81%E9%A2%98%E7%9B%AE/v2-88e5d76acf470ac0c8419f402082c873_720w_hu78c9355f3dd9e099bc43b76a74046572_50066_480x0_resize_q75_box.jpg 480w, https://isheihei.github.io/posts/java/spring%E5%B8%B8%E8%A7%81%E9%A2%98%E7%9B%AE/v2-88e5d76acf470ac0c8419f402082c873_720w_hu78c9355f3dd9e099bc43b76a74046572_50066_1024x0_resize_q75_box.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;img&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;137&#34;
		data-flex-basis=&#34;331px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;Tomcat在启动时给每个Web应用创建一个全局的上下文环境，这个上下文就是ServletContext，其为后面的Spring容器提供宿主环境。&lt;/p&gt;
&lt;p&gt;Tomcat在启动过程中触发容器初始化事件，Spring的ContextLoaderListener会监听到这个事件，它的contextInitialized方法会被调用，在这个方法中，Spring会初始化全局的Spring根容器，这个就是Spring的IoC容器，IoC容器初始化完毕后，Spring将其存储到ServletContext中，便于以后来获取。&lt;/p&gt;
&lt;p&gt;Tomcat在启动过程中还会扫描Servlet，一个Web应用中的Servlet可以有多个，以SpringMVC中的DispatcherServlet为例，这个Servlet实际上是一个标准的前端控制器，用以转发、匹配、处理每个Servlet请求。&lt;/p&gt;
&lt;p&gt;Servlet一般会延迟加载，当第一个请求达到时，Tomcat&amp;amp;Jetty发现DispatcherServlet还没有被实例化，就调用DispatcherServlet的init方法，DispatcherServlet在初始化的时候会建立自己的容器，叫做SpringMVC 容器，用来持有Spring MVC相关的Bean。同时，Spring MVC还会通过ServletContext拿到Spring根容器，并将Spring根容器设为SpringMVC容器的父容器，请注意，Spring MVC容器可以访问父容器中的Bean，但是父容器不能访问子容器的Bean， 也就是说Spring根容器不能访问SpringMVC容器里的Bean。说的通俗点就是，在Controller里可以访问Service对象，但是在Service里不可以访问Controller对象。&lt;/p&gt;
&lt;h2 id=&#34;拦截器和过滤器&#34;&gt;拦截器和过滤器&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://segmentfault.com/a/1190000022833940&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;过滤器 和 拦截器 6个区别，别再傻傻分不清了 - SegmentFault 思否&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Filter&lt;/code&gt; 是在Servelet之前进行处理，属于 Web容器，而拦截器(&lt;code&gt;Interceptor&lt;/code&gt;) 它是一个&lt;code&gt;Spring&lt;/code&gt;组件，并由&lt;code&gt;Spring&lt;/code&gt;容器管理，并不依赖&lt;code&gt;Tomcat&lt;/code&gt;等容器，是可以单独使用的。不仅能应用在&lt;code&gt;web&lt;/code&gt;程序中，也可以用于&lt;code&gt;Application&lt;/code&gt;、&lt;code&gt;Swing&lt;/code&gt;等程序中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/java/spring%E5%B8%B8%E8%A7%81%E9%A2%98%E7%9B%AE/20200602173814901.png&#34;
	width=&#34;568&#34;
	height=&#34;450&#34;
	srcset=&#34;https://isheihei.github.io/posts/java/spring%E5%B8%B8%E8%A7%81%E9%A2%98%E7%9B%AE/20200602173814901_hu1bbab2e482261d0e2266df0c764a0a59_13339_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/java/spring%E5%B8%B8%E8%A7%81%E9%A2%98%E7%9B%AE/20200602173814901_hu1bbab2e482261d0e2266df0c764a0a59_13339_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;在这里插入图片描述&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;126&#34;
		data-flex-basis=&#34;302px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;三级缓存&#34;&gt;三级缓存&lt;/h2&gt;
&lt;p&gt;循环依赖解决：&lt;a class=&#34;link&#34; href=&#34;https://juejin.cn/post/6844904039231012878&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;循环依赖如何避免和解决 - 掘金 (juejin.cn)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://segmentfault.com/a/1190000023647227&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Spring循环依赖三级缓存是否可以去掉第三级缓存？ - SegmentFault 思否&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/weixin_42157730/article/details/121112572&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;(49条消息) 关于Spring IOC 的 单例缓存池的一些想法_网友小陈_的博客-CSDN博客_spring单例池&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;三级缓存是通用的叫法。&lt;/p&gt;
&lt;p&gt;一级缓存为：singletonObjects&lt;/p&gt;
&lt;p&gt;二级缓存为：earlySingletonObjects&lt;/p&gt;
&lt;p&gt;三级缓存为：singletonFactories&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;先稍微解释一下这三个缓存的作用，后面详细分析：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;singletonObjects中缓存的是已经经历了完整生命周期的bean对象。&lt;/p&gt;
&lt;p&gt;earlySingletonObjects比singletonObjects多了一个early，表示缓存的是早期的bean对象。早期是什么意思？表示Bean的生命周期还没走完就把这个Bean放入earlySingletonObjects。该阶段还没有进行属性注入。&lt;/p&gt;
&lt;p&gt;singletonFactories中缓存的是ObjectFactory，表示对象工厂，用来创建某个对象的。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;singletonObjects：缓存某个beanName对应的经过了完整生命周期的bean&lt;/li&gt;
&lt;li&gt;earlySingletonObjects：缓存提前拿原始对象进行了AOP之后得到的代理对象，原始对象还没有进行属性注入和后续的BeanPostProcessor等生命周期&lt;/li&gt;
&lt;li&gt;singletonFactories：缓存的是一个ObjectFactory，主要用来去生成原始对象进行了AOP之后得到的代理对象，在每个Bean的生成过程中，都会提前暴露一个工厂，这个工厂可能用到，也可能用不到，如果没有出现循环依赖依赖本bean，那么这个工厂无用，本bean按照自己的生命周期执行，执行完后直接把本bean放入singletonObjects中即可，如果出现了循环依赖依赖了本bean，则另外那个bean执行ObjectFactory提交得到一个AOP之后的代理对象(如果有AOP的话，如果无需AOP，则直接得到一个原始对象)。&lt;/li&gt;
&lt;li&gt;其实还要一个缓存，就是earlyProxyReferences，它用来记录某个原始对象是否进行过AOP了。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;从这里可以看出来，三级缓存里把最原始的对象封装到ObjectFactory 工厂对象的逻辑里，而这时候对象是不稳定的，在调用singletonFactory.getObject() 后实际的对象可能会需要代理的包装，才能成为我们实际程序使用的对象， 从而保存到二级缓存里去，这也是三级缓存和二级缓存的区别，二级缓存里保存的对象是经过了代理包装或替换的，三级缓存中的对象还存在不确定性。&lt;/p&gt;
&lt;p&gt;构造器注入的 Bean 的情况，不能解决循环依赖问题，所以尽量使用setter注入，不要使用构造注入。&lt;/p&gt;
&lt;h3 id=&#34;二级缓存行不行&#34;&gt;二级缓存行不行？&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;为什么要包装一层&lt;code&gt;ObjectFactory&lt;/code&gt;对象？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果创建的&lt;code&gt;Bean&lt;/code&gt;有对应的&lt;code&gt;代理&lt;/code&gt;，那其他对象注入时，注入的应该是对应的&lt;code&gt;代理对象&lt;/code&gt;；但是&lt;code&gt;Spring&lt;/code&gt;无法提前知道这个对象是不是有&lt;code&gt;循环依赖&lt;/code&gt;的情况，而&lt;code&gt;正常情况&lt;/code&gt;下（没有&lt;code&gt;循环依赖&lt;/code&gt;情况），&lt;code&gt;Spring&lt;/code&gt;都是在创建好&lt;code&gt;完成品Bean&lt;/code&gt;之后才创建对应的&lt;code&gt;代理&lt;/code&gt;。这时候&lt;code&gt;Spring&lt;/code&gt;有两个选择：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不管有没有&lt;code&gt;循环依赖&lt;/code&gt;，都&lt;code&gt;提前&lt;/code&gt;创建好&lt;code&gt;代理对象&lt;/code&gt;，并将&lt;code&gt;代理对象&lt;/code&gt;放入缓存，出现&lt;code&gt;循环依赖&lt;/code&gt;时，其他对象直接就可以取到代理对象并注入。&lt;/li&gt;
&lt;li&gt;不提前创建好代理对象，在出现&lt;code&gt;循环依赖&lt;/code&gt;被其他对象注入时，才实时生成&lt;code&gt;代理对象&lt;/code&gt;。这样在没有&lt;code&gt;循环依赖&lt;/code&gt;的情况下，&lt;code&gt;Bean&lt;/code&gt;就可以按着&lt;code&gt;Spring设计原则&lt;/code&gt;的步骤来创建。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;Spring&lt;/code&gt;选择了第二种方式&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;第一种方式行不行？&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Sping&lt;/code&gt;选择了&lt;code&gt;第二种&lt;/code&gt;，如果是&lt;code&gt;第一种&lt;/code&gt;，就会有以下不同的处理逻辑：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在&lt;code&gt;提前曝光半成品&lt;/code&gt;时，直接执行&lt;code&gt;getEarlyBeanReference&lt;/code&gt;创建到代理，并放入到缓存&lt;code&gt;earlySingletonObjects&lt;/code&gt;中，这时候&lt;code&gt;earlySingletonObjects&lt;/code&gt;里放的不再是&lt;code&gt;实际对象&lt;/code&gt;，而是&lt;code&gt;代理对象&lt;/code&gt;，代理对象的&lt;code&gt;target(即实际对象)&lt;/code&gt;是&lt;code&gt;半成品&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;有了上一步，那就不需要通过&lt;code&gt;ObjectFactory&lt;/code&gt;来&lt;code&gt;延迟&lt;/code&gt;执行&lt;code&gt;getEarlyBeanReference&lt;/code&gt;，也就不需要&lt;code&gt;singletonFactories&lt;/code&gt;这一级缓存。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;测试结果是可以的&lt;/strong&gt;，并且从源码上分析可以得出两种方式性能是一样的，并不会影响到&lt;code&gt;Sping&lt;/code&gt;启动速度。那为什么&lt;code&gt;Sping&lt;/code&gt;不选择&lt;code&gt;二级缓存&lt;/code&gt;方式，而是要额外加一层缓存？&lt;/p&gt;
&lt;p&gt;如果要使用&lt;code&gt;二级缓存&lt;/code&gt;解决&lt;code&gt;循环依赖&lt;/code&gt;，意味着Bean在&lt;code&gt;构造&lt;/code&gt;完后就创建&lt;code&gt;代理对象&lt;/code&gt;，这样违背了&lt;code&gt;Spring设计原则&lt;/code&gt;。Spring结合AOP跟Bean的生命周期，是在&lt;code&gt;Bean创建完全&lt;/code&gt;之后通过&lt;code&gt;AnnotationAwareAspectJAutoProxyCreator&lt;/code&gt;这个后置处理器来完成的，在这个后置处理的&lt;code&gt;postProcessAfterInitialization&lt;/code&gt;方法中对初始化后的Bean完成AOP代理。如果出现了&lt;code&gt;循环依赖&lt;/code&gt;，那没有办法，只有给Bean先创建代理，但是没有出现循环依赖的情况下，设计之初就是让Bean在生命周期的最后一步完成代理而不是在实例化后就立马完成代理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;循环依赖创建过程&#34;&gt;循环依赖创建过程&lt;/h3&gt;
&lt;p&gt;如果&lt;code&gt;对象A&lt;/code&gt;和&lt;code&gt;对象B&lt;/code&gt;循环依赖，且都有代理的话，那创建的顺序就是&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;A半成品&lt;/code&gt;加入&lt;code&gt;第三级缓存&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;A&lt;/code&gt;填充属性注入&lt;code&gt;B&lt;/code&gt; -&amp;gt; 创建&lt;code&gt;B对象&lt;/code&gt; -&amp;gt; &lt;code&gt;B半成品&lt;/code&gt;加入&lt;code&gt;第三级缓存&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;B&lt;/code&gt;填充属性注入&lt;code&gt;A&lt;/code&gt; -&amp;gt; 创建&lt;code&gt;A代理对象&lt;/code&gt;，从&lt;code&gt;第三级缓存&lt;/code&gt;移除&lt;code&gt;A对象&lt;/code&gt;，&lt;code&gt;A代理对象&lt;/code&gt;加入&lt;code&gt;第二级缓存&lt;/code&gt;（此时&lt;code&gt;A&lt;/code&gt;还是半成品，&lt;code&gt;B&lt;/code&gt;注入的是&lt;code&gt;A代理对象&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;创建&lt;code&gt;B代理对象&lt;/code&gt;（此时&lt;code&gt;B&lt;/code&gt;是完成品） -&amp;gt; 从&lt;code&gt;第三级缓存&lt;/code&gt;移除&lt;code&gt;B对象&lt;/code&gt;，&lt;code&gt;B代理对象&lt;/code&gt;加入&lt;code&gt;第一级缓存&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;A半成品&lt;/code&gt;注入&lt;code&gt;B代理对象&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;从&lt;code&gt;第二级缓存&lt;/code&gt;移除&lt;code&gt;A代理对象&lt;/code&gt;，&lt;code&gt;A代理对象&lt;/code&gt;加入&lt;code&gt;第一级缓存&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/163031798&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Spring是如何解决循环依赖的？ - 知乎 (zhihu.com)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://segmentfault.com/a/1190000023647227&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Spring循环依赖三级缓存是否可以去掉第三级缓存？ - SegmentFault 思否&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;beanfactory-和-factorybean-区别&#34;&gt;BeanFactory 和 FactoryBean 区别&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/aspirant/p/9082858.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;BeanFactory 简介以及它 和FactoryBean的区别(阿里面试) - aspirant - 博客园 (cnblogs.com)&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;它的作用是用制造创建过程较为复杂的产品, 如 SqlSessionFactory, 但 @Bean 已具备等价功能&lt;/li&gt;
&lt;li&gt;使用上较为古怪, 一不留神就会用错
&lt;ol&gt;
&lt;li&gt;被 FactoryBean 创建的产品
&lt;ul&gt;
&lt;li&gt;会认为创建、依赖注入、Aware 接口回调、前初始化这些都是 FactoryBean 的职责, 这些流程都不会走&lt;/li&gt;
&lt;li&gt;唯有后初始化的流程会走, 也就是产品可以被代理增强&lt;/li&gt;
&lt;li&gt;单例的产品不会存储于 BeanFactory 的 singletonObjects 成员中, 而是另一个 factoryBeanObjectCache 成员中&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;按名字去获取时, 拿到的是产品对象, 名字前面加 &amp;amp; 获取的是工厂对象&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;aop&#34;&gt;AOP&lt;/h2&gt;
&lt;p&gt;AOP 底层实现方式之一是代理，由代理结合通知和目标，提供增强功能&lt;/p&gt;
&lt;p&gt;除此以外，aspectj 提供了两种另外的 AOP 底层实现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;第一种是通过 ajc 编译器在&lt;strong&gt;编译&lt;/strong&gt; class 类文件时，就把通知的增强功能，织入到目标类的字节码中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第二种是通过 agent 在&lt;strong&gt;加载&lt;/strong&gt;目标类时，修改目标类的字节码，织入增强功能&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;作为对比，之前学习的代理是&lt;strong&gt;运行&lt;/strong&gt;时生成新的字节码&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;简单比较的话：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;aspectj 在编译和加载时，修改目标字节码，性能较高&lt;/li&gt;
&lt;li&gt;aspectj 因为不用代理，能突破一些技术上的限制，例如对构造、对静态方法、对 final 也能增强&lt;/li&gt;
&lt;li&gt;但 aspectj 侵入性较强，且需要学习新的 aspectj 特有语法，因此没有广泛流行&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;aop-实现之-proxy&#34;&gt;AOP 实现之 proxy&lt;/h3&gt;
&lt;h4 id=&#34;jdk-动态代理&#34;&gt;jdk 动态代理&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;JdkProxyDemo&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kd&#34;&gt;interface&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Foo&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Target&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;implements&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Foo&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;target foo&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;param&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;// 目标对象
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;n&#34;&gt;Target&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;target&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Target&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;// 代理对象
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;n&#34;&gt;Foo&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;proxy&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Foo&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Proxy&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;newProxyInstance&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;n&#34;&gt;Target&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;class&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getClassLoader&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Class&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[]{&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Foo&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;class&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;},&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;method&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                    &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;proxy before...&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                    &lt;span class=&#34;n&#34;&gt;Object&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;method&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;invoke&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                    &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;proxy after...&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;o&#34;&gt;});&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;// 调用代理
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;n&#34;&gt;proxy&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;运行结果&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;proxy before...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;target foo
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;proxy after...
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;收获💡&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;jdk 动态代理要求目标&lt;strong&gt;必须&lt;/strong&gt;实现接口，生成的代理类实现相同接口，因此代理与目标之间是平级兄弟关系&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;cglib-代理&#34;&gt;cglib 代理&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;CglibProxyDemo&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Target&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;target foo&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;param&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;// 目标对象
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;n&#34;&gt;Target&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;target&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Target&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;// 代理对象
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;n&#34;&gt;Target&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;proxy&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Target&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Enhancer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;create&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Target&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;class&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;MethodInterceptor&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;method&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;methodProxy&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;proxy before...&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;n&#34;&gt;Object&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;methodProxy&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;invoke&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;c1&#34;&gt;// 另一种调用方法，不需要目标对象实例
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;//            Object result = methodProxy.invokeSuper(p, args);
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;proxy after...&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;o&#34;&gt;});&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;// 调用代理
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;n&#34;&gt;proxy&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;运行结果与 jdk 动态代理相同&lt;/p&gt;
&lt;p&gt;收获💡&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;cglib 不要求目标实现接口，它生成的代理类是目标的子类，因此代理与目标之间是子父关系&lt;/li&gt;
&lt;li&gt;限制⛔：根据上述分析 final 类无法被 cglib 增强&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;jdk 和 cglib 的区别&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JDK代理只能对实现接口的类生成代理；CGLib是针对类实现代理，对指定的类生成一个子类，并覆盖其中的方法，这种通过继承类的实现方式，不能代理final修饰的类。&lt;/li&gt;
&lt;li&gt;JDK代理使用的是反射机制实现aop的动态代理，CGLib代理使用字节码处理框架ASM，通过修改字节码生成子类。所以jdk动态代理的方式创建代理对象效率较高，执行效率较低，CGLib创建效率较低，执行效率高。&lt;/li&gt;
&lt;li&gt;JDK动态代理机制是委托机制，具体说动态实现接口类，在动态生成的实现类里面委托hanlder去调用原始实现类方法，CGLib则使用的继承机制，具体说被代理类和代理类是继承关系，所以代理类是可以赋值给被代理类的，如果被代理类有接口，那么代理类也可以赋值给接口。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;spring-aop-和-aspectj-aop-有什么区别&#34;&gt;Spring AOP 和 AspectJ AOP 有什么区别？&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。&lt;/strong&gt; Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。&lt;/p&gt;
&lt;p&gt;Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，&lt;/p&gt;
&lt;p&gt;如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比 Spring AOP 快很多&lt;/p&gt;
&lt;h2 id=&#34;component-和-bean-的区别是什么&#34;&gt;@Component 和 @Bean 的区别是什么？&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;@Component&lt;/code&gt; 注解作用于类，而&lt;code&gt;@Bean&lt;/code&gt;注解作用于方法。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Component&lt;/code&gt;通常是通过类路径扫描来自动侦测以及自动装配到 Spring 容器中（我们可以使用 &lt;code&gt;@ComponentScan&lt;/code&gt; 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。&lt;code&gt;@Bean&lt;/code&gt; 注解通常是我们在标有该注解的方法中定义产生这个 bean,&lt;code&gt;@Bean&lt;/code&gt;告诉了 Spring 这是某个类的实例，当我需要用它的时候还给我。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Bean&lt;/code&gt; 注解比 &lt;code&gt;@Component&lt;/code&gt; 注解的自定义性更强，而且很多地方我们只能通过 &lt;code&gt;@Bean&lt;/code&gt; 注解来注册 bean。比如当我们引用第三方库中的类需要装配到 &lt;code&gt;Spring&lt;/code&gt;容器时，则只能通过 &lt;code&gt;@Bean&lt;/code&gt;来实现。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;springmvc-工作原理&#34;&gt;SpringMVC 工作原理&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/img_convert/de6d2b213f112297298f3e223bf08f28.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;img&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;流程说明（重要）：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;客户端（浏览器）发送请求，直接请求到 &lt;code&gt;DispatcherServlet&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DispatcherServlet&lt;/code&gt; 根据请求信息调用 &lt;code&gt;HandlerMapping&lt;/code&gt;，解析请求对应的 &lt;code&gt;Handler&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;解析到对应的 &lt;code&gt;Handler&lt;/code&gt;（也就是我们平常说的 &lt;code&gt;Controller&lt;/code&gt; 控制器）后，开始由 &lt;code&gt;HandlerAdapter&lt;/code&gt; 适配器处理。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;HandlerAdapter&lt;/code&gt; 会根据 &lt;code&gt;Handler&lt;/code&gt;来调用真正的处理器开处理请求，并处理相应的业务逻辑。&lt;/li&gt;
&lt;li&gt;处理器处理完业务后，会返回一个 &lt;code&gt;ModelAndView&lt;/code&gt; 对象，&lt;code&gt;Model&lt;/code&gt; 是返回的数据对象，&lt;code&gt;View&lt;/code&gt; 是个逻辑上的 &lt;code&gt;View&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ViewResolver&lt;/code&gt; 会根据逻辑 &lt;code&gt;View&lt;/code&gt; 查找实际的 &lt;code&gt;View&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DispaterServlet&lt;/code&gt; 把返回的 &lt;code&gt;Model&lt;/code&gt; 传给 &lt;code&gt;View&lt;/code&gt;（视图渲染）。&lt;/li&gt;
&lt;li&gt;把 &lt;code&gt;View&lt;/code&gt; 返回给请求者（浏览器）&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;spring-自动装配&#34;&gt;Spring 自动装配&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://javaguide.cn/system-design/framework/spring/spring-boot-auto-assembly-principles.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Spring Boot 自动装配原理 | JavaGuide&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;autowired和resource的区别是什么&#34;&gt;@Autowired和@Resource的区别是什么&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.zhihu.com/question/39356740&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;@Autowired和@Resource的区别是什么？ - 知乎 (zhihu.com)&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;@Autowired默认按byType自动装配，而@Resource默认byName自动装配。&lt;/li&gt;
&lt;li&gt;@Autowired只包含一个参数：required，表示是否开启自动准入，默认是true。而@Resource包含七个参数，其中最重要的两个参数是：name 和 type。&lt;/li&gt;
&lt;li&gt;@Autowired如果要使用byName，需要使用@Qualifier一起配合。而@Resource如果指定了name，则用byName自动装配，如果指定了type，则用byType自动装配。&lt;/li&gt;
&lt;li&gt;@Autowired能够用在：构造器、方法、参数、成员变量和注解上，而@Resource能用在：类、成员变量和方法上。&lt;/li&gt;
&lt;li&gt;@Autowired是spring定义的注解，而@Resource是JSR-250定义的注解。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;当我们使用自动配置的方式装配Bean时，如果这个Bean有多个候选者，假如其中一个候选者具有@Primary&lt;a class=&#34;link&#34; href=&#34;https://www.zhihu.com/search?q=%e6%b3%a8%e8%a7%a3%e4%bf%ae%e9%a5%b0&amp;amp;search_source=Entity&amp;amp;hybrid_search_source=Entity&amp;amp;hybrid_search_extra=%7b%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1907479772%7d&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;注解修饰&lt;/a&gt;，该候选者会被选中，作为自动配置的值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Filter或Listener类中注入报错&lt;/p&gt;
&lt;p&gt;众所周知，&lt;a class=&#34;link&#34; href=&#34;https://www.zhihu.com/search?q=springmvc&amp;amp;search_source=Entity&amp;amp;hybrid_search_source=Entity&amp;amp;hybrid_search_extra=%7b%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1907479772%7d&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;springmvc&lt;/a&gt;的启动是在DisptachServlet里面做的，而它是在listener和filter之后执行。如果我们想在&lt;a class=&#34;link&#34; href=&#34;https://www.zhihu.com/search?q=listener&amp;amp;search_source=Entity&amp;amp;hybrid_search_source=Entity&amp;amp;hybrid_search_extra=%7b%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1907479772%7d&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;listener&lt;/a&gt;和filter里面@Autowired某个bean，肯定是不行的，因为filter初始化的时候，此时bean还没有初始化，无法自动装配。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其他常见注解&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://javaguide.cn/system-design/framework/spring/spring-common-annotations.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Spring/Spring Boot 常用注解总结！ | JavaGuide&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;spring事务&#34;&gt;Spring事务&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://javaguide.cn/system-design/framework/spring/spring-transaction.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Spring 事务总结 | JavaGuide&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;spring-支持两种方式的事务管理&#34;&gt;Spring 支持两种方式的事务管理&lt;/h3&gt;
&lt;h4 id=&#34;编程式事务管理&#34;&gt;编程式事务管理&lt;/h4&gt;
&lt;p&gt;通过 &lt;code&gt;TransactionTemplate&lt;/code&gt;或者&lt;code&gt;TransactionManager&lt;/code&gt;手动管理事务，实际应用中很少使用，但是对于你理解 Spring 事务管理原理有帮助。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nd&#34;&gt;@Autowired&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;PlatformTransactionManager&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;transactionManager&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;testTransaction&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;TransactionStatus&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;status&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;transactionManager&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getTransaction&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;DefaultTransactionDefinition&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;());&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;          &lt;span class=&#34;k&#34;&gt;try&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;               &lt;span class=&#34;c1&#34;&gt;// ....  业务代码
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;              &lt;span class=&#34;n&#34;&gt;transactionManager&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;commit&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;status&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;          &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;catch&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Exception&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;              &lt;span class=&#34;n&#34;&gt;transactionManager&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;rollback&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;status&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;          &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h4 id=&#34;声明式事务管理&#34;&gt;声明式事务管理&lt;/h4&gt;
&lt;p&gt;推荐使用（代码侵入性最小），实际是通过 AOP 实现（基于&lt;code&gt;@Transactional&lt;/code&gt; 的全注解方式使用最多）。&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;@Transactional&lt;/code&gt;注解进行事务管理的示例代码如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nd&#34;&gt;@Transactional&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;propagation&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;propagation&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;PROPAGATION_REQUIRED&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;aMethod&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;//do something
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;B&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;C&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;bMethod&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;cMethod&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;pring-事务管理接口介绍&#34;&gt;pring 事务管理接口介绍&lt;/h3&gt;
&lt;p&gt;Spring 框架中，事务管理相关最重要的 3 个接口如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;PlatformTransactionManager&lt;/code&gt;&lt;/strong&gt;： （平台）事务管理器，Spring 事务策略的核心。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;TransactionDefinition&lt;/code&gt;&lt;/strong&gt;： 事务定义信息(事务隔离级别、传播行为、超时、只读、回滚规则)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;TransactionStatus&lt;/code&gt;&lt;/strong&gt;： 事务运行状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;platformtransactionmanager&#34;&gt;PlatformTransactionManager：&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;package&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;org.springframework.transaction&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;org.springframework.lang.Nullable&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;interface&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;PlatformTransactionManager&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;//获得事务
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;TransactionStatus&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getTransaction&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nd&#34;&gt;@Nullable&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;TransactionDefinition&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;var1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;throws&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;TransactionException&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;//提交事务
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;commit&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;TransactionStatus&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;var1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;throws&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;TransactionException&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;//回滚事务
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;rollback&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;TransactionStatus&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;var1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;throws&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;TransactionException&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h4 id=&#34;transactiondefinition事务属性&#34;&gt;TransactionDefinition:事务属性&lt;/h4&gt;
&lt;p&gt;事务管理器接口 &lt;strong&gt;&lt;code&gt;PlatformTransactionManager&lt;/code&gt;&lt;/strong&gt; 通过 &lt;strong&gt;&lt;code&gt;getTransaction(TransactionDefinition definition)&lt;/code&gt;&lt;/strong&gt; 方法来得到一个事务，这个方法里面的参数是 &lt;strong&gt;&lt;code&gt;TransactionDefinition&lt;/code&gt;&lt;/strong&gt; 类 ，这个类就定义了一些基本的事务属性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;什么是事务属性呢？&lt;/strong&gt; 事务属性可以理解成事务的一些基本配置，描述了事务策略如何应用到方法上。&lt;/p&gt;
&lt;p&gt;事务属性包含了 5 个方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;隔离级别&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;TransactionDefinition.ISOLATION_DEFAULT&lt;/code&gt;&lt;/strong&gt; :使用后端数据库默认的隔离级别，MySQL 默认采用的 &lt;code&gt;REPEATABLE_READ&lt;/code&gt; 隔离级别 Oracle 默认采用的 &lt;code&gt;READ_COMMITTED&lt;/code&gt; 隔离级别.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;TransactionDefinition.ISOLATION_READ_UNCOMMITTED&lt;/code&gt;&lt;/strong&gt; :最低的隔离级别，使用这个隔离级别很少，因为它允许读取尚未提交的数据变更，&lt;strong&gt;可能会导致脏读、幻读或不可重复读&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;TransactionDefinition.ISOLATION_READ_COMMITTED&lt;/code&gt;&lt;/strong&gt; : 允许读取并发事务已经提交的数据，&lt;strong&gt;可以阻止脏读，但是幻读或不可重复读仍有可能发生&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;TransactionDefinition.ISOLATION_REPEATABLE_READ&lt;/code&gt;&lt;/strong&gt; : 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，&lt;strong&gt;可以阻止脏读和不可重复读，但幻读仍有可能发生。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;TransactionDefinition.ISOLATION_SERIALIZABLE&lt;/code&gt;&lt;/strong&gt; : 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，&lt;strong&gt;该级别可以防止脏读、不可重复读以及幻读&lt;/strong&gt;。但是这将严重影响程序的性能。通常情况下也不会用到该级别。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;传播行为&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;TransactionDefinition.PROPAGATION_REQUIRED&lt;/code&gt;：默认的传播行为。如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。有就加入，没有就创建。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TransactionDefinition.PROPAGATION_REQUIRES_NEW&lt;/code&gt;：创建一个新的事务，如果当前存在事务，则把当前事务挂起。也就是说不管外部方法是否开启事务，&lt;code&gt;Propagation.REQUIRES_NEW&lt;/code&gt;修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TransactionDefinition.PROPAGATION_NESTED&lt;/code&gt;：如果当前存在事务，就在嵌套事务内执行；如果当前没有事务，就执行与&lt;code&gt;TransactionDefinition.PROPAGATION_REQUIRED&lt;/code&gt;类似的操作。也就是说：
&lt;ul&gt;
&lt;li&gt;在外部方法开启事务的情况下,在内部开启一个新的事务，作为嵌套事务存在。&lt;/li&gt;
&lt;li&gt;如果外部方法无事务，则单独开启一个事务，与 &lt;code&gt;PROPAGATION_REQUIRED&lt;/code&gt; 类似。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TransactionDefinition.PROPAGATION_MANDATORY&lt;/code&gt;：如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;若是错误的配置以下 3 种事务传播行为，事务将不会发生回滚，这里不对照案例讲解了，使用的很少。&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;TransactionDefinition.PROPAGATION_SUPPORTS&lt;/code&gt;&lt;/strong&gt;: 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;TransactionDefinition.PROPAGATION_NOT_SUPPORTED&lt;/code&gt;&lt;/strong&gt;: 以非事务方式运行，如果当前存在事务，则把当前事务挂起。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;TransactionDefinition.PROPAGATION_NEVER&lt;/code&gt;&lt;/strong&gt;: 以非事务方式运行，如果当前存在事务，则抛出异常。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;回滚规则&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;这些规则定义了哪些异常会导致事务回滚而哪些不会。默认情况下，事务只有遇到运行期异常（&lt;code&gt;RuntimeException&lt;/code&gt; 的子类）时才会回滚，&lt;code&gt;Error&lt;/code&gt; 也会导致事务回滚，但是，在遇到检查型（Checked）异常时不会回滚。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果你想要回滚你定义的特定的异常类型的话，可以这样：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nd&#34;&gt;@Transactional&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rollbackFor&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;MyException&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;class&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;是否只读&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;但是，如果你给方法加上了&lt;code&gt;Transactional&lt;/code&gt;注解的话，这个方法执行的所有&lt;code&gt;sql&lt;/code&gt;会被放在一个事务中。如果声明了只读事务的话，数据库就会去优化它的执行，并不会带来其他的什么收益。&lt;/li&gt;
&lt;li&gt;如果不加&lt;code&gt;Transactional&lt;/code&gt;，每条&lt;code&gt;sql&lt;/code&gt;会开启一个单独的事务，中间被其它事务改了数据，都会实时读取到最新值。&lt;/li&gt;
&lt;li&gt;如果你一次执行单条查询语句，则没有必要启用事务支持，数据库默认支持 SQL 执行期间的读一致性；&lt;/li&gt;
&lt;li&gt;如果你一次执行多条查询语句，例如统计查询，报表查询，在这种场景下，多条查询 SQL 必须保证整体的读一致性，否则，在前条 SQL 查询之后，后条 SQL 查询之前，数据被其他用户改变，则该次整体的统计查询将会出现读数据不一致的状态，此时，应该启用事务支持&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;事务超时&lt;/strong&gt;；所谓事务超时，就是指一个事务所允许执行的最长时间，如果超过该时间限制但事务还没有完成，则自动回滚事务。在 &lt;code&gt;TransactionDefinition&lt;/code&gt; 中以 int 的值来表示超时时间，其单位是秒，&lt;strong&gt;默认值为-1（不超时）&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;transactionstatus事务状态&#34;&gt;TransactionStatus:事务状态&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;TransactionStatus&lt;/code&gt;接口用来记录事务的状态 该接口定义了一组方法,用来获取或判断事务的相应状态信息。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;PlatformTransactionManager.getTransaction(…)&lt;/code&gt;方法返回一个 &lt;code&gt;TransactionStatus&lt;/code&gt; 对象。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;interface&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;TransactionStatus&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;boolean&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;isNewTransaction&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 是否是新的事务
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;boolean&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;hasSavepoint&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 是否有恢复点
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;setRollbackOnly&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// 设置为只回滚
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;boolean&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;isRollbackOnly&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 是否为只回滚
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;boolean&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;isCompleted&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 是否已完成
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;transactional-注解使用详解&#34;&gt;@Transactional 注解使用详解&lt;/h3&gt;
&lt;h4 id=&#34;transactional-的作用范围&#34;&gt;&lt;code&gt;@Transactional&lt;/code&gt; 的作用范围&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;方法&lt;/strong&gt; ：推荐将注解使用于方法上，不过需要注意的是：&lt;strong&gt;该注解只能应用到 public 方法上，否则不生效。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;类&lt;/strong&gt; ：如果这个注解使用在类上的话，表明该注解对该类中所有的 public 方法都生效。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;接口&lt;/strong&gt; ：不推荐在接口上使用。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;spring-框架中用到了哪些设计模式&#34;&gt;Spring 框架中用到了哪些设计模式？&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;工厂设计模式&lt;/strong&gt; : Spring使用工厂模式通过 &lt;code&gt;BeanFactory&lt;/code&gt;、&lt;code&gt;ApplicationContext&lt;/code&gt; 创建 bean 对象。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;代理设计模式&lt;/strong&gt; : Spring AOP 功能的实现。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;单例设计模式&lt;/strong&gt; : Spring 中的 Bean 默认都是单例的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;模板方法模式&lt;/strong&gt; : Spring 中 &lt;code&gt;jdbcTemplate&lt;/code&gt;、&lt;code&gt;hibernateTemplate&lt;/code&gt; 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;包装器设计模式&lt;/strong&gt; : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;观察者模式:&lt;/strong&gt; Spring 事件驱动模型就是观察者模式很经典的一个应用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;适配器模式&lt;/strong&gt; :Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配&lt;code&gt;Controller&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;mybatis-缓存&#34;&gt;Mybatis 缓存&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://tech.meituan.com/2018/01/19/mybatis-cache.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;聊聊MyBatis缓存机制 - 美团技术团队 (meituan.com)&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
