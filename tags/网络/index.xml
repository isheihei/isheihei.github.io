<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>网络 on isheihei&#39;s blog</title>
        <link>https://isheihei.github.io/tags/%E7%BD%91%E7%BB%9C/</link>
        <description>Recent content in 网络 on isheihei&#39;s blog</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <lastBuildDate>Tue, 26 Jul 2022 15:35:36 +0800</lastBuildDate><atom:link href="https://isheihei.github.io/tags/%E7%BD%91%E7%BB%9C/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Reactor模型</title>
        <link>https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/reactor%E6%A8%A1%E5%9E%8B/</link>
        <pubDate>Tue, 26 Jul 2022 15:35:36 +0800</pubDate>
        
        <guid>https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/reactor%E6%A8%A1%E5%9E%8B/</guid>
        <description>&lt;h2 id=&#34;io线程模型&#34;&gt;IO线程模型&lt;/h2&gt;
&lt;p&gt;目前的IO线程处理模型一般可以分为以下三类&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;单线程阻塞I/O服务模型：单线程处理Socket连接和I/O，只能同时处理一个Socket&lt;/li&gt;
&lt;li&gt;多线程阻塞IO服务模型：每建立一个Socket连接就分配一个线程&lt;/li&gt;
&lt;li&gt;Reactor模式：多个连接共用一个阻塞对象，应用程序只需要在一个阻塞对象等待，无需阻塞等待所有连接。当某个连接有新的数据可以处理时，操作系统通知应用程序，线程从阻塞状态返回，开始进行业务处理。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;根据Reactor的数量和处理资源池线程的数量不同，Reactor模式有如下3种典型的实现&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;单Reactor单线程&lt;/li&gt;
&lt;li&gt;单Reactor多线程&lt;/li&gt;
&lt;li&gt;主从Reactor多线程&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;reactor模型&#34;&gt;Reactor模型&lt;/h2&gt;
&lt;p&gt;Reactor模型中有三个角色&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Reactor 对象的作用是监听和分发事件；&lt;/li&gt;
&lt;li&gt;Acceptor 对象的作用是获取连接；&lt;/li&gt;
&lt;li&gt;Handler 对象的作用是处理业务；&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;单线程模型&#34;&gt;单线程模型&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/reactor%E6%A8%A1%E5%9E%8B/%E5%8D%95Reactor%E5%8D%95%E8%BF%9B%E7%A8%8B.png&#34;
	width=&#34;1427&#34;
	height=&#34;834&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/reactor%E6%A8%A1%E5%9E%8B/%E5%8D%95Reactor%E5%8D%95%E8%BF%9B%E7%A8%8B_hu2adaabf63dcb50b8ed74a14558eec4a4_97390_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/reactor%E6%A8%A1%E5%9E%8B/%E5%8D%95Reactor%E5%8D%95%E8%BF%9B%E7%A8%8B_hu2adaabf63dcb50b8ed74a14558eec4a4_97390_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;单Reactor单线程&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;171&#34;
		data-flex-basis=&#34;410px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;对象里的 select、accept、read、send 是系统调用函数，dispatch 和 「业务处理」是需要完成的操作，其中 dispatch 是分发事件操作。&lt;/p&gt;
&lt;p&gt;接下来，介绍下「单 Reactor 单线程」这个方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Reactor 对象通过 select （IO 多路复用接口） 监听事件，收到事件后通过 dispatch 进行分发，具体分发给 Acceptor 对象还是 Handler 对象，还要看收到的事件类型；&lt;/li&gt;
&lt;li&gt;如果是连接建立的事件，则交由 Acceptor 对象进行处理，Acceptor 对象会通过 accept 方法 获取连接，并创建一个 Handler 对象来处理后续的响应事件；&lt;/li&gt;
&lt;li&gt;如果不是连接建立事件， 则交由当前连接对应的 Handler 对象来进行响应；&lt;/li&gt;
&lt;li&gt;Handler 对象通过 read -&amp;gt; 业务处理 -&amp;gt; send 的流程来完成完整的业务流程。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;单 Reactor 单线程的方案因为全部工作都在同一个进程内完成，所以实现起来比较简单，不需要考虑进程间通信，也不用担心多进程竞争。&lt;/p&gt;
&lt;p&gt;但是，这种方案存在 2 个缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一个缺点，因为只有一个进程，&lt;strong&gt;无法充分利用 多核 CPU 的性能&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;第二个缺点，Handler 对象在业务处理时，整个进程是无法处理其他连接的事件的，&lt;strong&gt;如果业务处理耗时比较长，那么就造成响应的延迟&lt;/strong&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以，单 Reactor 单进程的方案&lt;strong&gt;不适用计算机密集型的场景，只适用于业务处理非常快速的场景&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;Redis 是由 C 语言实现的，在 Redis 6.0 版本之前采用的正是「单 Reactor 单进程」的方案，因为 Redis 业务处理主要是在内存中完成，操作的速度是很快的，性能瓶颈不在 CPU 上，所以 Redis 对于命令的处理是单进程的方案。&lt;/p&gt;
&lt;h3 id=&#34;多线程模型&#34;&gt;多线程模型&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/reactor%E6%A8%A1%E5%9E%8B/%E5%8D%95Reactor%E5%A4%9A%E7%BA%BF%E7%A8%8B.png&#34;
	width=&#34;1514&#34;
	height=&#34;1277&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/reactor%E6%A8%A1%E5%9E%8B/%E5%8D%95Reactor%E5%A4%9A%E7%BA%BF%E7%A8%8B_hu34f2950544104121fb0752855b411a5e_150874_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/reactor%E6%A8%A1%E5%9E%8B/%E5%8D%95Reactor%E5%A4%9A%E7%BA%BF%E7%A8%8B_hu34f2950544104121fb0752855b411a5e_150874_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;单Reactor多线程&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;118&#34;
		data-flex-basis=&#34;284px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Reactor 对象通过 select （IO 多路复用接口） 监听事件，收到事件后通过 dispatch 进行分发，具体分发给 Acceptor 对象还是 Handler 对象，还要看收到的事件类型；&lt;/li&gt;
&lt;li&gt;如果是连接建立的事件，则交由 Acceptor 对象进行处理，Acceptor 对象会通过 accept 方法 获取连接，并创建一个 Handler 对象来处理后续的响应事件；&lt;/li&gt;
&lt;li&gt;如果不是连接建立事件， 则交由当前连接对应的 Handler 对象来进行响应；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面的三个步骤和单 Reactor 单线程方案是一样的，接下来的步骤就开始不一样了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Handler 对象不再负责业务处理，只负责数据的接收和发送，Handler 对象通过 read 读取到数据后，会将数据发给子线程里的 Processor 对象进行业务处理；&lt;/li&gt;
&lt;li&gt;子线程里的 Processor 对象就进行业务处理，处理完后，将结果发给主线程中的 Handler 对象，接着由 Handler 通过 send 方法将响应结果发送给 client；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;单 Reator 多线程的方案优势在于&lt;strong&gt;能够充分利用多核 CPU 的能&lt;/strong&gt;，那既然引入多线程，那么自然就带来了多线程竞争资源的问题。&lt;/p&gt;
&lt;p&gt;例如，子线程完成业务处理后，要把结果传递给主线程的 Handler 进行发送，这里涉及共享数据的竞争。&lt;/p&gt;
&lt;p&gt;要避免多线程由于竞争共享资源而导致数据错乱的问题，就需要在操作共享资源前加上互斥锁，以保证任意时间里只有一个线程在操作共享资源，待该线程操作完释放互斥锁后，其他线程才有机会操作共享数据。&lt;/p&gt;
&lt;p&gt;另外，「单 Reactor」的模式还有个问题，&lt;strong&gt;因为一个 Reactor 对象承担所有事件的监听和响应，而且只在主线程中运行，在面对瞬间高并发的场景时，容易成为性能的瓶颈的地方&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;主从多线程模型&#34;&gt;主从多线程模型&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/reactor%E6%A8%A1%E5%9E%8B/%E4%B8%BB%E4%BB%8EReactor%E5%A4%9A%E7%BA%BF%E7%A8%8B.png&#34;
	width=&#34;1772&#34;
	height=&#34;1262&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/reactor%E6%A8%A1%E5%9E%8B/%E4%B8%BB%E4%BB%8EReactor%E5%A4%9A%E7%BA%BF%E7%A8%8B_huf6051e633e27963a6945683b5260f969_148611_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/reactor%E6%A8%A1%E5%9E%8B/%E4%B8%BB%E4%BB%8EReactor%E5%A4%9A%E7%BA%BF%E7%A8%8B_huf6051e633e27963a6945683b5260f969_148611_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;主从Reactor多线程&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;140&#34;
		data-flex-basis=&#34;336px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主线程中的 MainReactor 对象通过 select 监控连接建立事件，收到事件后通过 Acceptor 对象中的 accept 获取连接，将新的连接分配给某个子线程；&lt;/li&gt;
&lt;li&gt;子线程中的 SubReactor 对象将 MainReactor 对象分配的连接加入 select 继续进行监听，并创建一个 Handler 用于处理连接的响应事件。&lt;/li&gt;
&lt;li&gt;如果有新的事件发生时，SubReactor 对象会调用当前连接对应的 Handler 对象来进行响应。&lt;/li&gt;
&lt;li&gt;Handler 对象通过 read -&amp;gt; 业务处理 -&amp;gt; send 的流程来完成完整的业务流程。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;MainReactor 仅监听连接事件，一旦建立了连接就将该连接加入 SubReactor，监听读写事件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;netty-中的-reactor-模型&#34;&gt;Netty 中的 Reactor 模型&lt;/h2&gt;
&lt;h3 id=&#34;eventloopeventloopgroup-怎么实现reactor线程模型&#34;&gt;EventLoop、EventLoopGroup 怎么实现Reactor线程模型?&lt;/h3&gt;
&lt;p&gt;上面我们已经了解了Reactor线程模型，了解了它的核心就是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Reactor线程模式 = Reactor(I/O多路复用)+ 线程池&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;它的运行模式包括四个步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;连接注册：建立连接后，将channel注册到selector上&lt;/li&gt;
&lt;li&gt;事件轮询：selcetor上轮询(select()函数)获取已经注册的channel的所有I/O事件(多路复用)&lt;/li&gt;
&lt;li&gt;事件分发：把准备就绪的I/O事件分配到对应线程进行处理&lt;/li&gt;
&lt;li&gt;事件处理：每个worker线程执行事件任务&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那这样的模型在Netty中具体怎么实现呢?&lt;/p&gt;
&lt;p&gt;这就需要我们了解下EventLoop和EventLoopGroup了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Netty boss 线程池是处理 accept事件的，不管线程池多大，只会使用一个线程，既然只使用一个线程为什么要用线程池呢？主要是异常的情况下，线程die了，可以再创建一个新线程，那什么情况下boss线程池可以使用多个线程呢？那就是当ServerBootstrap bind多个端口时。每个端口都有一个线程eventloop accept事件。&lt;/p&gt;
&lt;p&gt;作者：Rocky
链接：https://www.zhihu.com/question/284788403/answer/1670777098
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;1连接注册&#34;&gt;1)连接注册&lt;/h4&gt;
&lt;p&gt;Boss EventLoopGroup中有一个EventLoop，绑定某个特定端口进行监听。&lt;/p&gt;
&lt;p&gt;一旦有新的连接进来触发accept类型事件，就会在当前EventLoop的I/O事件处理阶段，将这个连接分配给Worker EventLoopGroup中的某一个EventLoop，进行后续 事件的监听。&lt;/p&gt;
&lt;h4 id=&#34;2事件轮询&#34;&gt;2)事件轮询&lt;/h4&gt;
&lt;p&gt;Worker EventLoopGroup中的EventLoop，会通过selcetor对绑定到自身的channel进行轮询，获取已经注册的channel的所有I/O事件(多路复用)。&lt;/p&gt;
&lt;p&gt;当然，EventLoopGroup中会有 多个EventLoop 运行，各自循环处理。具体EventLoop数量是由 用户指定的线程数 或者 默认为核数的2倍。&lt;/p&gt;
&lt;h4 id=&#34;3事件分发&#34;&gt;3)事件分发&lt;/h4&gt;
&lt;p&gt;当Worker EventLoopGroup中的EventLoop获取到I/O事件后，会在EventLoop的 I/O事件处理(processSelectedKeys) 阶段分发给对应ChannelPipeline进行处理。&lt;/p&gt;
&lt;p&gt;注意，仍然在当前线程进行串行处理&lt;/p&gt;
&lt;h4 id=&#34;4事件处理&#34;&gt;4)事件处理&lt;/h4&gt;
&lt;p&gt;在ChannelPipeline中对I/O事件进行处理。&lt;/p&gt;
&lt;p&gt;I/O事件处理完后，EventLoop在 任务处理(runAllTasks) 阶段，对队列中的任务进行消费处理。&lt;/p&gt;
&lt;p&gt;至此，我们就能完全梳理清楚EventLoopGroup/EventLoop 和 Reactor线程模型的关系了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Boss EventLoopGroup 对应 Reactor 中的 MainReactor，Worker EventLoopGroup 对应 Reactor模型 中的 handler组。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;netty是哪种reactor模型&#34;&gt;Netty是哪种Reactor模型？&lt;/h3&gt;
&lt;p&gt;Netty可以通过简单配置，支持单Reactor单线程模型 、单Reactor多线程模型 、多Reactor多线程模型。&lt;/p&gt;
&lt;h4 id=&#34;单reactor单线程模型&#34;&gt;单Reactor单线程模型&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;new ServerBootstrap()
.group(new NioEventLoopGroup(1))&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;单reactor多线程模型&#34;&gt;单Reactor多线程模型&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;new ServerBootstrap()
.group(new NioEventLoopGroup(1), new NioEventLoopGroup(4))&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;多reactor多线程模型&#34;&gt;多Reactor多线程模型&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;new ServerBootstrap()
.group(new NioEventLoopGroup(4), new NioEventLoopGroup(4))&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        </item>
        <item>
        <title>零拷贝</title>
        <link>https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E9%9B%B6%E6%8B%B7%E8%B4%9D/</link>
        <pubDate>Tue, 26 Jul 2022 10:59:34 +0800</pubDate>
        
        <guid>https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E9%9B%B6%E6%8B%B7%E8%B4%9D/</guid>
        <description>&lt;h2 id=&#34;太长不看系列read--write-一个文件&#34;&gt;太长不看系列：read() &amp;amp; write() 一个文件&lt;/h2&gt;
&lt;h3 id=&#34;没有-dma-技术之前&#34;&gt;没有 DMA 技术之前&lt;/h3&gt;
&lt;p&gt;四次内核态和用户态切换，四次拷贝，且两次拷贝都需要CPU参与&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E9%9B%B6%E6%8B%B7%E8%B4%9D/IO%E4%B8%AD%E6%96%AD.png&#34;
	width=&#34;1337&#34;
	height=&#34;785&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E9%9B%B6%E6%8B%B7%E8%B4%9D/IO%E4%B8%AD%E6%96%AD_hu2a490217fb86f0f2a5249dcee421d1b9_119603_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E9%9B%B6%E6%8B%B7%E8%B4%9D/IO%E4%B8%AD%E6%96%AD_hu2a490217fb86f0f2a5249dcee421d1b9_119603_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;没有DMA技术&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;170&#34;
		data-flex-basis=&#34;408px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;有了dma技术&#34;&gt;有了DMA技术&lt;/h3&gt;
&lt;p&gt;DMA可以控制磁盘到内核缓冲区，所以 CPU 减少了一定的工作量&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E9%9B%B6%E6%8B%B7%E8%B4%9D/%E4%BC%A0%E7%BB%9F%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93.png&#34;
	width=&#34;1100&#34;
	height=&#34;678&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E9%9B%B6%E6%8B%B7%E8%B4%9D/%E4%BC%A0%E7%BB%9F%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93_hua8e3266497881f7d0083c0379c6a4097_87556_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E9%9B%B6%E6%8B%B7%E8%B4%9D/%E4%BC%A0%E7%BB%9F%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93_hua8e3266497881f7d0083c0379c6a4097_87556_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;DMA技术&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;162&#34;
		data-flex-basis=&#34;389px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;零拷贝技术之-mmap&#34;&gt;零拷贝技术之 mmap()&lt;/h3&gt;
&lt;p&gt;mmap() 可以把内核缓冲区数据映射到用户态，所以不再需要内核态和用户态之间拷贝，但是需要在内核的缓冲区和 socket 缓冲区进行拷贝，所以共需要三次拷贝（磁盘 &amp;lt;-&amp;gt; 内核两次、内核PageCache&amp;lt;-&amp;gt; 内核socket缓冲区一次）以及两次系统调用（内核态和用户态四次转换）&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E9%9B%B6%E6%8B%B7%E8%B4%9D/mmap_write.png&#34;
	width=&#34;1100&#34;
	height=&#34;677&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E9%9B%B6%E6%8B%B7%E8%B4%9D/mmap_write_hu991a0cc7cc633bcddc064c5febd47237_90307_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E9%9B%B6%E6%8B%B7%E8%B4%9D/mmap_write_hu991a0cc7cc633bcddc064c5febd47237_90307_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;mmap()&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;162&#34;
		data-flex-basis=&#34;389px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;零拷贝技术之-sendfile&#34;&gt;零拷贝技术之 sendfile()&lt;/h3&gt;
&lt;p&gt;sendfile 可以直接发起一次系统调用进行文件发送，如果网卡支持 SG-DMA（&lt;em&gt;The Scatter-Gather Direct Memory Access&lt;/em&gt;）技术，可以直接从内核PageCache 拷贝到网卡，又减少了一次拷贝。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E9%9B%B6%E6%8B%B7%E8%B4%9D/senfile-3%E6%AC%A1%E6%8B%B7%E8%B4%9D.png&#34;
	width=&#34;1100&#34;
	height=&#34;686&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E9%9B%B6%E6%8B%B7%E8%B4%9D/senfile-3%E6%AC%A1%E6%8B%B7%E8%B4%9D_hu4ccaf8580c03c11a45c20f231e5a5ac8_119322_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E9%9B%B6%E6%8B%B7%E8%B4%9D/senfile-3%E6%AC%A1%E6%8B%B7%E8%B4%9D_hu4ccaf8580c03c11a45c20f231e5a5ac8_119322_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;sendfile无SG-DMA&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;160&#34;
		data-flex-basis=&#34;384px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E9%9B%B6%E6%8B%B7%E8%B4%9D/senfile-%E9%9B%B6%E6%8B%B7%E8%B4%9D.png&#34;
	width=&#34;1160&#34;
	height=&#34;686&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E9%9B%B6%E6%8B%B7%E8%B4%9D/senfile-%E9%9B%B6%E6%8B%B7%E8%B4%9D_hu57149e7fc7cae253fd2388b347179840_126338_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E9%9B%B6%E6%8B%B7%E8%B4%9D/senfile-%E9%9B%B6%E6%8B%B7%E8%B4%9D_hu57149e7fc7cae253fd2388b347179840_126338_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;sendfile有SG-DMA&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;169&#34;
		data-flex-basis=&#34;405px&#34;
	
&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;技术&lt;/th&gt;
&lt;th&gt;系统调用次数&lt;/th&gt;
&lt;th&gt;内核态与用户态切换次数&lt;/th&gt;
&lt;th&gt;数据拷贝次数&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;没有DMA技术之前&lt;/td&gt;
&lt;td&gt;两次&lt;/td&gt;
&lt;td&gt;四次&lt;/td&gt;
&lt;td&gt;四次（都需要CPU）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DMA技术&lt;/td&gt;
&lt;td&gt;两次&lt;/td&gt;
&lt;td&gt;四次&lt;/td&gt;
&lt;td&gt;四次（两次CPU拷贝、两次DMA拷贝）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;mmap()&lt;/td&gt;
&lt;td&gt;两次&lt;/td&gt;
&lt;td&gt;四次&lt;/td&gt;
&lt;td&gt;三次（两次DMA拷贝、一次CPU拷贝）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;sendfile（）：无SG-DMA&lt;/td&gt;
&lt;td&gt;一次&lt;/td&gt;
&lt;td&gt;两次&lt;/td&gt;
&lt;td&gt;三次（两次DMA拷贝、一次CPU拷贝）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;sendfile（）：有SG-DMA&lt;/td&gt;
&lt;td&gt;一次&lt;/td&gt;
&lt;td&gt;两次&lt;/td&gt;
&lt;td&gt;两次（一次DMA拷贝、一次SG-DMA拷贝）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;pagecache&#34;&gt;PageCache&lt;/h2&gt;
&lt;p&gt;回顾前面说道文件传输过程，其中第一步都是先需要先把磁盘文件数据拷贝「内核缓冲区」里，这个「内核缓冲区」实际上是&lt;strong&gt;磁盘高速缓存（&lt;em&gt;PageCache&lt;/em&gt;）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我们都知道程序运行的时候，具有「局部性」，所以通常，刚被访问的数据在短时间内再次被访问的概率很高，于是我们可以用 &lt;strong&gt;PageCache 来缓存最近被访问的数据&lt;/strong&gt;，当空间不足时淘汰最久未被访问的缓存。&lt;/p&gt;
&lt;p&gt;还有一点，读取磁盘数据的时候，需要找到数据所在的位置，但是对于机械磁盘来说，就是通过磁头旋转到数据所在的扇区，再开始「顺序」读取数据，但是旋转磁头这个物理动作是非常耗时的，为了降低它的影响，&lt;strong&gt;PageCache 使用了「预读功能」&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;比如，假设 read 方法每次只会读 &lt;code&gt;32 KB&lt;/code&gt; 的字节，虽然 read 刚开始只会读 0 ～ 32 KB 的字节，但内核会把其后面的 32～64 KB 也读取到 PageCache，这样后面读取 32～64 KB 的成本就很低，如果在 32～64 KB 淘汰出 PageCache 前，进程读取到它了，收益就非常大。&lt;/p&gt;
&lt;p&gt;所以，PageCache 的优点主要是两个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;缓存最近被访问的数据；&lt;/li&gt;
&lt;li&gt;预读功能；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这两个做法，将大大提高读写磁盘的性能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;但是，在传输大文件（GB 级别的文件）的时候，PageCache 会不起作用，那就白白浪费 DMA 多做的一次数据拷贝，造成性能的降低，即使使用了 PageCache 的零拷贝也会损失性能&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是因为如果你有很多 GB 级别文件需要传输，每当用户访问这些大文件的时候，内核就会把它们载入 PageCache 中，于是 PageCache 空间很快被这些大文件占满。&lt;/p&gt;
&lt;p&gt;另外，由于文件太大，可能某些部分的文件数据被再次访问的概率比较低，这样就会带来 2 个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PageCache 由于长时间被大文件占据，其他「热点」的小文件可能就无法充分使用到 PageCache，于是这样磁盘读写的性能就会下降了；&lt;/li&gt;
&lt;li&gt;PageCache 中的大文件数据，由于没有享受到缓存带来的好处，但却耗费 DMA 多拷贝到 PageCache 一次；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以，针对大文件的传输，不应该使用 PageCache，也就是说不应该使用零拷贝技术，因为可能由于 PageCache 被大文件占据，而导致「热点」小文件无法利用到 PageCache，这样在高并发的环境下，会带来严重的性能问题。&lt;/p&gt;
&lt;h2 id=&#34;大文件传输方式异步io--直接io&#34;&gt;大文件传输方式（异步I/O + 直接I/O）&lt;/h2&gt;
&lt;h3 id=&#34;异步io&#34;&gt;异步I/O&lt;/h3&gt;
&lt;p&gt;![异步I/O](异步 IO 的过程.png)&lt;/p&gt;
&lt;p&gt;它把读操作分为两部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前半部分，内核向磁盘发起读请求，但是可以&lt;strong&gt;不等待数据就位就可以返回&lt;/strong&gt;，于是进程此时可以处理其他任务；&lt;/li&gt;
&lt;li&gt;后半部分，当内核将磁盘中的数据拷贝到进程缓冲区后，进程将接收到内核的&lt;strong&gt;通知&lt;/strong&gt;，再去处理数据；&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;直接io&#34;&gt;直接I/O&lt;/h3&gt;
&lt;p&gt;而且，我们可以发现，异步 I/O 并没有涉及到 PageCache，所以使用异步 I/O 就意味着要绕开 PageCache。&lt;/p&gt;
&lt;p&gt;绕开 PageCache 的 I/O 叫直接 I/O，使用 PageCache 的 I/O 则叫缓存 I/O。通常，对于磁盘，异步 I/O 只支持直接 I/O。&lt;/p&gt;
&lt;p&gt;前面也提到，大文件的传输不应该使用 PageCache，因为可能由于 PageCache 被大文件占据，而导致「热点」小文件无法利用到 PageCache。&lt;/p&gt;
&lt;p&gt;于是，&lt;strong&gt;在高并发的场景下，针对大文件的传输的方式，应该使用「异步 I/O + 直接 I/O」来替代零拷贝技术&lt;/strong&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;参考：&lt;a class=&#34;link&#34; href=&#34;https://xiaolincoding.com/os/8_network_system/zero_copy.html#_9-1-%e4%bb%80%e4%b9%88%e6%98%af%e9%9b%b6%e6%8b%b7%e8%b4%9d&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;9.1 什么是零拷贝？ | 小林coding (xiaolincoding.com)&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>网络01-HTTP协议</title>
        <link>https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C01-http%E5%8D%8F%E8%AE%AE/</link>
        <pubDate>Mon, 18 Jul 2022 15:15:33 +0800</pubDate>
        
        <guid>https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C01-http%E5%8D%8F%E8%AE%AE/</guid>
        <description>&lt;h2 id=&#34;状态码&#34;&gt;状态码&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C01-http%E5%8D%8F%E8%AE%AE/HTTP%E7%8A%B6%E6%80%81%E7%A0%81.png&#34;
	width=&#34;913&#34;
	height=&#34;456&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C01-http%E5%8D%8F%E8%AE%AE/HTTP%E7%8A%B6%E6%80%81%E7%A0%81_hue8d9df02a05fa4118ed1a59593f7ba78_201118_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C01-http%E5%8D%8F%E8%AE%AE/HTTP%E7%8A%B6%E6%80%81%E7%A0%81_hue8d9df02a05fa4118ed1a59593f7ba78_201118_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;HTTP状态码&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;200&#34;
		data-flex-basis=&#34;480px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;1xx&#34;&gt;1xx&lt;/h3&gt;
&lt;p&gt;1xx 类状态码属于提示信息，是协议处理中的⼀种中间状态，实际用到的比较少。&lt;/p&gt;
&lt;h3 id=&#34;2xx&#34;&gt;2xx&lt;/h3&gt;
&lt;p&gt;2xx 类状态码表示服务器成功处理了客户端的请求，也是我们最愿意看到的状态。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;200 OK：是最常见的成功状态码，表示⼀切正常。如果是非 HEAD 请求，服务器返回的响应头都会有 body数据。&lt;/li&gt;
&lt;li&gt;204 No Content：也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。&lt;/li&gt;
&lt;li&gt;206 Partial Content：是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，⽽是其中的⼀部分，也是服务器处理成功的状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3xx&#34;&gt;3xx&lt;/h3&gt;
&lt;p&gt;3xx 类状态码表示客户端请求的资源发送了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是重定向。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;301 Moved Permanently：表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。&lt;/li&gt;
&lt;li&gt;302 Found：表示临时重定向，说明请求的资源还在，但暂时需要用另⼀个 URL 来访问。301 和 302 都会在响应头里使用字段 Location ，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。&lt;/li&gt;
&lt;li&gt;304 Not Modified：不具有跳转的含义，表示资源未修改，重定向已存在的缓冲⽂件，也称缓存重定向，用于缓存控制。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;4xx&#34;&gt;4xx&lt;/h3&gt;
&lt;p&gt;4xx 类状态码表示客户端发送的报⽂有误，服务器无法处理，也就是错误码的含义。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;400 Bad Request：表示客户端请求的报⽂有错误，但只是个笼统的错误。&lt;/li&gt;
&lt;li&gt;403 Forbidden：表示服务器禁止访问资源，并不是客户端的请求出错。&lt;/li&gt;
&lt;li&gt;404 Not Found：表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;5xx&#34;&gt;5xx&lt;/h3&gt;
&lt;p&gt;5xx 类状态码表示客户端请求报⽂正确，但是服务器处理时内部发生了错误，属于服务器端的错误码。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;500 Internal Server Error：与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。&lt;/li&gt;
&lt;li&gt;501 Not Implemented：表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。&lt;/li&gt;
&lt;li&gt;502 Bad Gateway：通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。&lt;/li&gt;
&lt;li&gt;503 Service Unavailable：表示服务器当前很忙，暂时无法响应服务器，类似“网络服务正忙，请稍后重试”的意思。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;http常见字段&#34;&gt;HTTP常见字段&lt;/h2&gt;
&lt;p&gt;Host：客户端发送请求时，用来指定服务器的域名&lt;/p&gt;
&lt;p&gt;Content-Length：服务器在返回数据时，表明本次回应的数据长度。&lt;/p&gt;
&lt;p&gt;Connection：Connection 字段最常用于客户端要求服务器使用 TCP 持久连接，以便其他请求复用。HTTP/1.1 版本的默认连接都是持久连接，但为了兼容老版本的 HTTP，需要指定 Connection 首部字段的值为Keep-Alive 。⼀个可以复用的 TCP 连接就建⽴了，直到客户端或服务器主动关闭连接。但是，这不是标准字段&lt;/p&gt;
&lt;p&gt;Content-Type：用于服务器回应时，告诉客户端，本次数据是什么格式。&lt;/p&gt;
&lt;p&gt;Content-Encoding：说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式；客户端在请求时，用 Accept-Encoding 字段说明自⼰可以接受哪些压缩方法。&lt;/p&gt;
&lt;h2 id=&#34;get-与-post&#34;&gt;GET 与 POST&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;GET 是安全且幂等的，因为他是只读操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。&lt;/li&gt;
&lt;li&gt;POST 因为是新增或提交数据的操作，会修改服务器上的资源，所以是不安全的，且多次提交就会创建多个资源，所以不是幂等的&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;http-与-https&#34;&gt;HTTP 与 HTTPS&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;HTTP 是超⽂本传输协议，信息是明文传输，存在安全⻛险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。&lt;/li&gt;
&lt;li&gt;HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报⽂传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。&lt;/li&gt;
&lt;li&gt;HTTP 的端口号是 80，HTTPS 的端口号是 443。&lt;/li&gt;
&lt;li&gt;HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;消息摘要消息认证码与数字签名的区别&#34;&gt;消息摘要、消息认证码与数字签名的区别&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.51cto.com/u_3078781/3292004&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;加解密算法+消息摘要+消息认证技术+数字签名+公钥证书_&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;ssltls握手&#34;&gt;SSL/TLS握手&lt;/h2&gt;
&lt;p&gt;SSL/TLS 协议建⽴的详细流程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;ClientHello：首先，由客户端向服务器发起加密通信请求，也就是 ClientHello 请求。在这⼀步，客户端主要向服务器发送以下信息：
&lt;ul&gt;
&lt;li&gt;客户端支持的 SSL/TLS 协议版本，如 TLS 1.2 版本。&lt;/li&gt;
&lt;li&gt;客户端生产的随机数（ Client Random ），后面用于生产「会话秘钥」。&lt;/li&gt;
&lt;li&gt;客户端⽀持的密码套件列表，如 RSA 加密算法。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;SeverHello：服务器收到客户端请求后，向客户端发出响应，也就是 SeverHello 。服务器回应的内容有如下内容：
&lt;ul&gt;
&lt;li&gt;确认 SSL/ TLS 协议版本，如果浏览器不支持，则关闭加密通信。&lt;/li&gt;
&lt;li&gt;服务器生产的随机数（ Server Random ），后面用于生产「会话秘钥」。&lt;/li&gt;
&lt;li&gt;确认的密码套件列表，如 RSA 加密算法。&lt;/li&gt;
&lt;li&gt;服务器的数字证书。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;客户端回应：客户端收到服务器的回应之后，首先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。如果证书没有问题，客户端会从数字证书中取出服务器的公钥，然后使用它加密报文，向服务器发送如下信息：
&lt;ul&gt;
&lt;li&gt;⼀个随机数（ pre-master key ）。该随机数会被服务器公钥加密。&lt;/li&gt;
&lt;li&gt;加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。&lt;/li&gt;
&lt;li&gt;客户端握手结束通知，表示客户端的握手阶段已经结束。这⼀项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。上面第⼀项的随机数是整个握手阶段的第三个随机数，这样服务器和客户端就同时有三个随机数，接着就用双方协商的加密算法，各自生成本次通信的「会话秘钥」。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;服务器的最后回应：服务器收到客户端的第三个随机数（ pre-master key ）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。然后，向客户端发出最后的信息：
&lt;ul&gt;
&lt;li&gt;加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。&lt;/li&gt;
&lt;li&gt;服务器握手结束通知，表示服务器的握手阶段已经结束。这⼀项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。&lt;/li&gt;
&lt;li&gt;至此，整个 SSL/TLS 的握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的 HTTP协议，只不过用「会话秘钥」加密内容。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C01-http%E5%8D%8F%E8%AE%AE/image-20220718225002147.png&#34;
	width=&#34;1545&#34;
	height=&#34;2807&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C01-http%E5%8D%8F%E8%AE%AE/image-20220718225002147_hu51dd03d806d8dfdbf68b6d43e682b388_1055339_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C01-http%E5%8D%8F%E8%AE%AE/image-20220718225002147_hu51dd03d806d8dfdbf68b6d43e682b388_1055339_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;SSL/TSL握手&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;55&#34;
		data-flex-basis=&#34;132px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;http10http11http2http3演变&#34;&gt;HTTP/1.0、HTTP/1.1、HTTP/2、HTTP/3演变&lt;/h2&gt;
&lt;h3 id=&#34;http11-相比-http10-的改进&#34;&gt;HTTP/1.1 相比 HTTP/1.0 的改进&lt;/h3&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://javaguide.cn/cs-basics/network/http1.0&amp;amp;http1.1.html#%e5%93%8d%e5%ba%94%e7%8a%b6%e6%80%81%e7%a0%81&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;HTTP 1.0 vs HTTP 1.1（应用层） | JavaGuide&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;连接方式&lt;/strong&gt; : HTTP 1.0 为短连接，HTTP 1.1 支持长连接。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;状态响应码&lt;/strong&gt; : HTTP/1.1中新加入了大量的状态码，光是错误响应状态码就新增了24种。比如说，&lt;code&gt;100 (Continue)&lt;/code&gt;——在请求大资源前的预热请求，&lt;code&gt;206 (Partial Content)&lt;/code&gt;——范围请求的标识码，&lt;code&gt;409 (Conflict)&lt;/code&gt;——请求与当前资源的规定冲突，&lt;code&gt;410 (Gone)&lt;/code&gt;——资源已被永久转移，而且没有任何已知的转发地址。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;缓存处理&lt;/strong&gt; : 在 HTTP1.0 中主要使用 header 里的 If-Modified-Since,Expires 来做为缓存判断的标准，HTTP1.1 则引入了更多的缓存控制策略例如 Entity tag，If-Unmodified-Since, If-Match, If-None-Match 等更多可供选择的缓存头来控制缓存策略。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;带宽优化及网络连接的使用&lt;/strong&gt; :HTTP1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Host头处理&lt;/strong&gt; : HTTP/1.1在请求头中加入了&lt;code&gt;Host&lt;/code&gt;字段。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用TCP 长连接的方式改善了 HTTP/1.0  短链接造成的性能开销&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;支持管道网络传输，只要第一个请求发出去了，不必等期回来，就可以发第二个请求出去，可以减少整体的响应时间&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;http2-针对-http11-优化&#34;&gt;HTTP/2 针对 HTTP/1.1 优化&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;头部压缩，如果同时发出多个请求，他们的头是一样的或是相似的，那么下一会帮你消除重复部分。这就是 &lt;code&gt;HPACK&lt;/code&gt; 算法：客户端和服务端同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后不发送同样字段了，只发送索引号，这样就提高速度。&lt;/li&gt;
&lt;li&gt;HTTP/2 不再像 HTTP/1.1 里的纯文本形式的报文，而是全面采用了二进制格式，头和数据体都是二进制。收到报文后无需再将铭文的报文转成二进制，而是直接解析二进制报文，这增加了数据传输的效率。&lt;/li&gt;
&lt;li&gt;数据流：&lt;strong&gt;HTTP/2 的数据包不是按顺序发送的，同⼀个连接里面连续的数据包，可能属于不同的回应&lt;/strong&gt;。因此，必须要对数据包做标记，指出它属于哪个回应。每个请求或回应的所有数据包，称为⼀个数据流（ Stream ）。每个数据流都标记着⼀个独一无二的编号，其中规定客户端发出的数据流编号为奇数， 服务器发出的数据流编号为偶数。&lt;/li&gt;
&lt;li&gt;多路复用：HTTP/2 是可以在⼀个连接中并发多个请求或回应，而不用按照顺序⼀⼀对应。移除了 HTTP/1.1 中的串行请求，不需要排队等待，也就不会再出现「队头阻塞」问题，降低了延迟，⼤幅度提高了连接的利⽤率。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;http3&#34;&gt;HTTP/3&lt;/h3&gt;
&lt;p&gt;HTTP/2 主要的问题在于，多个 HTTP 请求在复⽤⼀个 TCP 连接，下层的 TCP 协议是不知道有多少个 HTTP 请求的。所以⼀旦发生了丢包现象，就会触发 TCP 的重传机制，这样在⼀个 TCP 连接中的所有的 HTTP 请求都必须等待这个丢了的包被重传回来。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HTTP/1.1 中的管道（ pipeline）传输中如果有⼀个请求阻塞了，那么队列后请求也统统被阻塞住了&lt;/li&gt;
&lt;li&gt;HTTP/2 多个请求复用⼀个TCP连接，⼀旦发生丢包，就会阻塞住所有的 HTTP 请求。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这都是基于 TCP 传输层的问题，所以 HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP！&lt;/p&gt;
&lt;p&gt;UDP 是不可靠传输的，但基于 UDP 的 QUIC 协议 可以实现类似 TCP 的可靠性传输。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;QUIC 有自己的⼀套机制可以保证传输的可靠性的。当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响。&lt;/li&gt;
&lt;li&gt;TLS3 升级成了最新的 1.3 版本，头部压缩算法也升级成了 QPack 。&lt;/li&gt;
&lt;li&gt;HTTPS 要建⽴⼀个连接，要花费 6 次交互，先是建⽴三次握⼿，然后是 TLS/1.3 的三次握⼿。QUIC 直接把以往的 TCP 和 TLS/1.3 的 6 次交互合并成了 3 次，减少了交互次数。&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>网络02-TCP协议</title>
        <link>https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/</link>
        <pubDate>Mon, 18 Jul 2022 00:04:43 +0800</pubDate>
        
        <guid>https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/</guid>
        <description>&lt;h2 id=&#34;什么是tcp&#34;&gt;什么是TCP&lt;/h2&gt;
&lt;p&gt;IP 层是「不可靠」的，它不保证网络包的交付、不保证网络包的按序交付、也不保证网络包中的数据的完整性。&lt;/p&gt;
&lt;p&gt;如果需要保障网络数据包的可靠性，那么就需要由上层（传输层）的 TCP 协议来负责。因为 TCP 是⼀个⼯作在传输层的可靠数据传输的服务，它能确保接收端接收的网络包是无损坏、无间隔、非冗余和按序的。&lt;/p&gt;
&lt;p&gt;TCP 是面向连接的、可靠的、基于字节流的传输层通信协议。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;面向连接：⼀定是「⼀对⼀」才能连接，不能像 UDP 协议可以⼀个主机同时向多个主机发送消息，也就是⼀对多是无法做到的；&lt;/li&gt;
&lt;li&gt;可靠的：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证⼀个报文⼀定能够到达接收端；&lt;/li&gt;
&lt;li&gt;字节流：消息是「没有边界」的，所以无论我们消息有多大都可以进行传输。并且消息是「有序的」，当「前⼀个」消息没有收到的时候，即使它先收到了后面的字节，那么也不能扔给应用层去处理，同时对「重复」的报文会⾃动丢弃。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;TCP 四元组可以唯⼀的确定⼀个连接，四元组包括如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;源地址&lt;/li&gt;
&lt;li&gt;源端口&lt;/li&gt;
&lt;li&gt;目的地址&lt;/li&gt;
&lt;li&gt;目的端口&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718202454871.png&#34;
	width=&#34;821&#34;
	height=&#34;228&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718202454871_hu5382c26f3f67254d930af289186624bc_24142_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718202454871_hu5382c26f3f67254d930af289186624bc_24142_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;TCP四元组&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;360&#34;
		data-flex-basis=&#34;864px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;源地址和目的地址的字段（32位）是在 &lt;strong&gt;IP 头部&lt;/strong&gt; 中，作用是通过 IP 协议发送报文给对方主机。&lt;/p&gt;
&lt;p&gt;源端口和目的端口的字段（16位）是在 &lt;strong&gt;TCP 头部&lt;/strong&gt; 中，作用是告诉 TCP 协议应该把报文发给哪个进程。&lt;/p&gt;
&lt;h2 id=&#34;什么是tcp连接&#34;&gt;什么是TCP连接&lt;/h2&gt;
&lt;p&gt;简单来说就是，用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括Socket、序列号和窗口大小称为连接。&lt;/p&gt;
&lt;p&gt;所以我们可以知道，建⽴⼀个 TCP 连接是需要客户端与服务器端达成上述三个信息的共识。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Socket：由 IP 地址和端口号组成&lt;/li&gt;
&lt;li&gt;序列号：用来解决乱序问题等&lt;/li&gt;
&lt;li&gt;窗口大小：用来做流量控制&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;tcp-格式&#34;&gt;TCP 格式&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718201052747.png&#34;
	width=&#34;1053&#34;
	height=&#34;828&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718201052747_hu143c1bfee3267be99575a2a0ea300bb4_85927_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718201052747_hu143c1bfee3267be99575a2a0ea300bb4_85927_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;TCP头部格式&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;127&#34;
		data-flex-basis=&#34;305px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;序列号：在建⽴连接时由计算机生成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送⼀次数据，就「累加」⼀次该「数据字节数」的大小。用来解决网络包乱序问题。&lt;/p&gt;
&lt;p&gt;确认应答号：指下⼀次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。用来解决不丢包的问题。&lt;/p&gt;
&lt;p&gt;控制位：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ACK：该位为 1 时，「确认应答」的字段变为有效，TCP 规定除了最初建⽴连接时的 SYN 包之外该位必须设置为 1 。&lt;/li&gt;
&lt;li&gt;RST：该位为 1 时，表示 TCP 连接中出现异常必须强制断开连接。&lt;/li&gt;
&lt;li&gt;SYN：该位为 1 时，表示希望建⽴连接，并在其「序列号」的字段进行序列号初始值的设定。&lt;/li&gt;
&lt;li&gt;FIN：该位为 1 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 FIN 位为 1 的 TCP 段。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;tcp-和-udp-区别&#34;&gt;TCP 和 UDP 区别&lt;/h2&gt;
&lt;p&gt;UDP 不提供复杂的控制机制，利用 IP 提供面向「无连接」的通信服务。UDP 协议真的非常简，头部只有 8 个字节（ 64 位），UDP 的头部格式如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718203033417.png&#34;
	width=&#34;783&#34;
	height=&#34;468&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718203033417_hub871f519644e7be8a66c647c49d6b24b_35126_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718203033417_hub871f519644e7be8a66c647c49d6b24b_35126_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;UDP头部&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;167&#34;
		data-flex-basis=&#34;401px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;目标和源端口：主要是告诉 UDP 协议应该把报文发给哪个进程。&lt;/li&gt;
&lt;li&gt;包长度：该字段保存了 UDP 首部的长度跟数据的长度之和。&lt;/li&gt;
&lt;li&gt;校验和：校验和是为了提供可靠的 UDP 首部和数据而设计。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;区别&#34;&gt;区别&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;连接：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TCP 是面向连接的传输层协议，传输数据前先要建⽴连接。&lt;/li&gt;
&lt;li&gt;UDP 是不需要连接，即刻传输数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;服务对象&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TCP 是⼀对⼀的两点服务，即⼀条连接只有两个端点。&lt;/li&gt;
&lt;li&gt;UDP ⽀持⼀对⼀、⼀对多、多对多的交互通信&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可靠性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按需到达。&lt;/li&gt;
&lt;li&gt;UDP 是尽最大努⼒交付，不保证可靠交付数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;拥塞控制、流量控制&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。&lt;/li&gt;
&lt;li&gt;UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;首部开销&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TCP 首部长度较长，会有⼀定的开销，首部在没有使用「选项」字段时是 20 个字节，如果使用了「选项」字段则会变长的。&lt;/li&gt;
&lt;li&gt;UDP 首部只有 8 个字节，并且是固定不变的，开销较小。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;传输方式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TCP 是流式传输，没有边界，但保证顺序和可靠。&lt;/li&gt;
&lt;li&gt;UDP 是⼀个包⼀个包的发送，是有边界的，但可能会丢包和乱序。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分片不同&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP数据包，如果中途丢失了⼀个分片，只需要传输丢失的这个分片。&lt;/li&gt;
&lt;li&gt;UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层，但是如果中途丢了⼀个分片，在实现可靠传输的 UDP 时则就需要重传所有的数据包，这样传输效率非常差，所以通常 UDP 的报文应该小于 MTU。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;tcp-和-udp-应用场景&#34;&gt;TCP 和 UDP 应用场景：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;FTP 文件传输&lt;/li&gt;
&lt;li&gt;HTTP / HTTPS&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于 UDP 面向无连接，它可以随时发送数据，再加上UDP本身的处理既简单又高效，因此经常用于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;包总量较少的通信，如 DNS 、 SNMP 等&lt;/li&gt;
&lt;li&gt;视频、音频等多媒体通信&lt;/li&gt;
&lt;li&gt;广播通信&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为什么 UDP 头部没有「首部长度」字段，而TCP 头部有「首部长度」字段呢？&lt;/p&gt;
&lt;p&gt;原因是 TCP 有可变长的「选项」字段，而UDP 头部长度则是不会变化的，无需多⼀个字段去记录 UDP 的首部长度。&lt;/p&gt;
&lt;p&gt;为什么 UDP 头部有「包长度」字段，而 TCP 头部则没有「包长度」字段呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718205054689.png&#34;
	width=&#34;1007&#34;
	height=&#34;62&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718205054689_hua2ef8e70df4b2dd128cdf2480b61936e_18068_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718205054689_hua2ef8e70df4b2dd128cdf2480b61936e_18068_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;TCP数据长度计算公式&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;1624&#34;
		data-flex-basis=&#34;3898px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;其中 IP 总长度 和 IP 首部长度，在 IP 首部格式是已知的。TCP 首部长度，则是在 TCP 首部格式已知的，所以就可以求得 TCP 数据的长度。&lt;/p&gt;
&lt;p&gt;因为为了网络设备硬件设计和处理方便，首部长度需要是 4 字节的整数倍。&lt;/p&gt;
&lt;h2 id=&#34;tcp连接&#34;&gt;TCP连接&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/qzcsu/article/details/72861891&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;两张动图-彻底明白TCP的三次握手与四次挥手&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718205302134.png&#34;
	width=&#34;813&#34;
	height=&#34;678&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718205302134_hu11f676b8277e0c8c3fcdd8bc60b2f4ee_63124_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718205302134_hu11f676b8277e0c8c3fcdd8bc60b2f4ee_63124_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;三次握手&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;119&#34;
		data-flex-basis=&#34;287px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;⼀开始，客户端和服务端都处于 CLOSED 状态。先是服务端主动监听某个端口，处于 LISTEN 状态&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718205347523.png&#34;
	width=&#34;1173&#34;
	height=&#34;708&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718205347523_huce689b0c8b97dd2dfea4e38658c95ca7_109592_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718205347523_huce689b0c8b97dd2dfea4e38658c95ca7_109592_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;三次握手-1&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;165&#34;
		data-flex-basis=&#34;397px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端会随机初始化序号（ client_isn ），将此序号置于 TCP 首部的「序号」字段中，同时把 SYN 标志位置为 1 ，表示 SYN 报文。接着把第⼀个 SYN 报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于 SYN-SENT 状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718205410356.png&#34;
	width=&#34;1188&#34;
	height=&#34;708&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718205410356_hu4cc1a77cd489dbcd6ce93358ba072968_134235_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718205410356_hu4cc1a77cd489dbcd6ce93358ba072968_134235_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;三次握手-2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;167&#34;
		data-flex-basis=&#34;402px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务端收到客户端的 SYN 报文后，首先服务端也随机初始化⾃⼰的序号（ server_isn ），将此序号填入TCP 首部的「序号」字段中，其次把 TCP 首部的「确认应答号」字段填入 client_isn + 1 , 接着把 SYN和 ACK 标志位置为 1 。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 SYN-RCVD 状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718205435389.png&#34;
	width=&#34;1188&#34;
	height=&#34;708&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718205435389_huf2b5cad342f679d42319469f44c59b63_114934_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718205435389_huf2b5cad342f679d42319469f44c59b63_114934_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;三次握手-3&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;167&#34;
		data-flex-basis=&#34;402px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端收到服务端报文后，还要向服务端回应最后⼀个应答报文，首先该应答报文 TCP 首部 ACK 标志位置为 1 ，其次「确认应答号」字段填入 server_isn + 1 ，最后把报文发送给服务端，这次报文可以携带客户到服务器的数据，之后客户端处于 ESTABLISHED 状态。&lt;/li&gt;
&lt;li&gt;服务器收到客户端的应答报文后，也进入 ESTABLISHED 状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;如何在-linux-系统中查看-tcp-状态&#34;&gt;如何在 Linux 系统中查看 TCP 状态？&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;netstat -napt&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718210055179.png&#34;
	width=&#34;1563&#34;
	height=&#34;327&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718210055179_hu1cd9efad8a5ad1fba906c8b4f73860e1_54379_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718210055179_hu1cd9efad8a5ad1fba906c8b4f73860e1_54379_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;netstat命令&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;477&#34;
		data-flex-basis=&#34;1147px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;为什么是三次握手不是两次四次&#34;&gt;为什么是三次握手？不是两次、四次？&lt;/h3&gt;
&lt;p&gt;以三个方面分析三次握手的原因&lt;/p&gt;
&lt;h4 id=&#34;三次握手才可以阻止重复历史连接的初始化-避免资源浪费主要原因&#34;&gt;三次握手才可以阻止重复历史连接的初始化 避免资源浪费（主要原因）&lt;/h4&gt;
&lt;p&gt;如果只有「两次握手」，当客户端的 SYN 请求连接在网络中阻塞，客户端没有接收到 ACK 报文，就会重新发送 SYN ，由于没有第三次握手，服务器不清楚客户端是否收到了自己发送的建⽴连接的 ACK 确认信号，所以每收到⼀个 SYN 就只能先主动建立⼀个连接，这会造成什么情况呢？&lt;/p&gt;
&lt;p&gt;如果客户端的 SYN 阻塞了，重复发送多次 SYN 报文，那么服务器在收到请求后就会建立多个冗余的无效链接，造成不必要的资源浪费。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;⼀个「旧 SYN 报文」比「最新的 SYN 」 报文早到达了服务端；&lt;/li&gt;
&lt;li&gt;那么此时服务端就会回⼀个 SYN + ACK 报文给客户端；&lt;/li&gt;
&lt;li&gt;客户端收到后可以根据自身的上下文，判断这是⼀个历史连接（序列号过期或超时），那么客户端就会发送RST 报文给服务端，表示中止这⼀次连接。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;三次握手才可以同步双方的初始序列号&#34;&gt;三次握手才可以同步双方的初始序列号&lt;/h4&gt;
&lt;p&gt;互相发送序列号并互相得到对方的确认，至少需要三次握手。如果两次握手那么服务端无法得到客户端的确认信息。&lt;/p&gt;
&lt;h2 id=&#34;tcp连接断开&#34;&gt;TCP连接断开&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718213708230.png&#34;
	width=&#34;753&#34;
	height=&#34;794&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718213708230_hu59227d121b74d6a5ef23fdc8d02accce_67564_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718213708230_hu59227d121b74d6a5ef23fdc8d02accce_67564_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;四次挥手&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;94&#34;
		data-flex-basis=&#34;227px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端打算关闭连接，此时会发送⼀个 TCP 首部 FIN 标志位被置为 1 的报文，也即 FIN 报文，之后客户端进入 FIN_WAIT_1 状态。&lt;/li&gt;
&lt;li&gt;服务端收到该报文后，就向客户端发送 ACK 应答报文，接着服务端进入 CLOSED_WAIT 状态。&lt;/li&gt;
&lt;li&gt;客户端收到服务端的 ACK 应答报文后，之后进入 FIN_WAIT_2 状态。&lt;/li&gt;
&lt;li&gt;等待服务端处理完数据后，也向客户端发送 FIN 报文，之后服务端进入 LAST_ACK 状态。&lt;/li&gt;
&lt;li&gt;客户端收到服务端的 FIN 报文后，回⼀个 ACK 应答报文，之后进入 TIME_WAIT 状态&lt;/li&gt;
&lt;li&gt;服务器收到了 ACK 应答报文后，就进入了 CLOSED 状态，⾄此服务端已经完成连接的关闭。&lt;/li&gt;
&lt;li&gt;客户端在经过 2MSL ⼀段时间后，⾃动进入 CLOSED 状态，⾄此客户端也完成连接的关闭。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每个方向都需要⼀个 FIN 和⼀个 ACK，因此通常被称为四次挥手。这⾥⼀点需要注意是：主动关闭连接的，才有 TIME_WAIT 状态。&lt;/p&gt;
&lt;h3 id=&#34;为什么需要四次挥手&#34;&gt;为什么需要四次挥手&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据。&lt;/li&gt;
&lt;li&gt;服务器收到客户端的 FIN 报文时，先回⼀个 ACK 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 FIN 报文给客户端来表示同意现在关闭连接。&lt;/li&gt;
&lt;li&gt;从上面过程可知，服务端通常需要等待完成数据的发送和处理，所以服务端的 ACK 和 FIN ⼀般都会分开发送，从而比三次握手导致多了⼀次。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;为什么-time_wait-等待的时间是-2msl&#34;&gt;为什么 TIME_WAIT 等待的时间是 2MSL？&lt;/h3&gt;
&lt;p&gt;MSL 是 Maximum Segment Lifetime，报文最大生存时间，它是任何报文在网络上存在的最⻓时间，超过这个时间报文将被丢弃。因为 TCP 报文基于是 IP 协议的，而 IP 头中有⼀个 TTL 字段，是 IP 数据报可以经过的最大路由数，每经过⼀个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃，同时发送 ICMP 报文通知源主机。&lt;/p&gt;
&lt;p&gt;MSL 与 TTL 的区别： MSL 的单位是时间，而 TTL 是经过路由跳数。所以 MSL 应该要大于等于 TTL 消耗为 0 的时间，以确保报文已被⾃然消亡。TIME_WAIT 等待 2 倍的 MSL，比较合理的解释是： 网络中可能存在来⾃发送方的数据包，当这些发送方的数据包被接收方处理后⼜会向对方发送响应，所以⼀来⼀回需要等待 2倍的时间。&lt;/p&gt;
&lt;p&gt;比如如果被动关闭方没有收到断开连接的最后的 ACK 报文，就会触发超时重发 Fin 报文，另⼀方接收到 FIN 后，会重发 ACK 给被动关闭方， ⼀来⼀去正好 2 个MSL。&lt;/p&gt;
&lt;p&gt;2MSL 的时间是从客户端接收到 FIN 后发送 ACK 开始计时的。如果在 TIME-WAIT 时间内，因为客户端的 ACK没有传输到服务端，客户端⼜接收到了服务端重发的 FIN 报文，那么 2MSL 时间将重新计时。&lt;/p&gt;
&lt;p&gt;在 Linux 系统⾥ 2MSL 默认是 60 秒，那么⼀个 MSL 也就是 30 秒。Linux 系统停留在 TIME_WAIT 的时间为固定的 60 秒。&lt;/p&gt;
&lt;h3 id=&#34;为什么需要-time_wait-状态&#34;&gt;为什么需要 TIME_WAIT 状态？&lt;/h3&gt;
&lt;h4 id=&#34;防止旧连接的数据包&#34;&gt;防止旧连接的数据包&lt;/h4&gt;
&lt;p&gt;经过 2MSL 这个时间，⾜以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都⾃然消失，再出现的数据包⼀定都是新建⽴连接所产生的。&lt;/p&gt;
&lt;h4 id=&#34;保证连接正确关闭&#34;&gt;保证连接正确关闭&lt;/h4&gt;
&lt;p&gt;TIME-WAIT 作用是等待⾜够的时间以确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭。&lt;/p&gt;
&lt;h3 id=&#34;time_wait-过多有什么危害&#34;&gt;TIME_WAIT 过多有什么危害？&lt;/h3&gt;
&lt;p&gt;过多的 TIME-WAIT 状态主要的危害有两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第⼀是内存资源占用；&lt;/li&gt;
&lt;li&gt;第⼆是对端口资源的占用，⼀个 TCP 连接⾄少消耗⼀个本地端口；如果发起连接⼀方的 TIME_WAIT 状态过多，占满了所有端口资源，则会导致无法创建新连接。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;如何优化-time_wait&#34;&gt;如何优化 TIME_WAIT？&lt;/h4&gt;
&lt;p&gt;Linux 内核参数开启后，则可以复用处于 TIME_WAIT 的 socket 为新的连接所用。tcp_tw_reuse 功能只能用客户端（连接发起方），因为开启了该功能，在调用 connect()函数时，内核会随机找⼀个 time_wait 状态超过 1 秒的连接给新的连接复用。&lt;/p&gt;
&lt;h3 id=&#34;tcp保活机制&#34;&gt;TCP保活机制&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;TCP短连接:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;TCP短连接的情况，client向server发起连接请求，server接到请求，然后双方建立连接。client向server发送消息，server回应client，然后一次读写就完成了，这时候双方任何一个都可以发起close操作，不过一般都是client先发起close操作。&lt;/p&gt;
&lt;p&gt;为什么呢，一般的server不会回复完client后立即关闭连接的，当然不排除有特殊的情况。从上面的描述看，短连接一般只会在client/server间传递一次读写操作&lt;/p&gt;
&lt;p&gt;短连接的优点是：管理起来比较简单，存在的连接都是有用的连接，不需要额外的控制手段。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TCP长连接：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;长连接的情况，client向server发起连接，server接受client连接，双方建立连接。Client与server完成一次读写之后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。&lt;/p&gt;
&lt;p&gt;首先说一下TCP/IP详解上讲到的TCP保活功能，保活功能主要为服务器应用提供，服务器应用希望知道客户主机是否崩溃，从而可以代表客户使用资源。如果客户已经消失，使得服务器上保留一个半开放的连接，而服务器又在等待来自客户端的数据，则服务器将应远等待客户端的数据，保证功能就是试图在服务器端检测到这种半开放的连接。&lt;/p&gt;
&lt;p&gt;如果一个给定的连接在两小时内没有任何的动作，则服务器就向客户发一个探测报文段，客户主机必须处于以下4个状态之一：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;客户主机依然正常运行，并从服务器可达。客户的TCP响应正常，而服务器也知道对方是正常的，服务器在两小时后将保证定时器复位。&lt;/li&gt;
&lt;li&gt;客户主机已经崩溃，并且关闭或者正在重新启动。在任何一种情况下，客户的TCP都没有响应。服务端将不能收到对探测的响应，并在75秒后超时。服务器总共发送10个这样的探测 ，每个间隔75秒。如果服务器没有收到一个响应，它就认为客户主机已经关闭并终止连接。&lt;/li&gt;
&lt;li&gt;客户主机崩溃并已经重新启动。服务器将收到一个对其保证探测的响应，这个响应是一个复位，使得服务器终止这个连接。&lt;/li&gt;
&lt;li&gt;客户机正常运行，但是服务器不可达，这种情况与2类似，TCP能发现的就是没有收到探查的响应。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;从上面可以看出，TCP保活功能主要为探测长连接的存活状况，不过这里存在一个问题，存活功能的探测周期太长，还有就是它只是探测TCP连接的存活，属于比较斯文的做法，遇到恶意的连接时，保活功能就不够使了。&lt;/p&gt;
&lt;h2 id=&#34;既然-ip-层会分片为什么-tcp-层还需要-mss-呢&#34;&gt;既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718212310101.png&#34;
	width=&#34;1067&#34;
	height=&#34;422&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718212310101_hu1e526c0b4a2f8d3152247bc5add70829_64608_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718212310101_hu1e526c0b4a2f8d3152247bc5add70829_64608_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;MTU和MSS&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;252&#34;
		data-flex-basis=&#34;606px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MTU ：⼀个网络包的最大长度，以太网中⼀般为 1500 字节；&lt;/li&gt;
&lt;li&gt;MSS ：除去 IP 和 TCP 头部之后，⼀个网络包所能容纳的 TCP 数据的最大度；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当 IP 层有⼀个超过 MTU 大小的数据（TCP 头部 + TCP 数据）要发送，那么 IP 层就要进行分片，把数据分片成若干片，保证每⼀个分片都小于 MTU。把⼀份 IP 数据报进行分片以后，由目标主机的 IP 层来进行重新组装后，再交给上⼀层 TCP 传输层。&lt;/p&gt;
&lt;p&gt;这看起来井然有序，但这存在隐患的，那么当如果⼀个 IP 分片丢失，整个 IP 报文的所有分片都得重传。&lt;/p&gt;
&lt;p&gt;因为 IP 层本身没有超时重传机制，它由传输层的 TCP 来负责超时和重传。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当接收方发现 TCP 报文（头部 + 数据）的某⼀片丢失后，则不会响应 ACK 给对方，那么发送方的 TCP 在超时后，就会重发「整个 TCP 报文（头部 + 数据）」。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;因此，可以得知由 IP 层进行分片传输，是非常没有效率的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所以，为了达到最佳的传输效能 TCP 协议在建⽴连接的时候通常要协商双方的 MSS 值，当 TCP 层发现数据超过MSS 时，则就先会进行分片，当然由它形成的 IP 包的⻓度也就不会大于 MTU ，⾃然也就不用 IP 分片了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;经过 TCP 层分片后，如果⼀个 TCP 分片丢失后，进行重发时也是以 MSS 为单位，而不用重传所有的分片，大大增加了重传的效率。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;什么是-syn-攻击如何避免-syn-攻击&#34;&gt;什么是 SYN 攻击？如何避免 SYN 攻击？&lt;/h2&gt;
&lt;h3 id=&#34;syn攻击&#34;&gt;SYN攻击&lt;/h3&gt;
&lt;p&gt;我们都知道 TCP 连接建⽴是需要三次握手，假设攻击者短时间伪造不同 IP 地址的 SYN 报文，服务端每接收到⼀个 SYN 报文，就进入 SYN_RCVD 状态，但服务端发送出去的 ACK + SYN 报文，无法得到未知 IP 主机的ACK 应答，久而久之就会占满服务端的 SYN 接收队列（未连接队列），使得服务器不能为正常用户服务。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718212721706.png&#34;
	width=&#34;500&#34;
	height=&#34;348&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718212721706_hue4f8755de0cf2894d775595508aba5a7_101239_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718212721706_hue4f8755de0cf2894d775595508aba5a7_101239_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;SYN攻击&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;143&#34;
		data-flex-basis=&#34;344px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;解决方法&#34;&gt;解决方法&lt;/h3&gt;
&lt;p&gt;方法一：&lt;/p&gt;
&lt;p&gt;其中⼀种解决方式是通过修改 Linux 内核参数，控制队列大小和当队列满时应做什么处理。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当网卡接收数据包的速度大于内核处理的速度时，会有⼀个队列保存这些数据包。控制该队列的最大值如下参数：&lt;code&gt;net.core.netdev_max_backlog&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;SYN_RCVD 状态连接的最大个数：&lt;code&gt;net.ipv4.tcp_max_syn_backlog&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;超出处理能时，对新的 SYN 直接回报 RST，丢弃连接：&lt;code&gt;net.ipv4.tcp_abort_on_overflow&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;方法二：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718212953083.png&#34;
	width=&#34;737&#34;
	height=&#34;519&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718212953083_hu7c65eb8fdeda67b3846fc3fa95f9b0b3_61732_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718212953083_hu7c65eb8fdeda67b3846fc3fa95f9b0b3_61732_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;SYN队列&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;142&#34;
		data-flex-basis=&#34;340px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当 「 SYN 队列」满之后，后续服务器收到 SYN 包，不进入「 SYN 队列」；&lt;/li&gt;
&lt;li&gt;计算出⼀个 cookie 值，再以 SYN + ACK 中的「序列号」返回客户端，（cookie 的作用是验证之后可能到达的&lt;code&gt;ACK&lt;/code&gt;的有效性，保证这是一次完整的握手获得&lt;code&gt;SYN&lt;/code&gt;报文中携带的&lt;code&gt;TCP&lt;/code&gt;选项信息）&lt;/li&gt;
&lt;li&gt;服务端接收到客户端的应答报文时，服务器会检查这个 ACK 包的合法性。如果合法，直接放入到「 Accept队列」。&lt;/li&gt;
&lt;li&gt;最后应用通过调用 accpet() socket 接口，从「 Accept 队列」取出的连接。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718213041933.png&#34;
	width=&#34;762&#34;
	height=&#34;564&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718213041933_hu09417038a9a317da07526dbff59acc00_73260_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718213041933_hu09417038a9a317da07526dbff59acc00_73260_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;SYN攻击解决&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;135&#34;
		data-flex-basis=&#34;324px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;tcp重传机制&#34;&gt;TCP重传机制&lt;/h2&gt;
&lt;h3 id=&#34;超时重传&#34;&gt;超时重传&lt;/h3&gt;
&lt;p&gt;重传机制的其中⼀个方式，就是在发送数据时，设定⼀个定时器，当超过指定的时间后，没有收到对方的 ACK确认应答报文，就会重发该数据，也就是我们常说的超时重传。
TCP 会在以下两种情况发生超时重传：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据包丢失&lt;/li&gt;
&lt;li&gt;确认应答丢失&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;超时时间&#34;&gt;超时时间&lt;/h4&gt;
&lt;p&gt;RTT 就是数据从网络⼀端传送到另⼀端所需的时间，也就是包的往返时间。超时重传时间是以 RTO （Retransmission Timeout 超时重传时间）表示。&lt;/p&gt;
&lt;p&gt;超时重传时间 RTO 的值应该略大于报文往返 RTT 的值。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当超时时间 RTO 较大时，重发就慢，丢了老半天才重发，没有效率，性能差；&lt;/li&gt;
&lt;li&gt;当超时时间 RTO 较小时，会导致可能并没有丢就重发，于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;快速重传&#34;&gt;快速重传&lt;/h3&gt;
&lt;p&gt;TCP 还有另外⼀种快速重传（Fast Retransmit）机制，它不以时间为驱动，而是以数据驱动重传&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718220814102.png&#34;
	width=&#34;647&#34;
	height=&#34;602&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718220814102_hu6e48694c64f8a588a8190d7e30d521e5_53429_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718220814102_hu6e48694c64f8a588a8190d7e30d521e5_53429_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;快速重传&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;107&#34;
		data-flex-basis=&#34;257px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;快速重传的⼯作方式是当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段。&lt;/p&gt;
&lt;p&gt;快速重传机制只解决了⼀个问题，就是超时时间的问题，但是它依然面临着另外⼀个问题。就是重传的时候，是重传之前的⼀个，还是重传所有的问题。&lt;/p&gt;
&lt;h3 id=&#34;sack&#34;&gt;SACK&lt;/h3&gt;
&lt;p&gt;还有一种实现重传机制的方式叫：SACK（ Selective Acknowledgment 选择性确认）。
这种方式需要在 TCP 头部「选项」字段里加一个 SACK 的东西，它&lt;strong&gt;可以将缓存的地图发送给发送方&lt;/strong&gt;，这样发送方就可以知道哪些数据收到了，哪些数据没收到知道了这些信息，就可以&lt;strong&gt;只重传丢失的数据&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;dsack&#34;&gt;DSACK&lt;/h3&gt;
&lt;p&gt;Duplicate SACK ⼜称 D-SACK ，其主要使用了 SACK 来告诉「发送方」有哪些数据被重复接收了。&lt;/p&gt;
&lt;h2 id=&#34;滑动窗口&#34;&gt;滑动窗口&lt;/h2&gt;
&lt;p&gt;累计确认不怕ACK信息丢失&lt;/p&gt;
&lt;p&gt;累计确认：只要发送方收到了 ACK700 确认应答，就意味着 700 之前的所有数据「接收方」都收到了。这个模式就叫累计确认或者累计应答。&lt;/p&gt;
&lt;h3 id=&#34;窗口大小如何确定&#34;&gt;窗口大小如何确定&lt;/h3&gt;
&lt;p&gt;这个字段是接收端告诉发送端 还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能⼒来发送数据，而不会导致接收端处理不过来。所以，通常窗口的大小是由接收方的窗口大小来决定的。&lt;/p&gt;
&lt;p&gt;发送方发送的数据大小不能超过接收方的窗口大小，否则接收方就无法正常接收到数据。&lt;/p&gt;
&lt;h2 id=&#34;流量控制&#34;&gt;流量控制&lt;/h2&gt;
&lt;p&gt;发送方不能无脑的发数据给接收方，要考虑接收方处理能⼒。&lt;/p&gt;
&lt;p&gt;如果⼀直无脑的发数据给对方，但对方处理不过来，那么就会导致触发重发机制，从而导致网络流量的无端的浪费。&lt;/p&gt;
&lt;p&gt;为了解决这种现象发生，TCP 提供⼀种机制可以让「发送方」根据「接收方」的实际接收能⼒控制发送的数据量，这就是所谓的流量控制。&lt;/p&gt;
&lt;p&gt;根据调整窗口的大小来控制发送方与接收方的流量&lt;/p&gt;
&lt;h2 id=&#34;拥塞控制&#34;&gt;拥塞控制&lt;/h2&gt;
&lt;h3 id=&#34;流量控制与拥塞控制对比&#34;&gt;流量控制与拥塞控制对比&lt;/h3&gt;
&lt;p&gt;前面的流量控制是避免「发送方」的数据填满「接收方」的缓存，但是并不知道网络的中发生了什么。⼀般来说，计算机网络都处在⼀个共享的环境。因此也有可能会因为其他主机之间的通信使得网络拥堵。&lt;/p&gt;
&lt;p&gt;在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是⼀重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大&amp;hellip;.&lt;/p&gt;
&lt;p&gt;于是，就有了拥塞控制，控制的目的就是避免「发送方」的数据填满整个网络。为了在「发送方」调节所要发送数据的量，定义了⼀个叫做「拥塞窗口」的概念。&lt;/p&gt;
&lt;p&gt;拥塞窗口 cwnd是发送方维护的⼀个的状态变量，它会根据网络的拥塞程度动态变化的。&lt;/p&gt;
&lt;p&gt;我们在前面提到过发送窗口 swnd 和接收窗口 rwnd 是约等于的关系，那么由于加入了拥塞窗口的概念后，此时发送窗口的值是swnd = min(cwnd, rwnd)，也就是&lt;strong&gt;拥塞窗口和接收窗口中的最小值&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;拥塞窗口 cwnd 变化的规则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只要网络中没有出现拥塞， cwnd 就会增大；&lt;/li&gt;
&lt;li&gt;但网络中出现了拥塞， cwnd 就减少；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;传输轮次：每一个窗口为一轮，例如当前轮次窗口为4，那么传输完4字节后，开始下一轮。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/14.jpg&#34;
	width=&#34;621&#34;
	height=&#34;313&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/14_hu672fe8e890b96438a399c64b3e32e88a_46530_480x0_resize_q75_box.jpg 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/14_hu672fe8e890b96438a399c64b3e32e88a_46530_1024x0_resize_q75_box.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;拥塞控制&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;198&#34;
		data-flex-basis=&#34;476px&#34;
	
&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>网络03-IP协议</title>
        <link>https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C03-ip%E5%8D%8F%E8%AE%AE/</link>
        <pubDate>Mon, 18 Jul 2022 00:04:34 +0800</pubDate>
        
        <guid>https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C03-ip%E5%8D%8F%E8%AE%AE/</guid>
        <description>&lt;h2 id=&#34;数据链路层&#34;&gt;数据链路层&lt;/h2&gt;
&lt;p&gt;[计算机网络 - 链路层 | CS-Notes (cyc2018.xyz)](&lt;a class=&#34;link&#34; href=&#34;http://www.cyc2018.xyz/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://www.cyc2018.xyz/&lt;/a&gt;计算机基础/网络基础/计算机网络 - 链路层.html)&lt;/p&gt;
&lt;h2 id=&#34;网络层和数据链路层的关系&#34;&gt;网络层和数据链路层的关系&lt;/h2&gt;
&lt;p&gt;IP 的作用是主机之间通信用的，而 MAC 的作用则是实现「直连」的两个设备之间通信，而 IP 则负责在「没有直连」的两个网络之间进行通信传输。&lt;/p&gt;
&lt;h2 id=&#34;ip地址分类&#34;&gt;IP地址分类&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C03-ip%E5%8D%8F%E8%AE%AE/image-20220718165201221.png&#34;
	width=&#34;965&#34;
	height=&#34;645&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C03-ip%E5%8D%8F%E8%AE%AE/image-20220718165201221_huab3169f209f237fe3b95a91e12da8a16_125241_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C03-ip%E5%8D%8F%E8%AE%AE/image-20220718165201221_huab3169f209f237fe3b95a91e12da8a16_125241_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;IP地址分类&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;149&#34;
		data-flex-basis=&#34;359px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;D类地址用于组播（多播用于将包发送给特定组内的所有主机。）、E类地址为保留用&lt;/p&gt;
&lt;h3 id=&#34;主机个数&#34;&gt;主机个数&lt;/h3&gt;
&lt;p&gt;每类地址的最大主机个数要看主机号的位数，例如C类地址的主机号占8位，那么C类地址的最大主机个数位：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C03-ip%E5%8D%8F%E8%AE%AE/image-20220718165417407.png&#34;
	width=&#34;482&#34;
	height=&#34;119&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C03-ip%E5%8D%8F%E8%AE%AE/image-20220718165417407_hub91a98ade6dc23db785b6bbe6f396d29_11287_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C03-ip%E5%8D%8F%E8%AE%AE/image-20220718165417407_hub91a98ade6dc23db785b6bbe6f396d29_11287_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;C类地址的主机数&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;405&#34;
		data-flex-basis=&#34;972px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;为什么要减2呢？因为在 IP 地址中，有两个 IP 是特殊的，分别是主机号全为 1 和 全为 0 地址。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;网络号为全0：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果主机号也为全0，那么此类ip地址可以当源端但不可以做目的端，此ip地址代表的是网络上的主机。&lt;/li&gt;
&lt;li&gt;如果主机号不全为0，那么此类ip地址的使用和 1 相同，只是它代表的是网络上特定的主机。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;网络号为 127:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在我们划分A类地址时有一个地址0111111.x.x.x 的地址，即网络号是127的地址我们并没有使用，是因为这里将127的网络号和任意的主机号组合当做回环地址来使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主机号是全1的情况:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;广播地址可以分为本地广播和直接广播两种。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在本网络内广播的叫做本地广播。例如网络地址为 192.168.0.0/24 的情况下，广播地址是 192.168.0.255 。因为这个广播地址的 IP 包会被路由器屏蔽，所以不会到达 192.168.0.0/24 以外的其他链路上。&lt;/li&gt;
&lt;li&gt;在不同网络之间的广播叫做直接广播。例如网络地址为 192.168.0.0/24 的主机向 192.168.1.255/24 的目标地址发送 IP 包。收到这个包的路由器，将数据转发给 192.168.1.0/24，从而使得所有192.168.1.1~192.168.1.254 的主机都能收到这个包（由于直接广播有⼀定的安全问题，多数情况下会在路由器上设置为不转发）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ip分类的优缺点&#34;&gt;IP分类的优缺点&lt;/h3&gt;
&lt;h4 id=&#34;优点&#34;&gt;优点&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;不管是路由器还是主机解析到⼀个 IP 地址时候，我们判断其 IP 地址的首位是否为 0，为 0 则为 A 类地址，那么就能很快的找出网络地址和主机地址。优点就是简单明了、选路（基于网络地址）简单。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;缺点&#34;&gt;缺点&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;同⼀网络下没有地址层次，比如⼀个公司⾥用了 B 类地址，但是可能需要根据⽣产环境、测试环境、开发环境来划分地址层次，而这种 IP 分类是没有地址层次划分的功能，所以这就缺少地址的灵活性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A、B、C类有个尴尬处境，就是不能很好的与现实网络匹配。C 类地址能包含的最大主机数量实在太少了，只有 254 个，估计⼀个网吧都不够用。而 B 类地址能包含的最大主机数量又太多了，6 万多台机器放在⼀个网络下面，⼀般的企业基本达不到这个规模，闲着的地址就是浪费。这两个缺点，都可以在 CIDR ⽆分类地址解决。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;无分类地址-cidr&#34;&gt;无分类地址 CIDR&lt;/h3&gt;
&lt;p&gt;⼦网掩码，掩码的意思就是掩盖掉主机号，剩余的就是网络号。将⼦网掩码和 IP 地址按位计算 AND，就可得到网络号。&lt;/p&gt;
&lt;p&gt;子网划分：从主机号中借几位作为子网号，同时搭配对应的子网掩码。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C03-ip%E5%8D%8F%E8%AE%AE/image-20220718165954778.png&#34;
	width=&#34;710&#34;
	height=&#34;897&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C03-ip%E5%8D%8F%E8%AE%AE/image-20220718165954778_hu5db76a85da64ed758b895fc2aee977cf_130816_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C03-ip%E5%8D%8F%E8%AE%AE/image-20220718165954778_hu5db76a85da64ed758b895fc2aee977cf_130816_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;CIDR&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;79&#34;
		data-flex-basis=&#34;189px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;ip地址与路由控制&#34;&gt;IP地址与路由控制&lt;/h2&gt;
&lt;p&gt;IP地址的网络地址这⼀部分是用于进行路由控制。&lt;/p&gt;
&lt;p&gt;路由控制表中记录着网络地址与下⼀步应该发送至路由器的地址。在主机和路由器上都会有各自的路由器控制表。&lt;/p&gt;
&lt;p&gt;在发送 IP 包时，首先要确定 IP 包首部中的目标地址，再从路由控制表中找到与该地址具有相同网络地址的记录，根据该记录将 IP 包转发给相应的下⼀个路由器。如果路由控制表中存在多条相同网络地址的记录，就选择相同位数最多的网络地址，也就是最长匹配。&lt;/p&gt;
&lt;p&gt;下面以下图的网络链路作为例⼦说明&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C03-ip%E5%8D%8F%E8%AE%AE/image-20220718170355355.png&#34;
	width=&#34;1416&#34;
	height=&#34;902&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C03-ip%E5%8D%8F%E8%AE%AE/image-20220718170355355_hub4f69c90462582ff85546b9caf48a3ba_146717_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C03-ip%E5%8D%8F%E8%AE%AE/image-20220718170355355_hub4f69c90462582ff85546b9caf48a3ba_146717_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;IP路由过程&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;156&#34;
		data-flex-basis=&#34;376px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;环回地址&#34;&gt;环回地址&lt;/h3&gt;
&lt;p&gt;环回地址是在同⼀台计算机上的程序之间进行网络通信时所使用的⼀个默认地址。计算机使用⼀个特殊的 IP 地址 127.0.0.1 作为环回地址。与该地址具有相同意义的是⼀个叫做 localhost 的主机名。使用这个 IP 或主机名时，数据包不会流向网络。&lt;/p&gt;
&lt;h2 id=&#34;ip分片与重组&#34;&gt;IP分片与重组&lt;/h2&gt;
&lt;p&gt;每种数据链路的最大传输单元 MTU 都是不相同的，如 FDDI 数据链路 MTU 4352、以太网的 MTU 是 1500 字节等。&lt;/p&gt;
&lt;p&gt;每种数据链路的 MTU 之所以不同，是因为每个不同类型的数据链路的使用目的不同。使用目的不同，可承载的MTU 也就不同。&lt;/p&gt;
&lt;p&gt;其中，我们最常见数据链路是以太网，它的 MTU 是 1500 字节。&lt;/p&gt;
&lt;p&gt;那么当 IP 数据包大小大于 MTU 时， IP 数据包就会被分片。&lt;/p&gt;
&lt;p&gt;经过分片之后的 IP 数据报在被重组的时候，只能由目标主机进行，路由器是不会进行重组的。&lt;/p&gt;
&lt;p&gt;假设发送方发送⼀个 4000 字节的大数据报，若要传输在以太网链路，则需要把数据报分片成 3 个小数据报进行传输，再交由接收方重组成大数据报。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C03-ip%E5%8D%8F%E8%AE%AE/image-20220718170803277.png&#34;
	width=&#34;1154&#34;
	height=&#34;285&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C03-ip%E5%8D%8F%E8%AE%AE/image-20220718170803277_hue4850b2b9bd1125e429178351e028c6e_49201_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C03-ip%E5%8D%8F%E8%AE%AE/image-20220718170803277_hue4850b2b9bd1125e429178351e028c6e_49201_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;IP分组&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;404&#34;
		data-flex-basis=&#34;971px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;ipv6&#34;&gt;IPV6&lt;/h2&gt;
&lt;p&gt;IPv4 地址长度共 32 位，是以每 8 位作为⼀组，并用点分⼗进制的表示方式。&lt;/p&gt;
&lt;p&gt;IPv6 地址长度是 128 位，是以每 16 位作为⼀组，每组用冒号 「:」 隔开。&lt;/p&gt;
&lt;p&gt;IPv6 相比 IPv4 的首部改进：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;取消了首部校验和字段。 因为在数据链路层和传输层都会校验，因此 IPv6 直接取消了 IP 的校验。&lt;/li&gt;
&lt;li&gt;取消了分片/重新组装相关字段。 分片与重组是耗时的过程，IPv6 不允许在中间路由器进行分片与重组，这种操作只能在源与目标主机，这将大大提⾼了路由器转发的速度。&lt;/li&gt;
&lt;li&gt;取消选项字段。 选项字段不再是标准 IP 首部的⼀部分了，但它并没有消失，而是可能出现在 IPv6 首部中的「下⼀个首部」指出的位置上。删除该选项字段使的 IPv6 的首部成为固定长度的 40 字节。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C03-ip%E5%8D%8F%E8%AE%AE/image-20220718171251585.png&#34;
	width=&#34;1517&#34;
	height=&#34;497&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C03-ip%E5%8D%8F%E8%AE%AE/image-20220718171251585_huf3841a1c6187d16241175a67e11c902b_108207_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C03-ip%E5%8D%8F%E8%AE%AE/image-20220718171251585_huf3841a1c6187d16241175a67e11c902b_108207_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;IPV6 与 IPV4 首部对比&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;305&#34;
		data-flex-basis=&#34;732px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;ip协议相关技术&#34;&gt;IP协议相关技术&lt;/h2&gt;
&lt;h3 id=&#34;dns&#34;&gt;DNS&lt;/h3&gt;
&lt;p&gt;根域是在最顶层，它的下⼀层就是 com 顶级域，再下面是 server.com。&lt;/p&gt;
&lt;p&gt;所以域名的层级关系类似⼀个树状结构：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根 DNS 服务器&lt;/li&gt;
&lt;li&gt;顶级域 DNS 服务器（com）&lt;/li&gt;
&lt;li&gt;权威 DNS 服务器（server.com）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C03-ip%E5%8D%8F%E8%AE%AE/image-20220718172004203.png&#34;
	width=&#34;1505&#34;
	height=&#34;1095&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C03-ip%E5%8D%8F%E8%AE%AE/image-20220718172004203_hu24d2fbe6b2573423461fd745ec56deac_268308_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C03-ip%E5%8D%8F%E8%AE%AE/image-20220718172004203_hu24d2fbe6b2573423461fd745ec56deac_268308_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;DNS解析过程&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;137&#34;
		data-flex-basis=&#34;329px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;arp&#34;&gt;ARP&lt;/h3&gt;
&lt;p&gt;在传输⼀个 IP 数据报的时候，确定了源 IP 地址和目标 IP 地址后，就会通过主机「路由表」确定 IP 数据包下⼀跳。然而，网络层的下⼀层是数据链路层，所以我们还要知道「下⼀跳」的 MAC 地址。&lt;/p&gt;
&lt;p&gt;由于主机的路由表中可以找到下⼀跳的 IP 地址，所以可以通过 ARP 协议，求得下⼀跳的 MAC 地址。&lt;/p&gt;
&lt;p&gt;那么 ARP 又是如何知道对方 MAC 地址的呢？&lt;/p&gt;
&lt;p&gt;简单地说，ARP 是借助 ARP 请求与 ARP 响应两种类型的包确定 MAC 地址的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主机会通过广播发送 ARP 请求，这个包中包含了想要知道的 MAC 地址的主机 IP 地址。&lt;/li&gt;
&lt;li&gt;当同个链路中的所有设备收到 ARP 请求时，会去拆开 ARP 请求包⾥的内容，如果 ARP 请求包中的目标 IP地址与自己的 IP 地址⼀致，那么这个设备就将自己的 MAC 地址塞入 ARP 响应包返回给主机。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C03-ip%E5%8D%8F%E8%AE%AE/image-20220718191154055.png&#34;
	width=&#34;594&#34;
	height=&#34;498&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C03-ip%E5%8D%8F%E8%AE%AE/image-20220718191154055_hucf92c20f33913cb3a5706a65679b1d50_71116_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C03-ip%E5%8D%8F%E8%AE%AE/image-20220718191154055_hucf92c20f33913cb3a5706a65679b1d50_71116_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;ARP请求&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;119&#34;
		data-flex-basis=&#34;286px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;操作系统通常会把第⼀次通过 ARP 获取的 MAC 地址缓存起来，以便下次直接从缓存中找到对应 IP 地址的 MAC地址。不过，MAC 地址的缓存是有⼀定期限的，超过这个期限，缓存的内容将被清除。&lt;/p&gt;
&lt;h3 id=&#34;rarp&#34;&gt;RARP&lt;/h3&gt;
&lt;p&gt;ARP 协议是已知 IP 地址求 MAC 地址，那 RARP 协议正好相反，它是已知 MAC 地址求 IP 地址。例如将打印机服务器等小型嵌入式设备接入到网络时就经常会用得到。&lt;/p&gt;
&lt;p&gt;通常这需要架设⼀台 RARP 服务器，在这个服务器上注册设备的 MAC 地址及其 IP 地址。然后再将这个设备接入到网络，接着：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;该设备会发送⼀条「我的 MAC 地址是XXXX，请告诉我，我的IP地址应该是什么」的请求信息。&lt;/li&gt;
&lt;li&gt;RARP 服务器接到这个消息后返回「MAC地址为 XXXX 的设备，IP地址为 XXXX」的信息给这个设备。&lt;/li&gt;
&lt;li&gt;最后，设备就根据从 RARP 服务器所收到的应答信息设置自己的 IP 地址。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;dhcp&#34;&gt;DHCP&lt;/h3&gt;
&lt;p&gt;DHCP 在⽣活中我们是很常见的了，我们的电脑通常都是通过 DHCP 动态获取 IP 地址，大大省去了配 IP 信息繁琐的过程&lt;/p&gt;
&lt;p&gt;DHCP 交互中，全程都是使用 &lt;strong&gt;UDP 广播通信&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;先说明⼀点，DHCP 客户端进程监听的是 68 端口号，DHCP 服务端进程监听的是 67 端口号。&lt;/p&gt;
&lt;p&gt;这 4 个步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端首先发起 DHCP 发现报文（DHCP DISCOVER） 的 IP 数据报，由于客户端没有 IP 地址，也不知道DHCP 服务器的地址，所以使用的是 UDP 广播通信，其使用的广播目的地址是 255.255.255.255（端口67） 并且使用 0.0.0.0（端口 68） 作为源 IP 地址。DHCP 客户端将该 IP 数据报传递给链路层，链路层然后将帧广播到所有的网络中设备。&lt;/li&gt;
&lt;li&gt;DHCP 服务器收到 DHCP 发现报文时，用 DHCP 提供报文（DHCP OFFER） 向客户端做出响应。该报文仍然使用 IP 广播地址 255.255.255.255，该报文信息携带服务器提供可租约的 IP 地址、⼦网掩码、默认网关、DNS 服务器以及 IP 地址租用期。&lt;/li&gt;
&lt;li&gt;客户端收到⼀个或多个服务器的 DHCP 提供报文后，从中选择⼀个服务器，并向选中的服务器发送 DHCP 请求报文（DHCP REQUEST进行响应，回显配置的参数。&lt;/li&gt;
&lt;li&gt;最后，服务端用 DHCP ACK 报文对 DHCP 请求报文进行响应，应答所要求的参数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;⼀旦客户端收到 DHCP ACK 后，交互便完成了，并且客户端能够在租用期内使用 DHCP 服务器分配的 IP 地址。如果租约的 DHCP IP 地址快期后，客户端会向服务器发送 DHCP 请求报文：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务器如果同意继续租用，则用 DHCP ACK 报文进行应答，客户端就会延长租期。&lt;/li&gt;
&lt;li&gt;服务器如果不同意继续租用，则用 DHCP NACK 报文，客户端就要停⽌使用租约的 IP 地址。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;nat&#34;&gt;NAT&lt;/h3&gt;
&lt;p&gt;IPv4 的地址是非常紧缺的，在前面我们也提到可以通过⽆分类地址来减缓 IPv4 地址耗尽的速度，但是互联网的用户增速是非常惊⼈的，所以 IPv4 地址依然有被耗尽的危险。于是，提出了⼀种网络地址转换 NAT 的方法，再次缓解了 IPv4 地址耗尽的问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;简单的来说 NAT 就是同个公司、家庭、教室内的主机对外部通信时，把私有 IP 地址转换成公有 IP 地址。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C03-ip%E5%8D%8F%E8%AE%AE/image-20220718192020671.png&#34;
	width=&#34;1562&#34;
	height=&#34;617&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C03-ip%E5%8D%8F%E8%AE%AE/image-20220718192020671_hu0f7672e1f9a3dd3928a10546c47aa9f6_100412_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C03-ip%E5%8D%8F%E8%AE%AE/image-20220718192020671_hu0f7672e1f9a3dd3928a10546c47aa9f6_100412_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;NAT协议&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;253&#34;
		data-flex-basis=&#34;607px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那不是 N 个私有 IP 地址，你就要 N 个公有 IP 地址？这怎么就缓解了 IPv4 地址耗尽的问题？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于绝大多数的网络应用都是使用传输层协议 TCP 或 UDP 来传输数据的。因此，可以把 IP 地址 + 端口号⼀起进行转换。这样，就用⼀个全球 IP 地址就可以了，这种转换技术就叫网络地址与端口转换 NAPT。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C03-ip%E5%8D%8F%E8%AE%AE/image-20220718192418804.png&#34;
	width=&#34;1541&#34;
	height=&#34;834&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C03-ip%E5%8D%8F%E8%AE%AE/image-20220718192418804_hudadf5ac9a1ccbea3e104eb07b6c831d3_140429_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C03-ip%E5%8D%8F%E8%AE%AE/image-20220718192418804_hudadf5ac9a1ccbea3e104eb07b6c831d3_140429_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;NAPT协议&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;184&#34;
		data-flex-basis=&#34;443px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;图中有两个客户端 192.168.1.10 和 192.168.1.11 同时与服务器 183.232.231.172 进行通信，并且这两个客户端的本地端口都是 1025。&lt;/p&gt;
&lt;p&gt;此时，两个私有 IP 地址都转换 IP 地址为公有地址 120.229.175.121，但是以不同的端口号作为区分。&lt;/p&gt;
&lt;p&gt;于是，⽣成⼀个 NAPT 路由器的转换表，就可以正确地转换地址跟端口的组合，令客户端 A、B 能同时与服务器之间进行通信。&lt;/p&gt;
&lt;p&gt;这种转换表在 NAT 路由器上自动⽣成。例如，在 TCP 的情况下，建⽴ TCP 连接首次握⼿时的 SYN 包⼀经发出，就会⽣成这个表。而后又随着收到关闭连接时发出 FIN 包的确认应答从表中被删除。&lt;/p&gt;
&lt;h4 id=&#34;nat-的缺点&#34;&gt;NAT 的缺点&lt;/h4&gt;
&lt;p&gt;由于 NAT/NAPT 都依赖于自己的转换表，因此会有以下的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;外部⽆法主动与 NAT 内部服务器建⽴连接，因为 NAPT 转换表没有转换记录。&lt;/li&gt;
&lt;li&gt;转换表的⽣成与转换操作都会产⽣性能开销。&lt;/li&gt;
&lt;li&gt;通信过程中，如果 NAT 路由器重启了，所有的 TCP 连接都将被重置。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;解决&#34;&gt;解决&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;改用IPV6，每台机器一个公网IP&lt;/li&gt;
&lt;li&gt;NAT穿透技术：&lt;/li&gt;
&lt;li&gt;客户端主动从 NAT 设备获取公有 IP 地址，然后自己建⽴端口映射条目，然后用这个条目对外通信，就不需要 NAT 设备来进行转换了&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;icmp&#34;&gt;ICMP&lt;/h3&gt;
&lt;p&gt;ICMP 全称是 Internet Control Message Protocol，也就是互联网控制报文协议。&lt;/p&gt;
&lt;p&gt;ICMP 主要的功能包括：确认 IP 包是否成功送达目标地址、报告发送过程中 IP 包被废弃的原因和改善网络设置等。&lt;/p&gt;
&lt;p&gt;在 IP 通信中如果某个 IP 包因为某种原因未能达到目标地址，那么这个具体的原因将由 ICMP 负责通知。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C03-ip%E5%8D%8F%E8%AE%AE/image-20220718195953248.png&#34;
	width=&#34;966&#34;
	height=&#34;705&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C03-ip%E5%8D%8F%E8%AE%AE/image-20220718195953248_hu91e7a1518b7f78f09235a8e58079c93f_83828_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C03-ip%E5%8D%8F%E8%AE%AE/image-20220718195953248_hu91e7a1518b7f78f09235a8e58079c93f_83828_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;ICMP报文类型&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;137&#34;
		data-flex-basis=&#34;328px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C03-ip%E5%8D%8F%E8%AE%AE/image-20220718200110669.png&#34;
	width=&#34;1472&#34;
	height=&#34;1388&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C03-ip%E5%8D%8F%E8%AE%AE/image-20220718200110669_hu505635c5b7bb1109541094f54ae41f26_193821_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C03-ip%E5%8D%8F%E8%AE%AE/image-20220718200110669_hu505635c5b7bb1109541094f54ae41f26_193821_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;ICM报文&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;106&#34;
		data-flex-basis=&#34;254px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;ping工作原理&#34;&gt;Ping工作原理&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C03-ip%E5%8D%8F%E8%AE%AE/image-20220718200252435.png&#34;
	width=&#34;2840&#34;
	height=&#34;1544&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C03-ip%E5%8D%8F%E8%AE%AE/image-20220718200252435_hu885992200f332d4cef4a175edc4f7c5c_355748_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C03-ip%E5%8D%8F%E8%AE%AE/image-20220718200252435_hu885992200f332d4cef4a175edc4f7c5c_355748_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;Ping工作流程&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;183&#34;
		data-flex-basis=&#34;441px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;traceroute命令&#34;&gt;traceroute命令&lt;/h3&gt;
&lt;p&gt;有⼀款充分利用 ICMP 差错报文类型的应用叫做 traceroute （在UNIX、MacOS中是这个命令，而在Windows中对等的命令叫做 tracert ）&lt;/p&gt;
&lt;h4 id=&#34;作用&#34;&gt;作用&lt;/h4&gt;
&lt;p&gt;traceroute 的第⼀个作用就是故意设置特殊的 TTL，来追踪去往目的地时沿途经过的路由器。&lt;/p&gt;
&lt;p&gt;traceroute 的参数指向某个目的 IP 地址：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;traceout 192.168.1.100
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h4 id=&#34;原理&#34;&gt;原理&lt;/h4&gt;
&lt;p&gt;它的原理就是利用 IP 包的⽣存期限 从 1 开始按照顺序递增的同时发送 UDP 包，强制接收 ICMP 超时消息的⼀种方法。&lt;/p&gt;
&lt;p&gt;比如，将 TTL 设置 为 1 ，则遇到第⼀个路由器，就牺牲了，接着返回 ICMP 差错报文网络包，类型是时间超时。&lt;/p&gt;
&lt;p&gt;接下来将 TTL 设置为 2 ，第⼀个路由器过了，遇到第⼆个路由器也牺牲了，也同时返回了 ICMP 差错报文数据包，如此往复，直到到达目的主机。&lt;/p&gt;
&lt;p&gt;这样的过程，traceroute 就可以拿到了所有的路由器 IP。当然有的路由器根本就不会返回这个 ICMP，所以对于有的公网地址，是看不到中间经过的路由的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;发送方如何知道发出的 UDP 包是否到达了目的主机呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;traceroute 在发送 UDP 包时，会填入⼀个不可能的端口号值作为 UDP 目标端口号（大于 3000 ）。当目的主机，收到 UDP 包后，会返回 ICMP 差错报文消息，但这个差错报文消息的类型是「端口不可达」。所以，当差错报文类型是端口不可达时，说明发送方发出的 UDP 包到达了目的主机。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>IO模型分析与对比</title>
        <link>https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/io%E6%A8%A1%E5%9E%8B%E5%88%86%E6%9E%90%E4%B8%8E%E5%AF%B9%E6%AF%94/</link>
        <pubDate>Fri, 24 Jun 2022 13:45:35 +0800</pubDate>
        
        <guid>https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/io%E6%A8%A1%E5%9E%8B%E5%88%86%E6%9E%90%E4%B8%8E%E5%AF%B9%E6%AF%94/</guid>
        <description>&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://segmentfault.com/a/1190000003063859#articleHeader17&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Linux IO模式及 select、poll、epoll详解 - SegmentFault 思否&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/272891398&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;一文搞懂select、poll和epoll区别 - 知乎 (zhihu.com)&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;一些前置概念&#34;&gt;一些前置概念&lt;/h2&gt;
&lt;h3 id=&#34;用户空间与内核空间&#34;&gt;用户空间与内核空间&lt;/h3&gt;
&lt;p&gt;现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。&lt;/p&gt;
&lt;h3 id=&#34;进程阻塞&#34;&gt;进程阻塞&lt;/h3&gt;
&lt;p&gt;正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态。&lt;code&gt;当进程进入阻塞状态，是不占用CPU资源的&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;文件描述符-fd&#34;&gt;文件描述符 fd&lt;/h3&gt;
&lt;p&gt;文件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。&lt;/p&gt;
&lt;p&gt;文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。&lt;/p&gt;
&lt;h3 id=&#34;缓存-io&#34;&gt;缓存 I/O&lt;/h3&gt;
&lt;p&gt;缓存 I/O 又被称作标准 I/O，大多数文件系统的默认 I/O 操作都是缓存 I/O。在 Linux 的缓存 I/O 机制中，操作系统会将 I/O 的数据缓存在文件系统的页缓存（ page cache ）中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缓存 I/O 的缺点：&lt;/strong&gt;
数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，这些数据拷贝操作所带来的 CPU 以及内存开销是非常大的&lt;/p&gt;
&lt;h2 id=&#34;io-模式&#34;&gt;I/O 模式&lt;/h2&gt;
&lt;p&gt;对于一次IO访问（以read举例），数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。所以说，当一个read操作发生时，它会经历两个阶段：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;等待数据准备 (Waiting for the data to be ready)&lt;/li&gt;
&lt;li&gt;将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;正是因为这两个阶段，linux系统产生了下面五种网络模式的方案。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;阻塞 I/O（blocking IO）&lt;/li&gt;
&lt;li&gt;非阻塞 I/O（nonblocking IO）&lt;/li&gt;
&lt;li&gt;I/O 多路复用（ IO multiplexing）&lt;/li&gt;
&lt;li&gt;信号驱动 I/O（ signal driven IO）&lt;/li&gt;
&lt;li&gt;异步 I/O（asynchronous IO）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;阻塞-ioblocking-io&#34;&gt;阻塞 I/O（blocking IO）&lt;/h3&gt;
&lt;p&gt;在linux中，默认情况下所有的socket都是blocking，一个典型的读操作流程大概是这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/io%E6%A8%A1%E5%9E%8B%E5%88%86%E6%9E%90%E4%B8%8E%E5%AF%B9%E6%AF%94/bio.png&#34;
	width=&#34;552&#34;
	height=&#34;331&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/io%E6%A8%A1%E5%9E%8B%E5%88%86%E6%9E%90%E4%B8%8E%E5%AF%B9%E6%AF%94/bio_huc5d37df4b38ee3db2ba7c889e6af7011_57429_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/io%E6%A8%A1%E5%9E%8B%E5%88%86%E6%9E%90%E4%B8%8E%E5%AF%B9%E6%AF%94/bio_huc5d37df4b38ee3db2ba7c889e6af7011_57429_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;blocking IO&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;166&#34;
		data-flex-basis=&#34;400px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据（对于网络IO来说，很多时候数据在一开始还没有到达。比如，还没有收到一个完整的UDP包。这个时候kernel就要等待足够的数据到来）。这个过程需要等待，也就是说数据被拷贝到操作系统内核的缓冲区中是需要一个过程的。而在用户进程这边，整个进程会被阻塞（当然，是进程自己选择的阻塞）。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;所以，blocking IO的特点就是在IO执行的两个阶段都被block了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;非阻塞-iononblocking-io&#34;&gt;非阻塞 I/O（nonblocking IO）&lt;/h3&gt;
&lt;p&gt;linux下，可以通过设置socket使其变为non-blocking。当对一个non-blocking socket执行读操作时，流程是这个样子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/io%E6%A8%A1%E5%9E%8B%E5%88%86%E6%9E%90%E4%B8%8E%E5%AF%B9%E6%AF%94/nio.png&#34;
	width=&#34;603&#34;
	height=&#34;333&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/io%E6%A8%A1%E5%9E%8B%E5%88%86%E6%9E%90%E4%B8%8E%E5%AF%B9%E6%AF%94/nio_hu95f0bfd8ac579c5e5f7fba016d9afeb7_84999_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/io%E6%A8%A1%E5%9E%8B%E5%88%86%E6%9E%90%E4%B8%8E%E5%AF%B9%E6%AF%94/nio_hu95f0bfd8ac579c5e5f7fba016d9afeb7_84999_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;nonblocking IO&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;181&#34;
		data-flex-basis=&#34;434px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;所以，nonblocking IO的特点是用户进程需要&lt;strong&gt;不断的主动询问&lt;/strong&gt;kernel数据好了没有。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;io-多路复用-io-multiplexing&#34;&gt;I/O 多路复用（ IO multiplexing）&lt;/h3&gt;
&lt;p&gt;IO multiplexing就是我们说的select，poll，epoll，有些地方也称这种IO方式为event driven IO。select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select，poll，epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/io%E6%A8%A1%E5%9E%8B%E5%88%86%E6%9E%90%E4%B8%8E%E5%AF%B9%E6%AF%94/io-multi.png&#34;
	width=&#34;609&#34;
	height=&#34;326&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/io%E6%A8%A1%E5%9E%8B%E5%88%86%E6%9E%90%E4%B8%8E%E5%AF%B9%E6%AF%94/io-multi_huf8e7078d51edfb1acbaeb5699c79fdf4_77265_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/io%E6%A8%A1%E5%9E%8B%E5%88%86%E6%9E%90%E4%B8%8E%E5%AF%B9%E6%AF%94/io-multi_huf8e7078d51edfb1acbaeb5699c79fdf4_77265_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;IO multiplexing&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;186&#34;
		data-flex-basis=&#34;448px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;当用户进程调用了select，那么整个进程会被block&lt;/code&gt;，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;所以，I/O 多路复用的特点是通过一种机制一个进程能同时等待多个文件描述符，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，select()函数就可以返回。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个图和blocking IO的图其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个system call (select 和 recvfrom)，而blocking IO只调用了一个system call (recvfrom)。但是，用select的优势在于它可以同时处理多个connection。&lt;/p&gt;
&lt;p&gt;所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。）&lt;/p&gt;
&lt;p&gt;在IO multiplexing Model中，实际中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。&lt;/p&gt;
&lt;h3 id=&#34;异步-ioasynchronous-io&#34;&gt;异步 I/O（asynchronous IO）&lt;/h3&gt;
&lt;p&gt;inux下的asynchronous IO其实用得很少。先看一下它的流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/io%E6%A8%A1%E5%9E%8B%E5%88%86%E6%9E%90%E4%B8%8E%E5%AF%B9%E6%AF%94/async-io.png&#34;
	width=&#34;572&#34;
	height=&#34;324&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/io%E6%A8%A1%E5%9E%8B%E5%88%86%E6%9E%90%E4%B8%8E%E5%AF%B9%E6%AF%94/async-io_huc529fa909bb0db7279e58b28456e00fe_62560_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/io%E6%A8%A1%E5%9E%8B%E5%88%86%E6%9E%90%E4%B8%8E%E5%AF%B9%E6%AF%94/async-io_huc529fa909bb0db7279e58b28456e00fe_62560_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;asynchronous IO&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;176&#34;
		data-flex-basis=&#34;423px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。&lt;/p&gt;
&lt;h3 id=&#34;信号驱动-io-signal-driven-io&#34;&gt;信号驱动 I/O（ signal driven IO）&lt;/h3&gt;
&lt;p&gt;在信号驱动式I/O模型中，应用程序使用套接口进行信号驱动I/O，并安装一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个SIGIO信号，可以在信号处理函数中调用I/O操作函数处理数据&lt;/p&gt;
&lt;p&gt;异步 I/O与信号驱动 I/O的主要区别在于：&lt;strong&gt;信号驱动I/O是由内核通知应用程序何时启动一个I/O操作，而异步I/O模型是由内核通知应用程序I/O操作何时完成&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;优点：线程并没有在等待数据时被阻塞，可以提高资源的利用率&lt;/p&gt;
&lt;p&gt;缺点：信号I/O在大量IO操作时可能会因为信号队列溢出导致没法通知。&lt;/p&gt;
&lt;p&gt;信号驱动I/O尽管对于处理UDP套接字来说有用，即这种信号通知意味着到达一个数据报，或者返回一个异步错误。但是，对于TCP而言，信号驱动的I/O方式近乎无用，因为导致这种通知的条件为数众多，每一个来进行判别会消耗很大资源。&lt;/p&gt;
&lt;h3 id=&#34;io模式总结&#34;&gt;IO模式总结&lt;/h3&gt;
&lt;h4 id=&#34;blocking和non-blocking的区别&#34;&gt;blocking和non-blocking的区别&lt;/h4&gt;
&lt;p&gt;调用blocking IO会一直block住对应的进程直到操作完成，而 non-blocking IO在 kernel 还未准备好数据的情况下会立刻返回。&lt;/p&gt;
&lt;h4 id=&#34;synchronous-io和asynchronous-io的区别&#34;&gt;synchronous IO和asynchronous IO的区别&lt;/h4&gt;
&lt;p&gt;在说明synchronous IO和asynchronous IO的区别之前，需要先给出两者的定义。POSIX的定义是这样子的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A synchronous I/O operation causes the requesting process to be blocked until that I/O operation completes;&lt;/li&gt;
&lt;li&gt;An asynchronous I/O operation does not cause the requesting process to be blocked;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;两者的区别就在于synchronous IO做”IO operation”的时候会将process阻塞。按照这个定义，之前所述的blocking IO，non-blocking IO，IO multiplexing都属于synchronous IO。&lt;/p&gt;
&lt;p&gt;这里有个非常“狡猾”的地方，定义中所指的”IO operation”是指真实的IO操作，就是例子中的recvfrom这个system call。non-blocking IO在执行recvfrom这个system call的时候，如果kernel的数据没有准备好，这时候不会block进程。但是，当kernel中数据准备好的时候，recvfrom会将数据从kernel拷贝到用户内存中，这个时候进程是被block了，在这段时间内，进程是被block的。&lt;/p&gt;
&lt;p&gt;而asynchronous IO则不一样，当进程发起IO 操作之后，就直接返回再也不理睬了，直到kernel发送一个信号，告诉进程说IO完成。在这整个过程中，进程完全没有被block。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同步IO和异步IO的区别就在于：数据拷贝的时候进程是否阻塞！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;阻塞IO和非阻塞IO的区别就在于：应用程序的调用是否立即返回！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;各个IO Model的比较如图所示：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/io%E6%A8%A1%E5%9E%8B%E5%88%86%E6%9E%90%E4%B8%8E%E5%AF%B9%E6%AF%94/comparison.png&#34;
	width=&#34;614&#34;
	height=&#34;327&#34;
	srcset=&#34;https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/io%E6%A8%A1%E5%9E%8B%E5%88%86%E6%9E%90%E4%B8%8E%E5%AF%B9%E6%AF%94/comparison_hu9340ee179b4f5f73a447f871db282220_91658_480x0_resize_box_3.png 480w, https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/io%E6%A8%A1%E5%9E%8B%E5%88%86%E6%9E%90%E4%B8%8E%E5%AF%B9%E6%AF%94/comparison_hu9340ee179b4f5f73a447f871db282220_91658_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;IO Model 对比&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;187&#34;
		data-flex-basis=&#34;450px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;通过上面的图片，可以发现non-blocking IO和asynchronous IO的区别还是很明显的。在non-blocking IO中，虽然进程大部分时间都不会被block，但是它仍然要求进程去主动的check，并且当数据准备完成以后，也需要进程主动的再次调用recvfrom来将数据拷贝到用户内存。而asynchronous IO则完全不同。它就像是用户进程将整个IO操作交给了他人（kernel）完成，然后他人做完后发信号通知。在此期间，用户进程不需要去检查IO操作的状态，也不需要主动的去拷贝数据。&lt;/p&gt;
&lt;h2 id=&#34;io-多路复用之selectpollepollkqueue详解&#34;&gt;I/O 多路复用之select、poll、epoll、kqueue详解&lt;/h2&gt;
&lt;p&gt;select，poll，epoll，kqueue都是IO多路复用的机制。I/O多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。（这里啰嗦下）&lt;/p&gt;
&lt;h3 id=&#34;select&#34;&gt;select&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;select&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fd_set&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;readfds&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fd_set&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;writefds&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fd_set&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;exceptfds&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;timeval&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;timeout&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;//	writefds、readfds、和exceptfds　是三个指针，分别记录了读、写和 except 事件描述符
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;//	进程调用select的时候会把这三个指针传递进函数并阻塞直到有就绪事件
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;//	如果有就绪的事件对应的描述符，会对其设置就绪，select 返回后进程可以遍历所有的描述符，找到就绪的进行处理。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;select 函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。调用后select函数会阻塞，直到有描述副就绪（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以 通过遍历fdset，来找到就绪的描述符。&lt;/p&gt;
&lt;p&gt;select目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点。select的一 个缺点在于单个进程能够监视的文件描述符的数量&lt;strong&gt;存在最大限制&lt;/strong&gt;，在Linux上一般为1024，可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但 是这样也会造成效率的降低。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;调用过程&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用copy_from_user从用户空间拷贝fd_set到内核空间&lt;/li&gt;
&lt;li&gt;注册回调函数&lt;code&gt;__pollwait&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;遍历所有fd，调用其对应的poll方法（对于socket，这个poll方法是sock_poll，sock_poll根据情况会调用到tcp_poll，udp_poll或datagram_poll），以tcp_poll为例，核心实现就是&lt;code&gt;__pollwait&lt;/code&gt;，即上面注册的回调函数。&lt;code&gt;__pollwait&lt;/code&gt;，就是把current（当前进程）挂到设备的等待队列，不同设备有不同等待队列，如tcp_poll的等待队列是sk-&amp;gt;sk_sleep（把进程挂到等待队列中并不代表进程已睡眠）。在设备收到一条消息（网络设备）或填写完文件数据（磁盘设备）后，会唤醒设备等待队列上睡眠的进程，这时current便被唤醒。&lt;/li&gt;
&lt;li&gt;poll方法返回时会返回一个描述读写操作是否就绪的mask掩码，根据这个mask掩码给fd_set赋值&lt;/li&gt;
&lt;li&gt;若遍历完所有fd，还没返回一个可读写的mask掩码，则调schedule_timeout是调用select的进程（也就是current）进入睡眠。当设备驱动发生自身资源可读写后，会唤醒其等待队列上睡眠的进程。若超过一定超时时间（schedule_timeout指定），还没人唤醒，则调用select的进程会重新被唤醒获得CPU，进而重新遍历fd，判断有无就绪的fd&lt;/li&gt;
&lt;li&gt;把fd_set从内核空间拷贝到用户空间&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;内核需要将消息传递到用户空间，都需要内核拷贝动作。需要维护一个用来存放大量fd的数据结构，使得用户空间和内核空间在传递该结构时复制开销大。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每次调用select，都需把fd集合从用户态拷贝到内核态，fd很多时开销就很大&lt;/li&gt;
&lt;li&gt;同时每次调用select都需在内核遍历传递进来的所有fd，fd很多时开销就很大&lt;/li&gt;
&lt;li&gt;select支持的文件描述符数量太小了，默认最大支持1024个&lt;/li&gt;
&lt;li&gt;主动轮询效率很低&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;poll&#34;&gt;poll&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;poll&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;pollfd&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fds&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nfds&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;timeout&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;不同与select使用三个位图来表示三个fdset的方式，poll使用一个 pollfd的指针实现。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;pollfd&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;cm&#34;&gt;/* 文件描述符 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;short&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;events&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;cm&#34;&gt;/* 要监视的事件 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;short&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;revents&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;cm&#34;&gt;/* 发生的事件 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;pollfd结构包含了要监视的event和发生的event，不再使用select“参数-值”传递的方式。同时，pollfd并没有最大数量限制（但是数量过大后性能也是会下降）。 和select函数一样，poll返回后，需要轮询pollfd来获取就绪的描述符。&lt;/p&gt;
&lt;p&gt;poll和select同样存在一个缺点就是，包含大量文件描述符的数组被整体复制于用户态和内核的地址空间之间，而不论这些文件描述符是否就绪，它的开销随着文件描述符数量的增加而线性增大。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;它将用户传入的数组拷贝到内核空间&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;然后查询每个fd对应的设备状态：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;如果设备就绪 在设备等待队列中加入一项继续遍历&lt;/li&gt;
&lt;li&gt;若遍历完所有fd后，都没发现就绪的设备 挂起当前进程，直到设备就绪或主动超时，被唤醒后它又再次遍历fd。这个过程经历多次无意义的遍历。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;从上面看，select和poll都需要在返回后，&lt;code&gt;通过遍历文件描述符来获取已经就绪的socket&lt;/code&gt;。事实上，同时连接的大量客户端在一时刻可能只有很少的处于就绪状态，因此随着监视的描述符数量的增长，其效率也会线性下降。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;epoll&#34;&gt;epoll&lt;/h3&gt;
&lt;p&gt;epoll是在2.6内核中提出的，是之前的select和poll的增强版本。相对于select和poll来说，epoll更加灵活，没有描述符限制。epoll使用一个文件描述符管理多个描述符，&lt;strong&gt;将用户关心的文件描述符的事件存放到内核的一个事件表中&lt;/strong&gt;，用户每次新增和删除监听事件都通过内核中的这个事件表，这样在用户空间和内核空间的copy只需一次。&lt;strong&gt;select 和 poll 都需要把fd表或者数据结构拷贝到内核态再从内核态取出。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;epoll模型修改主动轮询为被动通知，当有事件发生时，被动接收通知。所以epoll模型注册套接字后，主程序可做其他事情，当事件发生时，接收到通知后再去处理。可理解为&lt;strong&gt;event poll&lt;/strong&gt;，epoll会把哪个流发生哪种I/O事件通知我们。所以epoll是事件驱动（每个事件关联fd），此时我们对这些流的操作都是有意义的。复杂度也降到O(1)。&lt;/p&gt;
&lt;h4 id=&#34;epoll操作过程&#34;&gt;epoll操作过程&lt;/h4&gt;
&lt;p&gt;epoll操作过程需要三个接口，分别如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;epoll_create&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;；&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//创建一个epoll的句柄（epfd），size用来告诉内核这个监听的数目一共有多大
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;epoll_ctl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;epfd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;op&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;epoll_event&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;event&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;；&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 增删改某个fd的某个事件
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;epoll_wait&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;epfd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;epoll_event&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;events&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;maxevents&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;timeout&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;// 等待 epfd 上的事件
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;1. int epoll_create(int size);&lt;/strong&gt;
创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大，这个参数不同于select()中的第一个参数，给出最大监听的fd+1的值，&lt;code&gt;参数size并不是限制了epoll所能监听的描述符最大个数，只是对内核初始分配内部数据结构的一个建议&lt;/code&gt;。
当创建好epoll句柄后，它就会占用一个fd值，在linux下如果查看/proc/进程id/fd/，是能够看到这个fd的，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；&lt;/strong&gt;
函数是对指定描述符fd执行op操作。
- epfd：是epoll_create()的返回值。
- op：表示op操作，用三个宏来表示：添加EPOLL_CTL_ADD，删除EPOLL_CTL_DEL，修改EPOLL_CTL_MOD。分别添加、删除和修改对fd的监听事件。
- fd：是需要监听的fd（文件描述符）
- epoll_event：是告诉内核需要监听什么事，struct epoll_event结构如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;epoll_event&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;__uint32_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;events&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;  &lt;span class=&#34;cm&#34;&gt;/* Epoll events */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;epoll_data_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;  &lt;span class=&#34;cm&#34;&gt;/* User data variable */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;//events可以是以下几个宏的集合：
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;EPOLLIN&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;：表示对应的文件描述符可以读（包括对端&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;SOCKET正常关闭&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;）；&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;EPOLLOUT&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;：表示对应的文件描述符可以写；&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;EPOLLPRI&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;EPOLLERR&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;：表示对应的文件描述符发生错误；&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;EPOLLHUP&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;：表示对应的文件描述符被挂断；&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;EPOLLET&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;：&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;将&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;EPOLL设为边缘触发&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Edge&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Triggered&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;模式，这是相对于水平触发&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Level&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Triggered&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;来说的。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;EPOLLONESHOT&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;socket的话&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;，需要再次把这个&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;socket加入到EPOLL队列里&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;3. int epoll_wait(int epfd,  struct epoll_event  * events,  int maxevents,  int timeout);&lt;/strong&gt;
等待epfd上的io事件，最多返回maxevents个事件。
参数events用来从内核得到事件的集合，maxevents告知内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size，参数timeout是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。&lt;/p&gt;
&lt;h4 id=&#34;工作模式&#34;&gt;工作模式&lt;/h4&gt;
&lt;p&gt;epoll对文件描述符的操作有两种模式：&lt;strong&gt;LT（level trigger）&lt;strong&gt;和&lt;/strong&gt;ET（edge trigger）&lt;/strong&gt;。LT模式是默认模式，LT模式与ET模式的区别如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LT模式，默认的模式（水平触发）&lt;/strong&gt;：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，&lt;code&gt;应用程序可以不立即处理该事件&lt;/code&gt;。下次调用epoll_wait时，会再次响应应用程序并通知此事件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ET模式，“高速”模式（边缘触发）&lt;/strong&gt;：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，&lt;code&gt;应用程序必须立即处理该事件&lt;/code&gt;。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LT模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;LT(level triggered)是缺省的工作方式，并且同时支持block和no-block socket.在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ET模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ET(edge-triggered)是高速工作方式，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了(比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一个EWOULDBLOCK 错误）。但是请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once)&lt;/p&gt;
&lt;p&gt;ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;假如有这样一个例子：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;我们已经把一个用来从管道中读取数据的文件句柄(RFD)添加到epoll描述符&lt;/li&gt;
&lt;li&gt;这个时候从管道的另一端被写入了2KB的数据&lt;/li&gt;
&lt;li&gt;调用epoll_wait(2)，并且它会返回RFD，说明它已经准备好读取操作&lt;/li&gt;
&lt;li&gt;然后我们读取了1KB的数据&lt;/li&gt;
&lt;li&gt;调用epoll_wait(2)&amp;hellip;&amp;hellip;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;LT模式：&lt;/strong&gt;
如果是LT模式，那么在第5步调用epoll_wait(2)之后，仍然能受到通知。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ET模式：&lt;/strong&gt;
如果我们在第1步将RFD添加到epoll描述符的时候使用了EPOLLET标志，那么在第5步调用epoll_wait(2)之后将有可能会挂起，因为剩余的数据还存在于文件的输入缓冲区内，而且数据发出端还在等待一个针对已经发出数据的反馈信息。只有在监视的文件句柄上发生了某个事件的时候 ET 工作模式才会汇报事件。因此在第5步的时候，调用者可能会放弃等待仍在存在于文件输入缓冲区内的剩余数据。&lt;/p&gt;
&lt;p&gt;当使用epoll的ET模型来工作时，当产生了一个EPOLLIN事件后，
读数据的时候需要考虑的是当recv()返回的大小如果等于请求的大小，那么很有可能是缓冲区还有数据未读完，也意味着该次事件还没有处理完，所以还需要再次读取：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;buflen&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;recv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;activeevents&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;].&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;buf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;sizeof&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buflen&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 由于是非阻塞的模式,所以当errno为EAGAIN时,表示当前缓冲区已无数据可读
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 在这里就当作是该次事件已处理处.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;errno&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;EAGAIN&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;break&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buflen&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     &lt;span class=&#34;c1&#34;&gt;// 这里表示对端的socket已正常关闭.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buflen&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;sizeof&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;n&#34;&gt;rs&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;   &lt;span class=&#34;c1&#34;&gt;// 需要再次读取
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;n&#34;&gt;rs&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Linux中的EAGAIN含义&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Linux环境下开发经常会碰到很多错误(设置errno)，其中EAGAIN是其中比较常见的一个错误(比如用在非阻塞操作中)。
从字面上来看，是提示再试一次。这个错误经常出现在当应用程序进行一些非阻塞(non-blocking)操作(对文件或socket)的时候。&lt;/p&gt;
&lt;p&gt;例如，以 O_NONBLOCK的标志打开文件/socket/FIFO，如果你连续做read操作而没有数据可读。此时程序不会阻塞起来等待数据准备就绪返回，read函数会返回一个错误EAGAIN，提示你的应用程序现在没有数据可读请稍后再试。
又例如，当一个系统调用(比如fork)因为没有足够的资源(比如虚拟内存)而执行失败，返回EAGAIN提示其再调用一次(也许下次就能成功)。&lt;/p&gt;
&lt;h4 id=&#34;优点&#34;&gt;优点&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;没有最大并发连接的限制，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）&lt;/li&gt;
&lt;li&gt;效率提升，不是轮询，不会随着FD数目的增加效率下降。只有活跃可用的FD才会调用callback函数 即Epoll最大的优点就在于它只关心“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll&lt;/li&gt;
&lt;li&gt;内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销。&lt;/li&gt;
&lt;li&gt;epoll通过内核和用户空间共享一块内存来实现的&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;kqueue&#34;&gt;kqueue&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;kqueue和epoll一样，都是用来替换select和poll的。不同的是kqueue被用在FreeBSD,NetBSD, OpenBSD, DragonFly BSD, 和 macOS中。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;kqueue 不仅能够处理文件描述符事件，还可以用于各种其他通知，例如文件修改监视、信号、异步 I/O 事件 (AIO)、子进程状态更改监视和支持纳秒级分辨率的计时器，此外kqueue提供了一种方式除了内核提供的事件之外，还可以使用用户定义的事件。&lt;/p&gt;
&lt;p&gt;kqueue提供了两个API，第一个是构建kqueue：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;kqueue&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;第二个是创建kevent:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;kevent&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;kq&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;kevent&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;changelist&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nchanges&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;kevent&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;eventlist&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nevents&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;timespec&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;timeout&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;kevent中的第一个参数是要注册的kqueue，changelist是要监视的事件列表，nchanges表示要监听事件的长度，eventlist是kevent返回的事件列表,nevents表示要返回事件列表的长度，最后一个参数是timeout。&lt;/p&gt;
&lt;p&gt;除此之外，kqueue还有一个用来初始化kevent结构体的EV_SET宏：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;EV_SET&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;kev&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ident&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;filter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;flags&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fflags&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;udata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;
&lt;p&gt;在 select/poll中，进程只有在调用一定的方法后，内核才对所有监视的文件描述符进行扫描，而&lt;strong&gt;epoll事先通过epoll_ctl()来注册一 个文件描述符，一旦基于某个文件描述符就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，当进程调用epoll_wait() 时便得到通知&lt;/strong&gt;。(&lt;code&gt;此处去掉了遍历文件描述符，而是通过监听回调的的机制&lt;/code&gt;。这正是epoll的魅力所在。)&lt;/p&gt;
&lt;p&gt;select，poll，epoll都是IO多路复用机制，即可以监视多个描述符，一旦某个描述符就绪（读或写就绪），能够通知程序进行相应读写操作。 但select，poll，epoll本质上都是&lt;strong&gt;同步I/O&lt;/strong&gt;，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll其实也需要调用epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。这就是回调机制带来的性能提升。&lt;/li&gt;
&lt;li&gt;select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次，而epoll只要一次拷贝，而且把current往等待队列上挂也只挂一次（在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内部定义的等待队列）。这也能节省不少的开销。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;如果没有大量的idle -connection或者dead-connection，epoll的效率并不会比select/poll高很多，但是当遇到大量的idle- connection，就会发现epoll的效率大大高于select/poll。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        </item>
        
    </channel>
</rss>
