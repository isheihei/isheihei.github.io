<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content='TCP协议知识总结：三次握手、四次挥手、流量控制、拥塞控制'><title>网络02-TCP协议</title>

<link rel='canonical' href='https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/'>

<link rel="stylesheet" href="/scss/style.min.d9e0562edde3d2bdf9d3d81365095a29d062ddaaa5d671f22168e57dfdb18b4f.css">
<meta property='og:title' content='网络02-TCP协议'>
<meta property='og:description' content='TCP协议知识总结：三次握手、四次挥手、流量控制、拥塞控制'>
<meta property='og:url' content='https://isheihei.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/'>
<meta property='og:site_name' content='isheihei&#39;s blog'>
<meta property='og:type' content='article'><meta property='article:section' content='Posts' /><meta property='article:tag' content='网络' /><meta property='article:published_time' content='2022-07-18T00:04:43&#43;08:00'/><meta property='article:modified_time' content='2022-07-18T00:04:43&#43;08:00'/>
<meta name="twitter:title" content="网络02-TCP协议">
<meta name="twitter:description" content="TCP协议知识总结：三次握手、四次挥手、流量控制、拥塞控制">
    
    
    <link rel="shortcut icon" href= "/img/favicon_hu2f307a5f23288c798230c92f583cd3bd_467065_32x0_resize_box_3.png" />

    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="切换菜单">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/">
                
                    
                    
                    
                        
                        <img src="/img/avatar_hu2f307a5f23288c798230c92f583cd3bd_467065_300x0_resize_box_3.png" width="300"
                            height="300" class="site-logo" loading="lazy" alt="Avatar">
                    
                
                </a>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/">isheihei&#39;s blog</a></h1>
            <h2 class="site-description">兼听则明，三思而后行。</h2>
        </div>
    </header><ol class="menu" id="main-menu">
        
        
        

        <li >
            <a href='/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>主页</span>
            </a>
        </li>
        
        

        <li >
            <a href='/about/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="7" r="4" />
  <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" />
</svg>



                
                <span>关于</span>
            </a>
        </li>
        
        

        <li >
            <a href='/archives/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>归档</span>
            </a>
        </li>
        
        

        <li >
            <a href='/search/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>Search</span>
            </a>
        </li>
        
        

        <li >
            <a href='/links/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5" />
  <path d="M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5" />
</svg>



                
                <span>Links</span>
            </a>
        </li>
        

        <div class="menu-bottom-section">
            
            
                <li id="dark-mode-toggle">
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                    <span>暗色模式</span>
                </li>
            
        </div>
    </ol>
</aside>
<main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" style="background-color: #2a9d8f; color: #fff;">
                计算机基础
            </a>
        
    </header>
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/">网络02-TCP协议</a>
        </h2>
    
        
        <h3 class="article-subtitle">
            TCP协议知识总结：三次握手、四次挥手、流量控制、拥塞控制
        </h3>
        
    </div>

    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">Jul 18, 2022</time>
            </div>
        

        
    </footer>
    

    
</div>
</header>

    <section class="article-content">
    
    
    <h2 id="什么是tcp">什么是TCP</h2>
<p>IP 层是「不可靠」的，它不保证网络包的交付、不保证网络包的按序交付、也不保证网络包中的数据的完整性。</p>
<p>如果需要保障网络数据包的可靠性，那么就需要由上层（传输层）的 TCP 协议来负责。因为 TCP 是⼀个⼯作在传输层的可靠数据传输的服务，它能确保接收端接收的网络包是无损坏、无间隔、非冗余和按序的。</p>
<p>TCP 是面向连接的、可靠的、基于字节流的传输层通信协议。</p>
<ul>
<li>面向连接：⼀定是「⼀对⼀」才能连接，不能像 UDP 协议可以⼀个主机同时向多个主机发送消息，也就是⼀对多是无法做到的；</li>
<li>可靠的：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证⼀个报文⼀定能够到达接收端；</li>
<li>字节流：消息是「没有边界」的，所以无论我们消息有多大都可以进行传输。并且消息是「有序的」，当「前⼀个」消息没有收到的时候，即使它先收到了后面的字节，那么也不能扔给应用层去处理，同时对「重复」的报文会⾃动丢弃。</li>
</ul>
<p>TCP 四元组可以唯⼀的确定⼀个连接，四元组包括如下：</p>
<ul>
<li>源地址</li>
<li>源端口</li>
<li>目的地址</li>
<li>目的端口</li>
</ul>
<p><img src="/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718202454871.png"
	width="821"
	height="228"
	srcset="/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718202454871_hu5382c26f3f67254d930af289186624bc_24142_480x0_resize_box_3.png 480w, /posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718202454871_hu5382c26f3f67254d930af289186624bc_24142_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="TCP四元组"
	
	
		class="gallery-image" 
		data-flex-grow="360"
		data-flex-basis="864px"
	
></p>
<p>源地址和目的地址的字段（32位）是在 <strong>IP 头部</strong> 中，作用是通过 IP 协议发送报文给对方主机。</p>
<p>源端口和目的端口的字段（16位）是在 <strong>TCP 头部</strong> 中，作用是告诉 TCP 协议应该把报文发给哪个进程。</p>
<h2 id="什么是tcp连接">什么是TCP连接</h2>
<p>简单来说就是，用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括Socket、序列号和窗口大小称为连接。</p>
<p>所以我们可以知道，建⽴⼀个 TCP 连接是需要客户端与服务器端达成上述三个信息的共识。</p>
<ul>
<li>Socket：由 IP 地址和端口号组成</li>
<li>序列号：用来解决乱序问题等</li>
<li>窗口大小：用来做流量控制</li>
</ul>
<h2 id="tcp-格式">TCP 格式</h2>
<p><img src="/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718201052747.png"
	width="1053"
	height="828"
	srcset="/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718201052747_hu143c1bfee3267be99575a2a0ea300bb4_85927_480x0_resize_box_3.png 480w, /posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718201052747_hu143c1bfee3267be99575a2a0ea300bb4_85927_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="TCP头部格式"
	
	
		class="gallery-image" 
		data-flex-grow="127"
		data-flex-basis="305px"
	
></p>
<p>序列号：在建⽴连接时由计算机生成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送⼀次数据，就「累加」⼀次该「数据字节数」的大小。用来解决网络包乱序问题。</p>
<p>确认应答号：指下⼀次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。用来解决不丢包的问题。</p>
<p>控制位：</p>
<ul>
<li>ACK：该位为 1 时，「确认应答」的字段变为有效，TCP 规定除了最初建⽴连接时的 SYN 包之外该位必须设置为 1 。</li>
<li>RST：该位为 1 时，表示 TCP 连接中出现异常必须强制断开连接。</li>
<li>SYN：该位为 1 时，表示希望建⽴连接，并在其「序列号」的字段进行序列号初始值的设定。</li>
<li>FIN：该位为 1 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 FIN 位为 1 的 TCP 段。</li>
</ul>
<h2 id="tcp-和-udp-区别">TCP 和 UDP 区别</h2>
<p>UDP 不提供复杂的控制机制，利用 IP 提供面向「无连接」的通信服务。UDP 协议真的非常简，头部只有 8 个字节（ 64 位），UDP 的头部格式如下：</p>
<p><img src="/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718203033417.png"
	width="783"
	height="468"
	srcset="/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718203033417_hub871f519644e7be8a66c647c49d6b24b_35126_480x0_resize_box_3.png 480w, /posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718203033417_hub871f519644e7be8a66c647c49d6b24b_35126_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="UDP头部"
	
	
		class="gallery-image" 
		data-flex-grow="167"
		data-flex-basis="401px"
	
></p>
<ul>
<li>目标和源端口：主要是告诉 UDP 协议应该把报文发给哪个进程。</li>
<li>包长度：该字段保存了 UDP 首部的长度跟数据的长度之和。</li>
<li>校验和：校验和是为了提供可靠的 UDP 首部和数据而设计。</li>
</ul>
<h3 id="区别">区别</h3>
<ol>
<li>
<p>连接：</p>
<ul>
<li>TCP 是面向连接的传输层协议，传输数据前先要建⽴连接。</li>
<li>UDP 是不需要连接，即刻传输数据。</li>
</ul>
</li>
<li>
<p>服务对象</p>
<ul>
<li>TCP 是⼀对⼀的两点服务，即⼀条连接只有两个端点。</li>
<li>UDP ⽀持⼀对⼀、⼀对多、多对多的交互通信</li>
</ul>
</li>
<li>
<p>可靠性</p>
<ul>
<li>TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按需到达。</li>
<li>UDP 是尽最大努⼒交付，不保证可靠交付数据。</li>
</ul>
</li>
<li>
<p>拥塞控制、流量控制</p>
<ul>
<li>TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。</li>
<li>UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。</li>
</ul>
</li>
<li>
<p>首部开销</p>
<ul>
<li>TCP 首部长度较长，会有⼀定的开销，首部在没有使用「选项」字段时是 20 个字节，如果使用了「选项」字段则会变长的。</li>
<li>UDP 首部只有 8 个字节，并且是固定不变的，开销较小。</li>
</ul>
</li>
<li>
<p>传输方式</p>
<ul>
<li>TCP 是流式传输，没有边界，但保证顺序和可靠。</li>
<li>UDP 是⼀个包⼀个包的发送，是有边界的，但可能会丢包和乱序。</li>
</ul>
</li>
<li>
<p>分片不同</p>
<ul>
<li>TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP数据包，如果中途丢失了⼀个分片，只需要传输丢失的这个分片。</li>
<li>UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层，但是如果中途丢了⼀个分片，在实现可靠传输的 UDP 时则就需要重传所有的数据包，这样传输效率非常差，所以通常 UDP 的报文应该小于 MTU。</li>
</ul>
</li>
</ol>
<h3 id="tcp-和-udp-应用场景">TCP 和 UDP 应用场景：</h3>
<ul>
<li>FTP 文件传输</li>
<li>HTTP / HTTPS</li>
</ul>
<p>由于 UDP 面向无连接，它可以随时发送数据，再加上UDP本身的处理既简单又高效，因此经常用于：</p>
<ul>
<li>包总量较少的通信，如 DNS 、 SNMP 等</li>
<li>视频、音频等多媒体通信</li>
<li>广播通信</li>
</ul>
<p>为什么 UDP 头部没有「首部长度」字段，而TCP 头部有「首部长度」字段呢？</p>
<p>原因是 TCP 有可变长的「选项」字段，而UDP 头部长度则是不会变化的，无需多⼀个字段去记录 UDP 的首部长度。</p>
<p>为什么 UDP 头部有「包长度」字段，而 TCP 头部则没有「包长度」字段呢？</p>
<p><img src="/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718205054689.png"
	width="1007"
	height="62"
	srcset="/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718205054689_hua2ef8e70df4b2dd128cdf2480b61936e_18068_480x0_resize_box_3.png 480w, /posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718205054689_hua2ef8e70df4b2dd128cdf2480b61936e_18068_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="TCP数据长度计算公式"
	
	
		class="gallery-image" 
		data-flex-grow="1624"
		data-flex-basis="3898px"
	
></p>
<p>其中 IP 总长度 和 IP 首部长度，在 IP 首部格式是已知的。TCP 首部长度，则是在 TCP 首部格式已知的，所以就可以求得 TCP 数据的长度。</p>
<p>因为为了网络设备硬件设计和处理方便，首部长度需要是 4 字节的整数倍。</p>
<h2 id="tcp连接">TCP连接</h2>
<p><a class="link" href="https://blog.csdn.net/qzcsu/article/details/72861891"  target="_blank" rel="noopener"
    >两张动图-彻底明白TCP的三次握手与四次挥手</a></p>
<p><img src="/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718205302134.png"
	width="813"
	height="678"
	srcset="/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718205302134_hu11f676b8277e0c8c3fcdd8bc60b2f4ee_63124_480x0_resize_box_3.png 480w, /posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718205302134_hu11f676b8277e0c8c3fcdd8bc60b2f4ee_63124_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="三次握手"
	
	
		class="gallery-image" 
		data-flex-grow="119"
		data-flex-basis="287px"
	
></p>
<ul>
<li>⼀开始，客户端和服务端都处于 CLOSED 状态。先是服务端主动监听某个端口，处于 LISTEN 状态</li>
</ul>
<p><img src="/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718205347523.png"
	width="1173"
	height="708"
	srcset="/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718205347523_huce689b0c8b97dd2dfea4e38658c95ca7_109592_480x0_resize_box_3.png 480w, /posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718205347523_huce689b0c8b97dd2dfea4e38658c95ca7_109592_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="三次握手-1"
	
	
		class="gallery-image" 
		data-flex-grow="165"
		data-flex-basis="397px"
	
></p>
<ul>
<li>客户端会随机初始化序号（ client_isn ），将此序号置于 TCP 首部的「序号」字段中，同时把 SYN 标志位置为 1 ，表示 SYN 报文。接着把第⼀个 SYN 报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于 SYN-SENT 状态。</li>
</ul>
<p><img src="/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718205410356.png"
	width="1188"
	height="708"
	srcset="/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718205410356_hu4cc1a77cd489dbcd6ce93358ba072968_134235_480x0_resize_box_3.png 480w, /posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718205410356_hu4cc1a77cd489dbcd6ce93358ba072968_134235_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="三次握手-2"
	
	
		class="gallery-image" 
		data-flex-grow="167"
		data-flex-basis="402px"
	
></p>
<ul>
<li>服务端收到客户端的 SYN 报文后，首先服务端也随机初始化⾃⼰的序号（ server_isn ），将此序号填入TCP 首部的「序号」字段中，其次把 TCP 首部的「确认应答号」字段填入 client_isn + 1 , 接着把 SYN和 ACK 标志位置为 1 。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 SYN-RCVD 状态。</li>
</ul>
<p><img src="/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718205435389.png"
	width="1188"
	height="708"
	srcset="/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718205435389_huf2b5cad342f679d42319469f44c59b63_114934_480x0_resize_box_3.png 480w, /posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718205435389_huf2b5cad342f679d42319469f44c59b63_114934_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="三次握手-3"
	
	
		class="gallery-image" 
		data-flex-grow="167"
		data-flex-basis="402px"
	
></p>
<ul>
<li>客户端收到服务端报文后，还要向服务端回应最后⼀个应答报文，首先该应答报文 TCP 首部 ACK 标志位置为 1 ，其次「确认应答号」字段填入 server_isn + 1 ，最后把报文发送给服务端，这次报文可以携带客户到服务器的数据，之后客户端处于 ESTABLISHED 状态。</li>
<li>服务器收到客户端的应答报文后，也进入 ESTABLISHED 状态。</li>
</ul>
<h3 id="如何在-linux-系统中查看-tcp-状态">如何在 Linux 系统中查看 TCP 状态？</h3>
<p><code>netstat -napt</code></p>
<p><img src="/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718210055179.png"
	width="1563"
	height="327"
	srcset="/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718210055179_hu1cd9efad8a5ad1fba906c8b4f73860e1_54379_480x0_resize_box_3.png 480w, /posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718210055179_hu1cd9efad8a5ad1fba906c8b4f73860e1_54379_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="netstat命令"
	
	
		class="gallery-image" 
		data-flex-grow="477"
		data-flex-basis="1147px"
	
></p>
<h3 id="为什么是三次握手不是两次四次">为什么是三次握手？不是两次、四次？</h3>
<p>以三个方面分析三次握手的原因</p>
<h4 id="三次握手才可以阻止重复历史连接的初始化-避免资源浪费主要原因">三次握手才可以阻止重复历史连接的初始化 避免资源浪费（主要原因）</h4>
<p>如果只有「两次握手」，当客户端的 SYN 请求连接在网络中阻塞，客户端没有接收到 ACK 报文，就会重新发送 SYN ，由于没有第三次握手，服务器不清楚客户端是否收到了自己发送的建⽴连接的 ACK 确认信号，所以每收到⼀个 SYN 就只能先主动建立⼀个连接，这会造成什么情况呢？</p>
<p>如果客户端的 SYN 阻塞了，重复发送多次 SYN 报文，那么服务器在收到请求后就会建立多个冗余的无效链接，造成不必要的资源浪费。</p>
<ul>
<li>⼀个「旧 SYN 报文」比「最新的 SYN 」 报文早到达了服务端；</li>
<li>那么此时服务端就会回⼀个 SYN + ACK 报文给客户端；</li>
<li>客户端收到后可以根据自身的上下文，判断这是⼀个历史连接（序列号过期或超时），那么客户端就会发送RST 报文给服务端，表示中止这⼀次连接。</li>
</ul>
<h4 id="三次握手才可以同步双方的初始序列号">三次握手才可以同步双方的初始序列号</h4>
<p>互相发送序列号并互相得到对方的确认，至少需要三次握手。如果两次握手那么服务端无法得到客户端的确认信息。</p>
<h2 id="tcp连接断开">TCP连接断开</h2>
<p><img src="/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718213708230.png"
	width="753"
	height="794"
	srcset="/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718213708230_hu59227d121b74d6a5ef23fdc8d02accce_67564_480x0_resize_box_3.png 480w, /posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718213708230_hu59227d121b74d6a5ef23fdc8d02accce_67564_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="四次挥手"
	
	
		class="gallery-image" 
		data-flex-grow="94"
		data-flex-basis="227px"
	
></p>
<ul>
<li>客户端打算关闭连接，此时会发送⼀个 TCP 首部 FIN 标志位被置为 1 的报文，也即 FIN 报文，之后客户端进入 FIN_WAIT_1 状态。</li>
<li>服务端收到该报文后，就向客户端发送 ACK 应答报文，接着服务端进入 CLOSED_WAIT 状态。</li>
<li>客户端收到服务端的 ACK 应答报文后，之后进入 FIN_WAIT_2 状态。</li>
<li>等待服务端处理完数据后，也向客户端发送 FIN 报文，之后服务端进入 LAST_ACK 状态。</li>
<li>客户端收到服务端的 FIN 报文后，回⼀个 ACK 应答报文，之后进入 TIME_WAIT 状态</li>
<li>服务器收到了 ACK 应答报文后，就进入了 CLOSED 状态，⾄此服务端已经完成连接的关闭。</li>
<li>客户端在经过 2MSL ⼀段时间后，⾃动进入 CLOSED 状态，⾄此客户端也完成连接的关闭。</li>
</ul>
<p>每个方向都需要⼀个 FIN 和⼀个 ACK，因此通常被称为四次挥手。这⾥⼀点需要注意是：主动关闭连接的，才有 TIME_WAIT 状态。</p>
<h3 id="为什么需要四次挥手">为什么需要四次挥手</h3>
<ul>
<li>关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据。</li>
<li>服务器收到客户端的 FIN 报文时，先回⼀个 ACK 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 FIN 报文给客户端来表示同意现在关闭连接。</li>
<li>从上面过程可知，服务端通常需要等待完成数据的发送和处理，所以服务端的 ACK 和 FIN ⼀般都会分开发送，从而比三次握手导致多了⼀次。</li>
</ul>
<h3 id="为什么-time_wait-等待的时间是-2msl">为什么 TIME_WAIT 等待的时间是 2MSL？</h3>
<p>MSL 是 Maximum Segment Lifetime，报文最大生存时间，它是任何报文在网络上存在的最⻓时间，超过这个时间报文将被丢弃。因为 TCP 报文基于是 IP 协议的，而 IP 头中有⼀个 TTL 字段，是 IP 数据报可以经过的最大路由数，每经过⼀个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃，同时发送 ICMP 报文通知源主机。</p>
<p>MSL 与 TTL 的区别： MSL 的单位是时间，而 TTL 是经过路由跳数。所以 MSL 应该要大于等于 TTL 消耗为 0 的时间，以确保报文已被⾃然消亡。TIME_WAIT 等待 2 倍的 MSL，比较合理的解释是： 网络中可能存在来⾃发送方的数据包，当这些发送方的数据包被接收方处理后⼜会向对方发送响应，所以⼀来⼀回需要等待 2倍的时间。</p>
<p>比如如果被动关闭方没有收到断开连接的最后的 ACK 报文，就会触发超时重发 Fin 报文，另⼀方接收到 FIN 后，会重发 ACK 给被动关闭方， ⼀来⼀去正好 2 个MSL。</p>
<p>2MSL 的时间是从客户端接收到 FIN 后发送 ACK 开始计时的。如果在 TIME-WAIT 时间内，因为客户端的 ACK没有传输到服务端，客户端⼜接收到了服务端重发的 FIN 报文，那么 2MSL 时间将重新计时。</p>
<p>在 Linux 系统⾥ 2MSL 默认是 60 秒，那么⼀个 MSL 也就是 30 秒。Linux 系统停留在 TIME_WAIT 的时间为固定的 60 秒。</p>
<h3 id="为什么需要-time_wait-状态">为什么需要 TIME_WAIT 状态？</h3>
<h4 id="防止旧连接的数据包">防止旧连接的数据包</h4>
<p>经过 2MSL 这个时间，⾜以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都⾃然消失，再出现的数据包⼀定都是新建⽴连接所产生的。</p>
<h4 id="保证连接正确关闭">保证连接正确关闭</h4>
<p>TIME-WAIT 作用是等待⾜够的时间以确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭。</p>
<h3 id="time_wait-过多有什么危害">TIME_WAIT 过多有什么危害？</h3>
<p>过多的 TIME-WAIT 状态主要的危害有两种：</p>
<ul>
<li>第⼀是内存资源占用；</li>
<li>第⼆是对端口资源的占用，⼀个 TCP 连接⾄少消耗⼀个本地端口；如果发起连接⼀方的 TIME_WAIT 状态过多，占满了所有端口资源，则会导致无法创建新连接。</li>
</ul>
<h4 id="如何优化-time_wait">如何优化 TIME_WAIT？</h4>
<p>Linux 内核参数开启后，则可以复用处于 TIME_WAIT 的 socket 为新的连接所用。tcp_tw_reuse 功能只能用客户端（连接发起方），因为开启了该功能，在调用 connect()函数时，内核会随机找⼀个 time_wait 状态超过 1 秒的连接给新的连接复用。</p>
<h3 id="tcp保活机制">TCP保活机制</h3>
<p><strong>TCP短连接:</strong></p>
<p>TCP短连接的情况，client向server发起连接请求，server接到请求，然后双方建立连接。client向server发送消息，server回应client，然后一次读写就完成了，这时候双方任何一个都可以发起close操作，不过一般都是client先发起close操作。</p>
<p>为什么呢，一般的server不会回复完client后立即关闭连接的，当然不排除有特殊的情况。从上面的描述看，短连接一般只会在client/server间传递一次读写操作</p>
<p>短连接的优点是：管理起来比较简单，存在的连接都是有用的连接，不需要额外的控制手段。</p>
<p><strong>TCP长连接：</strong></p>
<p>长连接的情况，client向server发起连接，server接受client连接，双方建立连接。Client与server完成一次读写之后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。</p>
<p>首先说一下TCP/IP详解上讲到的TCP保活功能，保活功能主要为服务器应用提供，服务器应用希望知道客户主机是否崩溃，从而可以代表客户使用资源。如果客户已经消失，使得服务器上保留一个半开放的连接，而服务器又在等待来自客户端的数据，则服务器将应远等待客户端的数据，保证功能就是试图在服务器端检测到这种半开放的连接。</p>
<p>如果一个给定的连接在两小时内没有任何的动作，则服务器就向客户发一个探测报文段，客户主机必须处于以下4个状态之一：</p>
<ol>
<li>客户主机依然正常运行，并从服务器可达。客户的TCP响应正常，而服务器也知道对方是正常的，服务器在两小时后将保证定时器复位。</li>
<li>客户主机已经崩溃，并且关闭或者正在重新启动。在任何一种情况下，客户的TCP都没有响应。服务端将不能收到对探测的响应，并在75秒后超时。服务器总共发送10个这样的探测 ，每个间隔75秒。如果服务器没有收到一个响应，它就认为客户主机已经关闭并终止连接。</li>
<li>客户主机崩溃并已经重新启动。服务器将收到一个对其保证探测的响应，这个响应是一个复位，使得服务器终止这个连接。</li>
<li>客户机正常运行，但是服务器不可达，这种情况与2类似，TCP能发现的就是没有收到探查的响应。</li>
</ol>
<p>从上面可以看出，TCP保活功能主要为探测长连接的存活状况，不过这里存在一个问题，存活功能的探测周期太长，还有就是它只是探测TCP连接的存活，属于比较斯文的做法，遇到恶意的连接时，保活功能就不够使了。</p>
<h2 id="既然-ip-层会分片为什么-tcp-层还需要-mss-呢">既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？</h2>
<p><img src="/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718212310101.png"
	width="1067"
	height="422"
	srcset="/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718212310101_hu1e526c0b4a2f8d3152247bc5add70829_64608_480x0_resize_box_3.png 480w, /posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718212310101_hu1e526c0b4a2f8d3152247bc5add70829_64608_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="MTU和MSS"
	
	
		class="gallery-image" 
		data-flex-grow="252"
		data-flex-basis="606px"
	
></p>
<ul>
<li>MTU ：⼀个网络包的最大长度，以太网中⼀般为 1500 字节；</li>
<li>MSS ：除去 IP 和 TCP 头部之后，⼀个网络包所能容纳的 TCP 数据的最大度；</li>
</ul>
<p>当 IP 层有⼀个超过 MTU 大小的数据（TCP 头部 + TCP 数据）要发送，那么 IP 层就要进行分片，把数据分片成若干片，保证每⼀个分片都小于 MTU。把⼀份 IP 数据报进行分片以后，由目标主机的 IP 层来进行重新组装后，再交给上⼀层 TCP 传输层。</p>
<p>这看起来井然有序，但这存在隐患的，那么当如果⼀个 IP 分片丢失，整个 IP 报文的所有分片都得重传。</p>
<p>因为 IP 层本身没有超时重传机制，它由传输层的 TCP 来负责超时和重传。</p>
<p><strong>当接收方发现 TCP 报文（头部 + 数据）的某⼀片丢失后，则不会响应 ACK 给对方，那么发送方的 TCP 在超时后，就会重发「整个 TCP 报文（头部 + 数据）」。</strong></p>
<p><strong>因此，可以得知由 IP 层进行分片传输，是非常没有效率的。</strong></p>
<p>所以，为了达到最佳的传输效能 TCP 协议在建⽴连接的时候通常要协商双方的 MSS 值，当 TCP 层发现数据超过MSS 时，则就先会进行分片，当然由它形成的 IP 包的⻓度也就不会大于 MTU ，⾃然也就不用 IP 分片了。</p>
<p><strong>经过 TCP 层分片后，如果⼀个 TCP 分片丢失后，进行重发时也是以 MSS 为单位，而不用重传所有的分片，大大增加了重传的效率。</strong></p>
<h2 id="什么是-syn-攻击如何避免-syn-攻击">什么是 SYN 攻击？如何避免 SYN 攻击？</h2>
<h3 id="syn攻击">SYN攻击</h3>
<p>我们都知道 TCP 连接建⽴是需要三次握手，假设攻击者短时间伪造不同 IP 地址的 SYN 报文，服务端每接收到⼀个 SYN 报文，就进入 SYN_RCVD 状态，但服务端发送出去的 ACK + SYN 报文，无法得到未知 IP 主机的ACK 应答，久而久之就会占满服务端的 SYN 接收队列（未连接队列），使得服务器不能为正常用户服务。</p>
<p><img src="/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718212721706.png"
	width="500"
	height="348"
	srcset="/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718212721706_hue4f8755de0cf2894d775595508aba5a7_101239_480x0_resize_box_3.png 480w, /posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718212721706_hue4f8755de0cf2894d775595508aba5a7_101239_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="SYN攻击"
	
	
		class="gallery-image" 
		data-flex-grow="143"
		data-flex-basis="344px"
	
></p>
<h3 id="解决方法">解决方法</h3>
<p>方法一：</p>
<p>其中⼀种解决方式是通过修改 Linux 内核参数，控制队列大小和当队列满时应做什么处理。</p>
<ul>
<li>当网卡接收数据包的速度大于内核处理的速度时，会有⼀个队列保存这些数据包。控制该队列的最大值如下参数：<code>net.core.netdev_max_backlog</code></li>
<li>SYN_RCVD 状态连接的最大个数：<code>net.ipv4.tcp_max_syn_backlog</code></li>
<li>超出处理能时，对新的 SYN 直接回报 RST，丢弃连接：<code>net.ipv4.tcp_abort_on_overflow</code></li>
</ul>
<p>方法二：</p>
<p><img src="/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718212953083.png"
	width="737"
	height="519"
	srcset="/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718212953083_hu7c65eb8fdeda67b3846fc3fa95f9b0b3_61732_480x0_resize_box_3.png 480w, /posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718212953083_hu7c65eb8fdeda67b3846fc3fa95f9b0b3_61732_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="SYN队列"
	
	
		class="gallery-image" 
		data-flex-grow="142"
		data-flex-basis="340px"
	
></p>
<ul>
<li>当 「 SYN 队列」满之后，后续服务器收到 SYN 包，不进入「 SYN 队列」；</li>
<li>计算出⼀个 cookie 值，再以 SYN + ACK 中的「序列号」返回客户端，（cookie 的作用是验证之后可能到达的<code>ACK</code>的有效性，保证这是一次完整的握手获得<code>SYN</code>报文中携带的<code>TCP</code>选项信息）</li>
<li>服务端接收到客户端的应答报文时，服务器会检查这个 ACK 包的合法性。如果合法，直接放入到「 Accept队列」。</li>
<li>最后应用通过调用 accpet() socket 接口，从「 Accept 队列」取出的连接。</li>
</ul>
<p><img src="/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718213041933.png"
	width="762"
	height="564"
	srcset="/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718213041933_hu09417038a9a317da07526dbff59acc00_73260_480x0_resize_box_3.png 480w, /posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718213041933_hu09417038a9a317da07526dbff59acc00_73260_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="SYN攻击解决"
	
	
		class="gallery-image" 
		data-flex-grow="135"
		data-flex-basis="324px"
	
></p>
<h2 id="tcp重传机制">TCP重传机制</h2>
<h3 id="超时重传">超时重传</h3>
<p>重传机制的其中⼀个方式，就是在发送数据时，设定⼀个定时器，当超过指定的时间后，没有收到对方的 ACK确认应答报文，就会重发该数据，也就是我们常说的超时重传。
TCP 会在以下两种情况发生超时重传：</p>
<ul>
<li>数据包丢失</li>
<li>确认应答丢失</li>
</ul>
<h4 id="超时时间">超时时间</h4>
<p>RTT 就是数据从网络⼀端传送到另⼀端所需的时间，也就是包的往返时间。超时重传时间是以 RTO （Retransmission Timeout 超时重传时间）表示。</p>
<p>超时重传时间 RTO 的值应该略大于报文往返 RTT 的值。</p>
<ul>
<li>当超时时间 RTO 较大时，重发就慢，丢了老半天才重发，没有效率，性能差；</li>
<li>当超时时间 RTO 较小时，会导致可能并没有丢就重发，于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。</li>
</ul>
<h3 id="快速重传">快速重传</h3>
<p>TCP 还有另外⼀种快速重传（Fast Retransmit）机制，它不以时间为驱动，而是以数据驱动重传</p>
<p><img src="/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718220814102.png"
	width="647"
	height="602"
	srcset="/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718220814102_hu6e48694c64f8a588a8190d7e30d521e5_53429_480x0_resize_box_3.png 480w, /posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/image-20220718220814102_hu6e48694c64f8a588a8190d7e30d521e5_53429_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="快速重传"
	
	
		class="gallery-image" 
		data-flex-grow="107"
		data-flex-basis="257px"
	
></p>
<p>快速重传的⼯作方式是当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段。</p>
<p>快速重传机制只解决了⼀个问题，就是超时时间的问题，但是它依然面临着另外⼀个问题。就是重传的时候，是重传之前的⼀个，还是重传所有的问题。</p>
<h3 id="sack">SACK</h3>
<p>还有一种实现重传机制的方式叫：SACK（ Selective Acknowledgment 选择性确认）。
这种方式需要在 TCP 头部「选项」字段里加一个 SACK 的东西，它<strong>可以将缓存的地图发送给发送方</strong>，这样发送方就可以知道哪些数据收到了，哪些数据没收到知道了这些信息，就可以<strong>只重传丢失的数据</strong>。</p>
<h3 id="dsack">DSACK</h3>
<p>Duplicate SACK ⼜称 D-SACK ，其主要使用了 SACK 来告诉「发送方」有哪些数据被重复接收了。</p>
<h2 id="滑动窗口">滑动窗口</h2>
<p>累计确认不怕ACK信息丢失</p>
<p>累计确认：只要发送方收到了 ACK700 确认应答，就意味着 700 之前的所有数据「接收方」都收到了。这个模式就叫累计确认或者累计应答。</p>
<h3 id="窗口大小如何确定">窗口大小如何确定</h3>
<p>这个字段是接收端告诉发送端 还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能⼒来发送数据，而不会导致接收端处理不过来。所以，通常窗口的大小是由接收方的窗口大小来决定的。</p>
<p>发送方发送的数据大小不能超过接收方的窗口大小，否则接收方就无法正常接收到数据。</p>
<h2 id="流量控制">流量控制</h2>
<p>发送方不能无脑的发数据给接收方，要考虑接收方处理能⼒。</p>
<p>如果⼀直无脑的发数据给对方，但对方处理不过来，那么就会导致触发重发机制，从而导致网络流量的无端的浪费。</p>
<p>为了解决这种现象发生，TCP 提供⼀种机制可以让「发送方」根据「接收方」的实际接收能⼒控制发送的数据量，这就是所谓的流量控制。</p>
<p>根据调整窗口的大小来控制发送方与接收方的流量</p>
<h2 id="拥塞控制">拥塞控制</h2>
<h3 id="流量控制与拥塞控制对比">流量控制与拥塞控制对比</h3>
<p>前面的流量控制是避免「发送方」的数据填满「接收方」的缓存，但是并不知道网络的中发生了什么。⼀般来说，计算机网络都处在⼀个共享的环境。因此也有可能会因为其他主机之间的通信使得网络拥堵。</p>
<p>在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是⼀重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大&hellip;.</p>
<p>于是，就有了拥塞控制，控制的目的就是避免「发送方」的数据填满整个网络。为了在「发送方」调节所要发送数据的量，定义了⼀个叫做「拥塞窗口」的概念。</p>
<p>拥塞窗口 cwnd是发送方维护的⼀个的状态变量，它会根据网络的拥塞程度动态变化的。</p>
<p>我们在前面提到过发送窗口 swnd 和接收窗口 rwnd 是约等于的关系，那么由于加入了拥塞窗口的概念后，此时发送窗口的值是swnd = min(cwnd, rwnd)，也就是<strong>拥塞窗口和接收窗口中的最小值</strong>。</p>
<p>拥塞窗口 cwnd 变化的规则：</p>
<ul>
<li>只要网络中没有出现拥塞， cwnd 就会增大；</li>
<li>但网络中出现了拥塞， cwnd 就减少；</li>
</ul>
<p>传输轮次：每一个窗口为一轮，例如当前轮次窗口为4，那么传输完4字节后，开始下一轮。</p>
<p><img src="/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/14.jpg"
	width="621"
	height="313"
	srcset="/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/14_hu672fe8e890b96438a399c64b3e32e88a_46530_480x0_resize_q75_box.jpg 480w, /posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C02-tcp%E5%8D%8F%E8%AE%AE/14_hu672fe8e890b96438a399c64b3e32e88a_46530_1024x0_resize_q75_box.jpg 1024w"
	loading="lazy"
	
		alt="拥塞控制"
	
	
		class="gallery-image" 
		data-flex-grow="198"
		data-flex-basis="476px"
	
></p>

</section>


    <footer class="article-footer">
    
    <section class="article-tags">
        
            <a href="/tags/%E7%BD%91%E7%BB%9C/">网络</a>
        
    </section>


    </footer>


    
</article>

    

    

<aside class="related-content--wrapper">
    <h2 class="section-title">相关文章</h2>
    <div class="related-content">
        <div class="flex article-list--tile">
            
                
<article class="">
    <a href="/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/reactor%E6%A8%A1%E5%9E%8B/">
        
        

        <div class="article-details">
            <h2 class="article-title">Reactor模型</h2>
        </div>
    </a>
</article>

            
                
<article class="">
    <a href="/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E9%9B%B6%E6%8B%B7%E8%B4%9D/">
        
        

        <div class="article-details">
            <h2 class="article-title">零拷贝</h2>
        </div>
    </a>
</article>

            
                
<article class="">
    <a href="/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C01-http%E5%8D%8F%E8%AE%AE/">
        
        

        <div class="article-details">
            <h2 class="article-title">网络01-HTTP协议</h2>
        </div>
    </a>
</article>

            
                
<article class="">
    <a href="/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C03-ip%E5%8D%8F%E8%AE%AE/">
        
        

        <div class="article-details">
            <h2 class="article-title">网络03-IP协议</h2>
        </div>
    </a>
</article>

            
                
<article class="">
    <a href="/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/io%E6%A8%A1%E5%9E%8B%E5%88%86%E6%9E%90%E4%B8%8E%E5%AF%B9%E6%AF%94/">
        
        

        <div class="article-details">
            <h2 class="article-title">IO模型分析与对比</h2>
        </div>
    </a>
</article>

            
        </div>
    </div>
</aside>

     
    
        
    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            2020 - 
        
        2022 isheihei&#39;s blog
    </section>
    
    <section class="powerby">
        
            浙ICP备2022017844号 <br/>
        Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <br />
        Theme <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.12.0">Stack</a></b> designed by <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a>
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
    <aside class="sidebar right-sidebar sticky">
        
            
                
    <section class="widget archives">
        <div class="widget-icon">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



        </div>
        <h2 class="widget-title section-title">目录</h2>
        
        <div class="widget--toc">
            <nav id="TableOfContents">
  <ol>
    <li><a href="#什么是tcp">什么是TCP</a></li>
    <li><a href="#什么是tcp连接">什么是TCP连接</a></li>
    <li><a href="#tcp-格式">TCP 格式</a></li>
    <li><a href="#tcp-和-udp-区别">TCP 和 UDP 区别</a>
      <ol>
        <li><a href="#区别">区别</a></li>
        <li><a href="#tcp-和-udp-应用场景">TCP 和 UDP 应用场景：</a></li>
      </ol>
    </li>
    <li><a href="#tcp连接">TCP连接</a>
      <ol>
        <li><a href="#如何在-linux-系统中查看-tcp-状态">如何在 Linux 系统中查看 TCP 状态？</a></li>
        <li><a href="#为什么是三次握手不是两次四次">为什么是三次握手？不是两次、四次？</a>
          <ol>
            <li><a href="#三次握手才可以阻止重复历史连接的初始化-避免资源浪费主要原因">三次握手才可以阻止重复历史连接的初始化 避免资源浪费（主要原因）</a></li>
            <li><a href="#三次握手才可以同步双方的初始序列号">三次握手才可以同步双方的初始序列号</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#tcp连接断开">TCP连接断开</a>
      <ol>
        <li><a href="#为什么需要四次挥手">为什么需要四次挥手</a></li>
        <li><a href="#为什么-time_wait-等待的时间是-2msl">为什么 TIME_WAIT 等待的时间是 2MSL？</a></li>
        <li><a href="#为什么需要-time_wait-状态">为什么需要 TIME_WAIT 状态？</a>
          <ol>
            <li><a href="#防止旧连接的数据包">防止旧连接的数据包</a></li>
            <li><a href="#保证连接正确关闭">保证连接正确关闭</a></li>
          </ol>
        </li>
        <li><a href="#time_wait-过多有什么危害">TIME_WAIT 过多有什么危害？</a>
          <ol>
            <li><a href="#如何优化-time_wait">如何优化 TIME_WAIT？</a></li>
          </ol>
        </li>
        <li><a href="#tcp保活机制">TCP保活机制</a></li>
      </ol>
    </li>
    <li><a href="#既然-ip-层会分片为什么-tcp-层还需要-mss-呢">既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？</a></li>
    <li><a href="#什么是-syn-攻击如何避免-syn-攻击">什么是 SYN 攻击？如何避免 SYN 攻击？</a>
      <ol>
        <li><a href="#syn攻击">SYN攻击</a></li>
        <li><a href="#解决方法">解决方法</a></li>
      </ol>
    </li>
    <li><a href="#tcp重传机制">TCP重传机制</a>
      <ol>
        <li><a href="#超时重传">超时重传</a>
          <ol>
            <li><a href="#超时时间">超时时间</a></li>
          </ol>
        </li>
        <li><a href="#快速重传">快速重传</a></li>
        <li><a href="#sack">SACK</a></li>
        <li><a href="#dsack">DSACK</a></li>
      </ol>
    </li>
    <li><a href="#滑动窗口">滑动窗口</a>
      <ol>
        <li><a href="#窗口大小如何确定">窗口大小如何确定</a></li>
      </ol>
    </li>
    <li><a href="#流量控制">流量控制</a></li>
    <li><a href="#拥塞控制">拥塞控制</a>
      <ol>
        <li><a href="#流量控制与拥塞控制对比">流量控制与拥塞控制对比</a></li>
      </ol>
    </li>
  </ol>
</nav>
        </div>
    </section>

            
        
    </aside>


        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
