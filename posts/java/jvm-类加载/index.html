<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content='类加载过程、类加载器、对象创建过程'><title>JVM-类加载</title>

<link rel='canonical' href='https://isheihei.github.io/posts/java/jvm-%E7%B1%BB%E5%8A%A0%E8%BD%BD/'>

<link rel="stylesheet" href="/scss/style.min.d9e0562edde3d2bdf9d3d81365095a29d062ddaaa5d671f22168e57dfdb18b4f.css">
<meta property='og:title' content='JVM-类加载'>
<meta property='og:description' content='类加载过程、类加载器、对象创建过程'>
<meta property='og:url' content='https://isheihei.github.io/posts/java/jvm-%E7%B1%BB%E5%8A%A0%E8%BD%BD/'>
<meta property='og:site_name' content='isheihei&#39;s blog'>
<meta property='og:type' content='article'><meta property='article:section' content='Posts' /><meta property='article:tag' content='jvm' /><meta property='article:tag' content='Java' /><meta property='article:published_time' content='2022-07-15T20:17:48&#43;08:00'/><meta property='article:modified_time' content='2022-07-15T20:17:48&#43;08:00'/>
<meta name="twitter:title" content="JVM-类加载">
<meta name="twitter:description" content="类加载过程、类加载器、对象创建过程">
    
    
    <link rel="shortcut icon" href= "/img/favicon_hu2f307a5f23288c798230c92f583cd3bd_467065_32x0_resize_box_3.png" />

    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="切换菜单">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/">
                
                    
                    
                    
                        
                        <img src="/img/avatar_hu2f307a5f23288c798230c92f583cd3bd_467065_300x0_resize_box_3.png" width="300"
                            height="300" class="site-logo" loading="lazy" alt="Avatar">
                    
                
                </a>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/">isheihei&#39;s blog</a></h1>
            <h2 class="site-description">兼听则明，三思而后行。</h2>
        </div>
    </header><ol class="menu" id="main-menu">
        
        
        

        <li >
            <a href='/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>主页</span>
            </a>
        </li>
        
        

        <li >
            <a href='/about/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="7" r="4" />
  <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" />
</svg>



                
                <span>关于</span>
            </a>
        </li>
        
        

        <li >
            <a href='/archives/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>归档</span>
            </a>
        </li>
        
        

        <li >
            <a href='/search/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>Search</span>
            </a>
        </li>
        
        

        <li >
            <a href='/links/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5" />
  <path d="M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5" />
</svg>



                
                <span>Links</span>
            </a>
        </li>
        

        <div class="menu-bottom-section">
            
            
                <li id="dark-mode-toggle">
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                    <span>暗色模式</span>
                </li>
            
        </div>
    </ol>
</aside>
<main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/java/" style="background-color: #729fd8; color: #fff;">
                Java
            </a>
        
    </header>
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/posts/java/jvm-%E7%B1%BB%E5%8A%A0%E8%BD%BD/">JVM-类加载</a>
        </h2>
    
        
        <h3 class="article-subtitle">
            类加载过程、类加载器、对象创建过程
        </h3>
        
    </div>

    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">Jul 15, 2022</time>
            </div>
        

        
    </footer>
    

    
</div>
</header>

    <section class="article-content">
    
    
    <h2 id="类加载过程">类加载过程</h2>
<h3 id="生命周期">生命周期</h3>
<p>类是在运行期间<strong>第一次使用时动态加载</strong>的（不使用不加载），而不是一次性加载所有类，因为一次性加载会占用很多的内存，加载的类信息存放于一块成为方法区的内存空间</p>
<p><img src="/posts/java/jvm-%E7%B1%BB%E5%8A%A0%E8%BD%BD/JVM-%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png"
	width="1092"
	height="234"
	srcset="/posts/java/jvm-%E7%B1%BB%E5%8A%A0%E8%BD%BD/JVM-%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F_hu8e43835ce85328b9666c388e85f80113_34408_480x0_resize_box_3.png 480w, /posts/java/jvm-%E7%B1%BB%E5%8A%A0%E8%BD%BD/JVM-%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F_hu8e43835ce85328b9666c388e85f80113_34408_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="JVM-类的生命周期"
	
	
		class="gallery-image" 
		data-flex-grow="466"
		data-flex-basis="1120px"
	
></p>
<p>包括 7 个阶段：</p>
<ul>
<li>加载（Loading）</li>
<li>链接：验证（Verification）、准备（Preparation）、解析（Resolution）</li>
<li>初始化（Initialization）</li>
<li>使用（Using）</li>
<li>卸载（Unloading）</li>
</ul>
<h3 id="加载阶段">加载阶段</h3>
<p>加载是类加载的其中一个阶段，注意不要混淆</p>
<p>加载过程完成以下三件事：</p>
<ul>
<li>通过类的完全限定名称获取定义该类的二进制字节流（二进制字节码）</li>
<li>将该字节流表示的静态存储结构转换为方法区的运行时存储结构（Java 类模型）</li>
<li><strong>在内存中生成一个代表该类的 Class 对象，作为该类在方法区中的各种数据的访问入口</strong></li>
</ul>
<p>其中二进制字节流可以从以下方式中获取：</p>
<ul>
<li>从 ZIP 包读取，成为 JAR、EAR、WAR 格式的基础</li>
<li>从网络中获取，最典型的应用是 Applet</li>
<li>由其他文件生成，例如由 JSP 文件生成对应的 Class 类</li>
<li>运行时计算生成，例如动态代理技术，在 java.lang.reflect.Proxy 使用 ProxyGenerator.generateProxyClass 生成字节码</li>
</ul>
<p>将字节码文件加载至方法区后，会<strong>在堆中</strong>创建一个 java.lang.Class 对象，用来引用位于方法区内的数据结构，该 Class 对象是在加载类的过程中创建的，每个类都对应有一个 Class 类型的对象</p>
<p>方法区内部采用 C++ 的 instanceKlass 描述 Java 类的数据结构：</p>
<ul>
<li><code>_java_mirror</code> 即 Java 的类镜像，例如对 String 来说就是 String.class，作用是把 class 暴露给 Java 使用</li>
<li><code>_super</code> 即父类、<code>_fields</code> 即成员变量、<code>_methods</code> 即方法、<code>_constants</code> 即常量池、<code>_class_loader</code> 即类加载器、<code>_vtable</code> <strong>虚方法表</strong>、<code>_itable</code> 接口方法表</li>
</ul>
<p>加载过程：</p>
<ul>
<li>如果这个类还有父类没有加载，先加载父类</li>
<li>加载和链接可能是交替运行的</li>
<li>Class 对象和 _java_mirror 相互持有对方的地址，堆中对象通过 instanceKlass 和元空间进行交互</li>
</ul>
<p><img src="/posts/java/jvm-%E7%B1%BB%E5%8A%A0%E8%BD%BD/JVM-%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-%E5%8A%A0%E8%BD%BD.png"
	width="817"
	height="379"
	srcset="/posts/java/jvm-%E7%B1%BB%E5%8A%A0%E8%BD%BD/JVM-%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-%E5%8A%A0%E8%BD%BD_hue21997fb3467820226412a963ce42254_80963_480x0_resize_box_3.png 480w, /posts/java/jvm-%E7%B1%BB%E5%8A%A0%E8%BD%BD/JVM-%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-%E5%8A%A0%E8%BD%BD_hue21997fb3467820226412a963ce42254_80963_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="JVM-类的生命周期-加载"
	
	
		class="gallery-image" 
		data-flex-grow="215"
		data-flex-basis="517px"
	
></p>
<p>创建数组类有些特殊，因为数组类本身并不是由类加载器负责创建，而是由 JVM 在运行时根据需要而直接创建的，但数组的元素类型仍然需要依靠类加载器去创建，创建数组类的过程：</p>
<ul>
<li>如果数组的元素类型是引用类型，那么遵循定义的加载过程递归加载和创建数组的元素类型</li>
<li>JVM 使用指定的元素类型和数组维度来创建新的数组类</li>
<li><strong>基本数据类型由启动类加载器加载</strong></li>
</ul>
<h3 id="链接阶段">链接阶段</h3>
<h4 id="验证">验证</h4>
<p>确保 Class 文件的字节流中包含的信息是否符合 JVM 规范，保证被加载类的正确性，不会危害虚拟机自身的安全</p>
<p>主要包括<strong>四种验证</strong>：</p>
<ul>
<li>
<p>文件格式验证</p>
</li>
<li>
<p>语义检查，但凡在语义上不符合规范的，虚拟机不会给予验证通过</p>
<ul>
<li>
<p>是否所有的类都有父类的存在（除了 Object 外，其他类都应该有父类）</p>
</li>
<li>
<p>是否一些被定义为 final 的方法或者类被重写或继承了</p>
</li>
<li>
<p>非抽象类是否实现了所有抽象方法或者接口方法</p>
</li>
<li>
<p>是否存在不兼容的方法</p>
</li>
</ul>
</li>
<li>
<p>字节码验证，试图通过对字节码流的分析，判断字节码是否可以被正确地执行</p>
<ul>
<li>在字节码的执行过程中，是否会跳转到一条不存在的指令</li>
<li>函数的调用是否传递了正确类型的参数</li>
<li>变量的赋值是不是给了正确的数据类型</li>
<li>栈映射帧（StackMapTable）在这个阶段用于检测在特定的字节码处，其局部变量表和操作数栈是否有着正确的数据类型</li>
</ul>
</li>
<li>
<p>符号引用验证，Class 文件在其常量池会通过字符串记录将要使用的其他类或者方法</p>
</li>
</ul>
<h4 id="准备">准备</h4>
<p>准备阶段为<strong>静态变量（类变量）分配内存并设置初始值</strong>，使用的是方法区的内存：</p>
<p>说明：实例变量不会在这阶段分配内存，它会在对象实例化时随着对象一起被分配在堆中，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次</p>
<p>类变量初始化：</p>
<ul>
<li>static 变量分配空间和赋值是两个步骤：<strong>分配空间在准备阶段完成，赋值在初始化阶段完成</strong></li>
<li>如果 static 变量是 final 的基本类型以及字符串常量，那么编译阶段值（方法区）就确定了，准备阶段会显式初始化</li>
<li>如果 static 变量是 final 的，但属于引用类型或者构造器方法的字符串，赋值在初始化阶段完成</li>
</ul>
<p>实例：</p>
<ul>
<li>
<p>初始值一般为 0 值，例如下面的类变量 value 被初始化为 0 而不是 123：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">123</span><span class="o">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>常量 value 被初始化为 123 而不是 0：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">123</span><span class="o">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>Java 并不支持 boolean 类型，对于 boolean 类型，内部实现是 int，由于 int 的默认值是0，故 boolean 的默认值就是 false</p>
</li>
</ul>
<h4 id="解析">解析</h4>
<p>将常量池中类、接口、字段、方法的<strong>符号引用替换为直接引用</strong>（内存地址）的过程：</p>
<ul>
<li>符号引用：一组符号来描述目标，可以是任何字面量，属于编译原理方面的概念，如：包括类和接口的全限名、字段的名称和描述符、方法的名称和<strong>方法描述符</strong>（因为类还没有加载完，很多方法是找不到的）</li>
<li>直接引用：直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄，如果有了直接引用，那说明引用的目标必定已经存在于内存之中</li>
</ul>
<p>例如：在 <code>com.demo.Solution</code> 类中引用了 <code>com.test.Quest</code>，把 <code>com.test.Quest</code> 作为符号引用存进类常量池，在类加载完后，<strong>用这个符号引用去方法区找这个类的内存地址</strong></p>
<p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等</p>
<ul>
<li>在类加载阶段解析的是非虚方法，静态绑定</li>
<li>也可以在初始化阶段之后再开始解析，这是为了支持 Java 的<strong>动态绑定</strong></li>
<li>通过解析操作，符号引用就可以转变为目标方法在类的虚方法表中的位置，从而使得方法被成功调用</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Load2</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span><span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">ClassLoader</span> <span class="n">classloader</span> <span class="o">=</span> <span class="n">Load2</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getClassLoader</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// cloadClass 加载类方法不会导致类的解析和初始化，也不会加载D
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="n">classloader</span><span class="o">.</span><span class="na">loadClass</span><span class="o">(</span><span class="s">&#34;cn.jvm.t3.load.C&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">    <span class="c1">// new C();会导致类的解析和初始化，从而解析初始化D
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">System</span><span class="o">.</span><span class="na">in</span><span class="o">.</span><span class="na">read</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">C</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">D</span> <span class="n">d</span> <span class="o">=</span> <span class="k">new</span> <span class="n">D</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">D</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="初始化">初始化</h3>
<h4 id="介绍">介绍</h4>
<p>初始化阶段才真正开始执行类中定义的 Java 程序代码，在准备阶段，类变量已经赋过一次系统要求的初始值；在初始化阶段，通过程序制定的计划去初始化类变量和其它资源，执行 clinit ()</p>
<p>在编译生成 class 文件时，编译器会产生两个方法加于 class 文件中，一个是类的初始化方法 clinit，另一个是实例的初始化方法 init</p>
<p>类构造器 clinit () 与实例构造器 init() 不同，它不需要程序员进行显式调用，在一个类的生命周期中，类构造器最多被虚拟机<strong>调用一次</strong>，而实例构造器则会被虚拟机调用多次，只要程序员创建对象</p>
<p>类在第一次实例化加载一次，把 class 读入内存，后续实例化不再加载，引用第一次加载的类</p>
<h4 id="clinit">clinit</h4>
<p>clinit ()：类构造器，由编译器自动收集类中<strong>所有类变量的赋值动作和静态语句块</strong>中的语句合并产生的</p>
<p>作用：是在类加载过程中的初始化阶段进行静态变量初始化和执行静态代码块</p>
<ul>
<li>如果类中没有静态变量或静态代码块，那么 clinit 方法将不会被生成</li>
<li>clinit 方法只执行一次，在执行 clinit 方法时，必须先执行父类的clinit方法</li>
<li>static 变量的赋值操作和静态代码块的合并顺序由源文件中出现的顺序决定</li>
<li>static 不加 final 的变量都在初始化环节赋值</li>
</ul>
<p><strong>线程安全</strong>问题：</p>
<ul>
<li>虚拟机会保证一个类的 clinit () 方法在多线程环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行这个类的 clinit () 方法，其它线程都阻塞等待，直到活动线程执行clinit () 方法完毕</li>
<li>如果在一个类的 clinit () 方法中有耗时的操作，就可能造成多个线程阻塞，在实际过程中此种阻塞很隐蔽</li>
</ul>
<p>特别注意：静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">static</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//i = 0;                // 给变量赋值可以正常编译通过
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>  	<span class="c1">// 这句编译器会提示“非法向前引用”
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="kd">static</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成 clinit ()方法，两者不同的是：</p>
<ul>
<li>在初始化一个接口时，并不会先初始化它的父接口，所以执行接口的 clinit ()方法不需要先执行父接口的clinit () 方法</li>
<li>在初始化一个类时，不会先初始化所实现的接口，所以接口的实现类在初始化时不会执行接口的 clinit () 方法</li>
<li>只有当父接口中定义的变量使用时，父接口才会初始化</li>
</ul>
<h4 id="时机">时机</h4>
<p>类的初始化是懒惰的，只有在首次使用时才会被装载，JVM 不会无条件地装载 Class 类型，Java 虚拟机规定，一个类或接口在初次使用前，必须要进行初始化</p>
<p><strong>主动引用</strong>：虚拟机规范中并没有强制约束何时进行加载，但是规范严格规定了有且只有下列情况必须对类进行初始化（加载、验证、准备都会发生）：</p>
<ul>
<li>当创建一个类的实例时，使用 new 关键字，或者通过反射、克隆、反序列化（前文讲述的对象的创建时机）</li>
<li>当调用类的静态方法或访问静态字段时，遇到 getstatic、putstatic、invokestatic 这三条字节码指令，如果类没有进行过初始化，则必须先触发其初始化
<ul>
<li>getstatic：程序访问类的静态变量（不是静态常量，常量会被加载到运行时常量池）</li>
<li>putstatic：程序给类的静态变量赋值</li>
<li>invokestatic ：调用一个类的静态方法</li>
</ul>
</li>
<li>使用 java.lang.reflect 包的方法对类进行反射调用时，如果类没有进行初始化，则需要先触发其初始化</li>
<li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化，但这条规则并<strong>不适用于接口</strong></li>
<li>当虚拟机启动时，需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类</li>
<li>MethodHandle 和 VarHandle 可以看作是轻量级的反射调用机制，而要想使用这两个调用， 就必须先使用 findStaticVarHandle 来初始化要调用的类</li>
<li>补充：当一个接口中定义了 JDK8 新加入的默认方法（被 default 关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化</li>
</ul>
<p><strong>被动引用</strong>：所有引用类的方式都不会触发初始化，称为被动引用</p>
<ul>
<li>通过子类引用父类的静态字段，不会导致子类初始化，只会触发父类的初始化</li>
<li>通过数组定义来引用类，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法</li>
<li>常量（final 修饰）在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化</li>
<li>调用 ClassLoader 类的 loadClass() 方法加载一个类，并不是对类的主动使用，不会导致类的初始化</li>
</ul>
<h4 id="init">init</h4>
<p>init 指的是实例构造器，主要作用是在类实例化过程中执行，执行内容包括成员变量初始化和代码块的执行</p>
<p>实例化即调用 init() ，虚拟机会保证这个类的构造方法的线程安全，先为实例变量分配内存空间，再执行赋默认值，然后根据源码中的顺序执行赋初值或代码块，没有成员变量初始化和代码块则不会执行</p>
<p>类实例化过程：<strong>父类的类构造器 init() -&gt; 子类的类构造器 init() -&gt; 父类的成员变量和实例代码块 -&gt; 父类的构造函数 -&gt; 子类的成员变量和实例代码块 -&gt; 子类的构造函数</strong></p>
<p>new 关键字会创建对象并复制 dup 一个对象引用，一个调用 init()  方法，另一个用来赋值给接收者</p>
<h3 id="卸载阶段">卸载阶段</h3>
<p>时机：执行了 System.exit() 方法，程序正常执行结束，程序在执行过程中遇到了异常或错误而异常终止，由于操作系统出现错误而导致Java虚拟机进程终止</p>
<p>卸载类即该类的 <strong>Class 对象被 GC</strong>，卸载类需要满足3个要求:</p>
<ol>
<li>该类的所有的实例对象都已被 GC，也就是说堆不存在该类的实例对象</li>
<li>该类没有在其他任何地方被引用</li>
<li>该类的类加载器的实例已被 GC，一般是可替换类加载器的场景，如 OSGi、JSP 的重加载等，很难达成</li>
</ol>
<p>在 JVM 生命周期类，由 JVM 自带的类加载器加载的类是不会被卸载的，自定义的类加载器加载的类是可能被卸载。因为 JVM 会始终引用启动、扩展、系统类加载器，这些类加载器始终引用它们所加载的类，这些类始终是可及的</p>
<h2 id="类加载器">类加载器</h2>
<h3 id="类加载">类加载</h3>
<p>类加载方式：</p>
<ul>
<li>隐式加载：不直接在代码中调用 ClassLoader 的方法加载类对象
<ul>
<li>创建类对象、使用类的静态域、创建子类对象、使用子类的静态域</li>
<li>在 JVM 启动时，通过三大类加载器加载 class</li>
</ul>
</li>
<li>显式加载：
<ul>
<li>ClassLoader.loadClass(className)：只加载和连接，<strong>不会进行初始化</strong></li>
<li>Class.forName(String name, boolean initialize, ClassLoader loader)：使用 loader 进行加载和连接，根据参数 initialize 决定是否初始化</li>
</ul>
</li>
</ul>
<p>类的唯一性：</p>
<ul>
<li>在 JVM 中表示两个 class 对象判断为同一个类存在的两个必要条件：
<ul>
<li>类的完整类名必须一致，包括包名</li>
<li>加载这个类的 ClassLoader（指 ClassLoader 实例对象）必须相同</li>
</ul>
</li>
<li>这里的相等，包括类的 Class 对象的 equals() 方法、isAssignableFrom() 方法、isInstance() 方法的返回结果为 true，也包括使用 instanceof 关键字做对象所属关系判定结果为 true</li>
</ul>
<p>命名空间：</p>
<ul>
<li>每个类加载器都有自己的命名空间，命名空间由该加载器及所有的父加载器所加载的类组成</li>
<li>在同一命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类</li>
</ul>
<p>基本特征：</p>
<ul>
<li><strong>可见性</strong>，子类加载器可以访问父加载器加载的类型，但是反过来是不允许的</li>
<li><strong>单一性</strong>，由于父加载器的类型对于子加载器是可见的，所以父加载器中加载过的类型，不会在子加载器中重复加载</li>
</ul>
<h3 id="加载器">加载器</h3>
<p>类加载器是 Java 的核心组件，用于加载字节码到 JVM 内存，得到 Class 类的对象</p>
<p>从 Java 虚拟机规范来讲，只存在以下两种不同的类加载器：</p>
<ul>
<li>启动类加载器（Bootstrap ClassLoader）：使用 C++ 实现，是虚拟机自身的一部分</li>
<li>自定义类加载器（User-Defined ClassLoader）：Java 虚拟机规范<strong>将所有派生于抽象类 ClassLoader 的类加载器都划分为自定义类加载器</strong>，使用 Java 语言实现，独立于虚拟机</li>
</ul>
<p>从 Java 开发人员的角度看：</p>
<ul>
<li>启动类加载器（Bootstrap ClassLoader）：
<ul>
<li>处于安全考虑，Bootstrap 启动类加载器只加载包名为 java、javax、sun 等开头的类</li>
<li>类加载器负责加载在 <code>JAVA_HOME/jre/lib</code> 或 <code>sun.boot.class.path</code> 目录中的，或者被 -Xbootclasspath 参数所指定的路径中的类，并且是虚拟机识别的类库加载到虚拟机内存中</li>
<li>仅按照文件名识别，如 rt.jar 名字不符合的类库即使放在 lib 目录中也不会被加载</li>
<li>启动类加载器无法被 Java 程序直接引用，编写自定义类加载器时，如果要把加载请求委派给启动类加载器，直接使用 null 代替</li>
</ul>
</li>
<li>扩展类加载器（Extension ClassLoader）：
<ul>
<li>由 ExtClassLoader (sun.misc.Launcher$ExtClassLoader)  实现，上级为 Bootstrap，显示为 null</li>
<li>将 <code>JAVA_HOME/jre/lib/ext</code> 或者被 <code>java.ext.dir</code> 系统变量所指定路径中的所有类库加载到内存中</li>
<li>开发者可以使用扩展类加载器，创建的 JAR 放在此目录下，会由扩展类加载器自动加载</li>
</ul>
</li>
<li>应用程序类加载器（Application ClassLoader）：
<ul>
<li>由 AppClassLoader(sun.misc.Launcher$AppClassLoader) 实现，上级为 Extension</li>
<li>负责加载环境变量 classpath 或系统属性 <code>java.class.path</code> 指定路径下的类库</li>
<li>这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，因此称为系统类加载器</li>
<li>可以直接使用这个类加载器，如果应用程序中没有自定义类加载器，这个就是程序中默认的类加载器</li>
</ul>
</li>
<li>自定义类加载器：由开发人员自定义的类加载器，上级是 Application</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//获取系统类加载器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">ClassLoader</span> <span class="n">systemClassLoader</span> <span class="o">=</span> <span class="n">ClassLoader</span><span class="o">.</span><span class="na">getSystemClassLoader</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">systemClassLoader</span><span class="o">);</span><span class="c1">//sun.misc.Launcher$AppClassLoader@18b4aac2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">//获取其上层  扩展类加载器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">ClassLoader</span> <span class="n">extClassLoader</span> <span class="o">=</span> <span class="n">systemClassLoader</span><span class="o">.</span><span class="na">getParent</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">extClassLoader</span><span class="o">);</span><span class="c1">//sun.misc.Launcher$ExtClassLoader@610455d6
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">//获取其上层 获取不到引导类加载器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">ClassLoader</span> <span class="n">bootStrapClassLoader</span> <span class="o">=</span> <span class="n">extClassLoader</span><span class="o">.</span><span class="na">getParent</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">bootStrapClassLoader</span><span class="o">);</span><span class="c1">//null
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">//对于用户自定义类来说：使用系统类加载器进行加载
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">ClassLoader</span> <span class="n">classLoader</span> <span class="o">=</span> <span class="n">ClassLoaderTest</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getClassLoader</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">classLoader</span><span class="o">);</span><span class="c1">//sun.misc.Launcher$AppClassLoader@18b4aac2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">//String 类使用引导类加载器进行加载的 --&gt; java核心类库都是使用启动类加载器加载的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">ClassLoader</span> <span class="n">classLoader1</span> <span class="o">=</span> <span class="n">String</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getClassLoader</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">classLoader1</span><span class="o">);</span><span class="c1">//null
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>补充两个类加载器：</p>
<ul>
<li>SecureClassLoader 扩展了 ClassLoader，新增了几个与使用相关的代码源和权限定义类验证（对 class 源码的访问权限）的方法，一般不会直接跟这个类打交道，更多是与它的子类 URLClassLoader 有所关联</li>
<li>ClassLoader 是一个抽象类，很多方法是空的没有实现，而 URLClassLoader 这个实现类为这些方法提供了具体的实现，并新增了 URLClassPath 类协助取得 Class 字节流等功能。在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承 URLClassLoader 类，这样就可以避免去编写 findClass() 方法及其获取字节码流的方式，使自定义类加载器编写更加简洁</li>
</ul>
<h3 id="常用api">常用API</h3>
<p>ClassLoader 类，是一个抽象类，其后所有的类加载器都继承自 ClassLoader（不包括启动类加载器）</p>
<p>获取 ClassLoader 的途径：</p>
<ul>
<li>获取当前类的 ClassLoader：<code>clazz.getClassLoader()</code></li>
<li>获取当前线程上下文的 ClassLoader：<code>Thread.currentThread.getContextClassLoader()</code></li>
<li>获取系统的 ClassLoader：<code>ClassLoader.getSystemClassLoader()</code></li>
<li>获取调用者的 ClassLoader：<code>DriverManager.getCallerClassLoader()</code></li>
</ul>
<p>ClassLoader 类常用方法：</p>
<ul>
<li><code>getParent()</code>：返回该类加载器的超类加载器</li>
<li><code>loadclass(String name)</code>：加载名为 name 的类，返回结果为 Class 类的实例，<strong>该方法就是双亲委派模式</strong></li>
<li><code>findclass(String name)</code>：查找二进制名称为 name 的类，返回结果为 Class 类的实例，该方法会在检查完父类加载器之后被 loadClass() 方法调用</li>
<li><code>findLoadedClass(String name)</code>：查找名称为 name 的已经被加载过的类，final 修饰无法重写</li>
<li><code>defineClass(String name, byte[] b, int off, int len)</code>：将<strong>字节流</strong>解析成 JVM 能够识别的类对象</li>
<li><code>resolveclass(Class&lt;?&gt; c)</code>：链接指定的 Java 类，可以使类的 Class 对象创建完成的同时也被解析</li>
<li><code>InputStream getResourceAsStream(String name)</code>：指定资源名称获取输入流</li>
</ul>
<h3 id="加载模型">加载模型</h3>
<h4 id="加载机制">加载机制</h4>
<p>在 JVM 中，对于类加载模型提供了三种，分别为全盘加载、双亲委派、缓存机制</p>
<ul>
<li>
<p><strong>全盘加载：</strong> 当一个类加载器负责加载某个 Class 时，该 Class 所依赖和引用的其他 Class 也将由该类加载器负责载入，除非显示指定使用另外一个类加载器来载入</p>
</li>
<li>
<p><strong>双亲委派：</strong> 先让父类加载器加载该 Class，在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。简单来说就是，某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，<strong>依次递归</strong>，如果父加载器可以完成类加载任务，就成功返回；只有当父加载器无法完成此加载任务时，才自己去加载</p>
</li>
<li>
<p><strong>缓存机制：</strong> 会保证所有加载过的 Class 都会被缓存，当程序中需要使用某个 Class 时，类加载器先从缓存区中搜寻该 Class，只有当缓存区中不存在该 Class 对象时，系统才会读取该类对应的二进制数据，并将其转换成 Class 对象存入缓冲区（方法区）中</p>
<ul>
<li>这就是修改了 Class 后，必须重新启动 JVM，程序所做的修改才会生效的原因</li>
</ul>
</li>
</ul>
<h4 id="双亲委派">双亲委派</h4>
<p>双亲委派模型（Parents Delegation Model）：该模型要求除了顶层的启动类加载器外，其它类加载器都要有父类加载器，这里的父子关系一般通过组合关系（Composition）来实现，而不是继承关系（Inheritance）</p>
<p>工作过程：一个类加载器首先将类加载请求转发到父类加载器，只有当父类加载器无法完成时才尝试自己加载</p>
<p>双亲委派机制的优点：</p>
<ul>
<li>
<p>可以避免某一个类被重复加载，当父类已经加载后则无需重复加载，保证全局唯一性</p>
</li>
<li>
<p>Java 类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一</p>
</li>
<li>
<p>保护程序安全，防止类库的核心 API 被随意篡改</p>
<p>例如：在工程中新建 java.lang 包，接着在该包下新建 String 类，并定义 main 函数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">String</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;demo info&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>此时执行 main 函数，会出现异常，在类 java.lang.String 中找不到 main 方法，防止恶意篡改核心 API 库。出现该信息是因为双亲委派的机制，java.lang.String 的在启动类加载器（Bootstrap）得到加载，启动类加载器优先级更高，在核心 jre 库中有其相同名字的类文件，但该类中并没有 main 方法</p>
</li>
</ul>
<p>双亲委派机制的缺点：检查类是否加载的委托过程是单向的，这个方式虽然从结构上看比较清晰，使各个 ClassLoader 的职责非常明确，但<strong>顶层的 ClassLoader 无法访问底层的 ClassLoader 所加载的类</strong>（可见性）</p>
<h4 id="源码分析">源码分析</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">protected</span> <span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">loadClass</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">resolve</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="kd">throws</span> <span class="n">ClassNotFoundException</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">synchronized</span> <span class="o">(</span><span class="n">getClassLoadingLock</span><span class="o">(</span><span class="n">name</span><span class="o">))</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">       <span class="c1">// 调用当前类加载器的 findLoadedClass(name)，检查当前类加载器是否已加载过指定 name 的类
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">Class</span> <span class="n">c</span> <span class="o">=</span> <span class="n">findLoadedClass</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1">// 当前类加载器如果没有加载过
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="kt">long</span> <span class="n">t0</span> <span class="o">=</span> <span class="n">System</span><span class="o">.</span><span class="na">nanoTime</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">            <span class="k">try</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// 判断当前类加载器是否有父类加载器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="k">if</span> <span class="o">(</span><span class="n">parent</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                    <span class="c1">// 如果当前类加载器有父类加载器，则调用父类加载器的 loadClass(name,false)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>         			<span class="c1">// 父类加载器的 loadClass 方法，又会检查自己是否已经加载过
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="n">c</span> <span class="o">=</span> <span class="n">parent</span><span class="o">.</span><span class="na">loadClass</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                    <span class="c1">// 当前类加载器没有父类加载器，说明当前类加载器是 BootStrapClassLoader
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          			<span class="c1">// 则调用 BootStrap ClassLoader 的方法加载类
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="n">c</span> <span class="o">=</span> <span class="n">findBootstrapClassOrNull</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">                <span class="o">}</span>
</span></span><span class="line"><span class="cl">            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">ClassNotFoundException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span> <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// 如果调用父类的类加载器无法对类进行加载，则用自己的 findClass() 方法进行加载
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// 可以自定义 findClass() 方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="kt">long</span> <span class="n">t1</span> <span class="o">=</span> <span class="n">System</span><span class="o">.</span><span class="na">nanoTime</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">                <span class="n">c</span> <span class="o">=</span> <span class="n">findClass</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                <span class="c1">// this is the defining class loader; record the stats
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">sun</span><span class="o">.</span><span class="na">misc</span><span class="o">.</span><span class="na">PerfCounter</span><span class="o">.</span><span class="na">getParentDelegationTime</span><span class="o">().</span><span class="na">addTime</span><span class="o">(</span><span class="n">t1</span> <span class="o">-</span> <span class="n">t0</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">                <span class="n">sun</span><span class="o">.</span><span class="na">misc</span><span class="o">.</span><span class="na">PerfCounter</span><span class="o">.</span><span class="na">getFindClassTime</span><span class="o">().</span><span class="na">addElapsedTimeFrom</span><span class="o">(</span><span class="n">t1</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">                <span class="n">sun</span><span class="o">.</span><span class="na">misc</span><span class="o">.</span><span class="na">PerfCounter</span><span class="o">.</span><span class="na">getFindClasses</span><span class="o">().</span><span class="na">increment</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">            <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(</span><span class="n">resolve</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 链接指定的 Java 类，可以使类的 Class 对象创建完成的同时也被解析
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">resolveClass</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">c</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="破坏委派">破坏委派</h4>
<p>双亲委派模型并不是一个具有强制性约束的模型，而是 Java 设计者推荐给开发者的类加载器实现方式</p>
<p>破坏双亲委派模型的方式：</p>
<ul>
<li>
<p>自定义 ClassLoader</p>
<ul>
<li>如果不想破坏双亲委派模型，只需要重写 findClass 方法</li>
<li>如果想要去破坏双亲委派模型，需要去<strong>重写 loadClass</strong>方法</li>
</ul>
</li>
<li>
<p>引入线程<strong>上下文类加载器</strong></p>
<p>Java 提供了很多服务提供者接口（Service Provider Interface，SPI），允许第三方为这些接口提供实现。常见的 SPI 有 JDBC、JCE、JNDI 等。这些 SPI 接口由 Java 核心库来提供，而 SPI 的实现代码则是作为 Java 应用所依赖的 jar 包被包含进类路径 classpath 里，SPI 接口中的代码需要加载具体的实现类：</p>
<ul>
<li>SPI 的接口是 Java 核心库的一部分，是由引导类加载器来加载的</li>
<li>SPI 的实现类是由系统类加载器加载，引导类加载器是无法找到 SPI 的实现类，因为双亲委派模型中 BootstrapClassloader 无法委派 AppClassLoader 来加载类</li>
</ul>
<p>JDK 开发人员引入了线程上下文类加载器（Thread Context ClassLoader），这种类加载器可以通过 Thread  类的 setContextClassLoader 方法进行设置线程上下文类加载器，在执行线程中抛弃双亲委派加载模式，使程序可以逆向使用类加载器，使 Bootstrap 加载器拿到了 Application 加载器加载的类，破坏了双亲委派模型</p>
</li>
<li>
<p>实现程序的动态性，如代码热替换（Hot Swap）、模块热部署（Hot Deployment）</p>
<p>IBM 公司主导的 JSR一291（OSGiR4.2）实现模块化热部署的关键是它自定义的类加载器机制的实现，每一个程序模块（OSGi 中称为 Bundle）都有一个自己的类加载器，当更换一个 Bundle 时，就把 Bundle 连同类加载器一起换掉以实现代码的热替换，在 OSGi 环境下，类加载器不再双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的网状结构</p>
<p>当收到类加载请求时，OSGi 将按照下面的顺序进行类搜索:</p>
<ol>
<li>将以 java.* 开头的类，委派给父类加载器加载</li>
<li>否则，将委派列表名单内的类，委派给父类加载器加载</li>
<li>否则，将 Import 列表中的类，委派给 Export 这个类的 Bundle 的类加载器加载</li>
<li>否则，查找当前 Bundle 的 ClassPath，使用自己的类加载器加载</li>
<li>否则，查找类是否在自己的 Fragment Bundle 中，如果在就委派给 Fragment Bundle 类加载器加载</li>
<li>否则，查找 Dynamic Import 列表的 Bundle，委派给对应 Bundle 的类加载器加载</li>
<li>否则，类查找失败</li>
</ol>
<p>热替换是指在程序的运行过程中，不停止服务，只通过替换程序文件来修改程序的行为，<strong>热替换的关键需求在于服务不能中断</strong>，修改必须立即表现正在运行的系统之中</p>
</li>
</ul>
<h2 id="对象创建">对象创建</h2>
<h3 id="生命周期-1">生命周期</h3>
<p>在 Java 中，对象的生命周期包括以下几个阶段：</p>
<ol>
<li>
<pre><code> 创建阶段 (Created)：
</code></pre>
</li>
<li>
<pre><code> 应用阶段 (In Use)：对象至少被一个强引用持有着
</code></pre>
</li>
<li>
<pre><code> 不可见阶段 (Invisible)：程序的执行已经超出了该对象的作用域，不再持有该对象的任何强引用
</code></pre>
</li>
<li>
<pre><code> 不可达阶段 (Unreachable)：该对象不再被任何强引用所持有，包括 GC Root 的强引用
</code></pre>
</li>
<li>
<pre><code> 收集阶段 (Collected)：垃圾回收器对该对象的内存空间重新分配做好准备，该对象如果重写了 finalize() 方法，则会去执行该方法
</code></pre>
</li>
<li>
<pre><code> 终结阶段 (Finalized)：等待垃圾回收器对该对象空间进行回收，当对象执行完 finalize() 方法后仍然处于不可达状态时进入该阶段
</code></pre>
</li>
<li>
<pre><code> 对象空间重分配阶段 (De-allocated)：垃圾回收器对该对象的所占用的内存空间进行回收或者再分配
</code></pre>
</li>
</ol>
<p>参考文章：https://blog.csdn.net/sodino/article/details/38387049</p>
<h3 id="创建时机">创建时机</h3>
<p>类在第一次实例化加载一次，后续实例化不再加载，引用第一次加载的类</p>
<p>Java 对象创建时机：</p>
<ol>
<li>
<p>使用 new 关键字创建对象：由执行类实例创建表达式而引起的对象创建</p>
</li>
<li>
<p>使用 Class 类的 newInstance 方法（反射机制）</p>
</li>
<li>
<p>使用 Constructor 类的 newInstance 方法（反射机制）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Student</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kt">int</span> <span class="n">id</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="nf">Student</span><span class="o">(</span><span class="n">Integer</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">id</span> <span class="o">=</span> <span class="n">id</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">Constructor</span><span class="o">&lt;</span><span class="n">Student</span><span class="o">&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="n">Student</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getConstructor</span><span class="o">(</span><span class="n">Integer</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">Student</span> <span class="n">stu</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="na">newInstance</span><span class="o">(</span><span class="n">123</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>使用 newInstance 方法的这两种方式创建对象使用的就是 Java 的反射机制，事实上 Class 的 newInstance 方法内部调用的也是 Constructor 的 newInstance 方法</p>
</li>
<li>
<p>使用 Clone 方法创建对象：用 clone 方法创建对象的过程中并不会调用任何构造函数，要想使用 clone 方法，我们就必须先实现 Cloneable 接口并实现其定义的 clone 方法</p>
</li>
<li>
<p>使用（反）序列化机制创建对象：当反序列化一个对象时，JVM 会创建一个<strong>单独的对象</strong>，在此过程中，JVM 并不会调用任何构造函数，为了反序列化一个对象，需要让类实现 Serializable 接口</p>
</li>
</ol>
<p>从 Java 虚拟机层面看，除了使用 new 关键字创建对象的方式外，其他方式全部都是通过转变为 invokevirtual 指令直接创建对象的</p>
<h3 id="创建过程">创建过程</h3>
<p>创建对象的过程：</p>
<ol>
<li>
<p>判断对象对应的类是否加载、链接、初始化</p>
</li>
<li>
<p>为对象分配内存：指针碰撞、空闲链表。当一个对象被创建时，虚拟机就会为其分配内存来存放对象的实例变量及其从父类继承过来的实例变量，即使从<strong>隐藏变量</strong>也会被分配空间（继承部分解释了为什么会隐藏）</p>
</li>
<li>
<p>处理并发安全问题：</p>
<ul>
<li>采用 CAS 配上自旋保证更新的原子性</li>
<li>每个线程预先分配一块 TLAB</li>
</ul>
</li>
<li>
<p>初始化分配的空间：虚拟机将分配到的内存空间都初始化为零值（不包括对象头），保证对象实例字段在不赋值时可以直接使用，程序能访问到这些字段的数据类型所对应的零值</p>
</li>
<li>
<p>设置对象的对象头：将对象的所属类（类的元数据信息）、对象的 HashCode、对象的 GC 信息、锁信息等数据存储在对象头中</p>
</li>
<li>
<p>执行 init 方法进行实例化：实例变量初始化、实例代码块初始化 、构造函数初始化</p>
<ul>
<li>
<p>实例变量初始化与实例代码块初始化：</p>
<p>对实例变量直接赋值或者使用实例代码块赋值，<strong>编译器会将其中的代码放到类的构造函数中去</strong>，并且这些代码会被放在对超类构造函数的调用语句之后（Java 要求构造函数的第一条语句必须是超类构造函数的调用语句），构造函数本身的代码之前</p>
</li>
<li>
<p>构造函数初始化：</p>
<p><strong>Java 要求在实例化类之前，必须先实例化其超类，以保证所创建实例的完整性</strong>，在准备实例化一个类的对象前，首先准备实例化该类的父类，如果该类的父类还有父类，那么准备实例化该类的父类的父类，依次递归直到递归到 Object 类。然后从 Object 类依次对以下各类进行实例化，初始化父类中的变量和执行构造函数</p>
</li>
</ul>
</li>
</ol>
<h4 id="tlab">TLAB</h4>
<p>TLAB：Thread Local Allocation Buffer，为每个线程在堆内单独分配了一个缓冲区，多线程分配内存时，使用 TLAB 可以避免线程安全问题，同时还能够提升内存分配的吞吐量，这种内存分配方式叫做<strong>快速分配策略</strong></p>
<ul>
<li>栈上分配使用的是栈来进行对象内存的分配</li>
<li>TLAB 分配使用的是 Eden 区域进行内存分配，属于堆内存</li>
</ul>
<p>堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据，由于对象实例的创建在 JVM 中非常频繁，因此在并发环境下为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度</p>
<p>问题：堆空间都是共享的么？ 不一定，因为还有 TLAB，在堆中划分出一块区域，为每个线程所独占</p>
<p><img src="/posts/java/jvm-%E7%B1%BB%E5%8A%A0%E8%BD%BD/JVM-TLAB%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5.jpg"
	width="1019"
	height="508"
	srcset="/posts/java/jvm-%E7%B1%BB%E5%8A%A0%E8%BD%BD/JVM-TLAB%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5_hu7bee462e369a6bde2c91f390735a88cb_81901_480x0_resize_q75_box.jpg 480w, /posts/java/jvm-%E7%B1%BB%E5%8A%A0%E8%BD%BD/JVM-TLAB%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5_hu7bee462e369a6bde2c91f390735a88cb_81901_1024x0_resize_q75_box.jpg 1024w"
	loading="lazy"
	
		alt="JVM-TLAB内存分配策略"
	
	
		class="gallery-image" 
		data-flex-grow="200"
		data-flex-basis="481px"
	
></p>
<p>JVM 是将 TLAB 作为内存分配的首选，但不是所有的对象实例都能够在 TLAB 中成功分配内存，一旦对象在 TLAB 空间分配内存失败时，JVM 就会通过<strong>使用加锁机制确保数据操作的原子性</strong>，从而直接在堆中分配内存</p>
<p>栈上分配优先于 TLAB 分配进行，逃逸分析中若可进行栈上分配优化，会优先进行对象栈上直接分配内存</p>
<p>参数设置：</p>
<ul>
<li>
<p><code>-XX:UseTLAB</code>：设置是否开启 TLAB 空间</p>
</li>
<li>
<p><code>-XX:TLABWasteTargetPercent</code>：设置 TLAB 空间所占用 Eden 空间的百分比大小，默认情况下 TLAB 空间的内存非常小，仅占有整个 Eden 空间的1%</p>
</li>
<li>
<p><code>-XX:TLABRefillWasteFraction</code>：指当 TLAB 空间不足，请求分配的对象内存大小超过此阈值时不会进行 TLAB 分配，直接进行堆内存分配，否则还是会优先进行 TLAB 分配</p>
</li>
</ul>
<p><img src="/posts/java/jvm-%E7%B1%BB%E5%8A%A0%E8%BD%BD/JVM-TLAB%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E8%BF%87%E7%A8%8B.jpg"
	width="1048"
	height="487"
	srcset="/posts/java/jvm-%E7%B1%BB%E5%8A%A0%E8%BD%BD/JVM-TLAB%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E8%BF%87%E7%A8%8B_hu207684061cb338e73386fb993f778b6e_163864_480x0_resize_q75_box.jpg 480w, /posts/java/jvm-%E7%B1%BB%E5%8A%A0%E8%BD%BD/JVM-TLAB%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E8%BF%87%E7%A8%8B_hu207684061cb338e73386fb993f778b6e_163864_1024x0_resize_q75_box.jpg 1024w"
	loading="lazy"
	
		alt="JVM-TLAB内存分配过程"
	
	
		class="gallery-image" 
		data-flex-grow="215"
		data-flex-basis="516px"
	
></p>
<h3 id="承上启下">承上启下</h3>
<ol>
<li>
<p>一个实例变量在对象初始化的过程中会被赋值几次？一个实例变量最多可以被初始化 4 次</p>
<p>JVM 在为一个对象分配完内存之后，会给每一个实例变量赋予默认值，这个实例变量被第一次赋值；在声明实例变量的同时对其进行了赋值操作，那么这个实例变量就被第二次赋值；在实例代码块中又对变量做了初始化操作，那么这个实例变量就被第三次赋值；在构造函数中也对变量做了初始化操作，那么这个实例变量就被第四次赋值</p>
</li>
<li>
<p>类的初始化过程与类的实例化过程的异同？</p>
<p>类的初始化是指类加载过程中的初始化阶段对类变量按照代码进行赋值的过程；类的实例化是指在类完全加载到内存中后创建对象的过程（类的实例化触发了类的初始化，先初始化才能实例化）</p>
</li>
<li>
<p>假如一个类还未加载到内存中，那么在创建一个该类的实例时，具体过程是怎样的？（<strong>经典案例</strong>）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">StaticTest</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">staticFunction</span><span class="o">();</span><span class="c1">//调用静态方法，触发初始化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">static</span> <span class="n">StaticTest</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StaticTest</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">static</span> <span class="o">{</span>   <span class="c1">//静态代码块
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;1&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="o">{</span>       <span class="c1">// 实例代码块
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;2&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">StaticTest</span><span class="o">()</span> <span class="o">{</span>    <span class="c1">// 实例构造器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;3&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;a=&#34;</span> <span class="o">+</span> <span class="n">a</span> <span class="o">+</span> <span class="s">&#34;,b=&#34;</span> <span class="o">+</span> <span class="n">b</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">staticFunction</span><span class="o">()</span> <span class="o">{</span>   <span class="c1">// 静态方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;4&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">110</span><span class="o">;</span>    		<span class="c1">// 实例变量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">static</span> <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="n">112</span><span class="o">;</span>     <span class="c1">// 静态变量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">}</span><span class="cm">/* Output: 
</span></span></span><span class="line"><span class="cl"><span class="cm">        2
</span></span></span><span class="line"><span class="cl"><span class="cm">        3
</span></span></span><span class="line"><span class="cl"><span class="cm">        a=110,b=0
</span></span></span><span class="line"><span class="cl"><span class="cm">        1
</span></span></span><span class="line"><span class="cl"><span class="cm">        4
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span><span class="c1">//:~
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><code>static StaticTest st = new StaticTest();</code>：</p>
<ul>
<li>
<p>实例实例化不一定要在类初始化结束之后才开始</p>
</li>
<li>
<p>在同一个类加载器下，一个类型只会被初始化一次。所以一旦开始初始化一个类，无论是否完成后续都不会再重新触发该类型的初始化阶段了（只考虑在同一个类加载器下的情形）。因此在实例化上述程序中的 st 变量时，<strong>实际上是把实例化嵌入到了静态初始化流程中，并且在上面的程序中，嵌入到了静态初始化的起始位置</strong>，这就导致了实例初始化完全发生在静态初始化之前，这也是导致 a 为 110，b 为 0 的原因</p>
</li>
</ul>
<p>代码等价于：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">StaticTest</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">&lt;</span><span class="n">clinit</span><span class="o">&gt;(){</span>
</span></span><span class="line"><span class="cl">        <span class="n">a</span> <span class="o">=</span> <span class="n">110</span><span class="o">;</span>    <span class="c1">// 实例变量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;2&#34;</span><span class="o">);</span>	<span class="c1">// 实例代码块
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;3&#34;</span><span class="o">);</span>	<span class="c1">// 实例构造器中代码的执行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;a=&#34;</span> <span class="o">+</span> <span class="n">a</span> <span class="o">+</span> <span class="s">&#34;,b=&#34;</span> <span class="o">+</span> <span class="n">b</span><span class="o">);</span>  <span class="c1">// 实例构造器中代码的执行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">类变量st被初始化</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;1&#34;</span><span class="o">);</span>	<span class="c1">//静态代码块
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">类变量b被初始化为112</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ol>

</section>


    <footer class="article-footer">
    
    <section class="article-tags">
        
            <a href="/tags/jvm/">jvm</a>
        
            <a href="/tags/java/">Java</a>
        
    </section>


    </footer>


    
</article>

    

    

<aside class="related-content--wrapper">
    <h2 class="section-title">相关文章</h2>
    <div class="related-content">
        <div class="flex article-list--tile">
            
                
<article class="">
    <a href="/posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/">
        
        

        <div class="article-details">
            <h2 class="article-title">JVM-垃圾回收</h2>
        </div>
    </a>
</article>

            
                
<article class="">
    <a href="/posts/java/jvm-%E9%94%81%E4%BC%98%E5%8C%96/">
        
        

        <div class="article-details">
            <h2 class="article-title">线程安全与锁优化</h2>
        </div>
    </a>
</article>

            
                
<article class="">
    <a href="/posts/java/netty%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/">
        
        

        <div class="article-details">
            <h2 class="article-title">Netty学习总结</h2>
        </div>
    </a>
</article>

            
                
<article class="">
    <a href="/posts/java/spring%E5%B8%B8%E8%A7%81%E9%A2%98%E7%9B%AE/">
        
        

        <div class="article-details">
            <h2 class="article-title">Spring常见题目</h2>
        </div>
    </a>
</article>

            
                
<article class="">
    <a href="/posts/java/java-nio%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/">
        
        

        <div class="article-details">
            <h2 class="article-title">Java-NIO的基本使用</h2>
        </div>
    </a>
</article>

            
        </div>
    </div>
</aside>

     
    
        
    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            2020 - 
        
        2022 isheihei&#39;s blog
    </section>
    
    <section class="powerby">
        
            浙ICP备2022017844号 <br/>
        Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <br />
        Theme <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.12.0">Stack</a></b> designed by <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a>
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
    <aside class="sidebar right-sidebar sticky">
        
            
                
    <section class="widget archives">
        <div class="widget-icon">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



        </div>
        <h2 class="widget-title section-title">目录</h2>
        
        <div class="widget--toc">
            <nav id="TableOfContents">
  <ol>
    <li><a href="#类加载过程">类加载过程</a>
      <ol>
        <li><a href="#生命周期">生命周期</a></li>
        <li><a href="#加载阶段">加载阶段</a></li>
        <li><a href="#链接阶段">链接阶段</a>
          <ol>
            <li><a href="#验证">验证</a></li>
            <li><a href="#准备">准备</a></li>
            <li><a href="#解析">解析</a></li>
          </ol>
        </li>
        <li><a href="#初始化">初始化</a>
          <ol>
            <li><a href="#介绍">介绍</a></li>
            <li><a href="#clinit">clinit</a></li>
            <li><a href="#时机">时机</a></li>
            <li><a href="#init">init</a></li>
          </ol>
        </li>
        <li><a href="#卸载阶段">卸载阶段</a></li>
      </ol>
    </li>
    <li><a href="#类加载器">类加载器</a>
      <ol>
        <li><a href="#类加载">类加载</a></li>
        <li><a href="#加载器">加载器</a></li>
        <li><a href="#常用api">常用API</a></li>
        <li><a href="#加载模型">加载模型</a>
          <ol>
            <li><a href="#加载机制">加载机制</a></li>
            <li><a href="#双亲委派">双亲委派</a></li>
            <li><a href="#源码分析">源码分析</a></li>
            <li><a href="#破坏委派">破坏委派</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#对象创建">对象创建</a>
      <ol>
        <li><a href="#生命周期-1">生命周期</a></li>
        <li><a href="#创建时机">创建时机</a></li>
        <li><a href="#创建过程">创建过程</a>
          <ol>
            <li><a href="#tlab">TLAB</a></li>
          </ol>
        </li>
        <li><a href="#承上启下">承上启下</a></li>
      </ol>
    </li>
  </ol>
</nav>
        </div>
    </section>

            
        
    </aside>


        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
