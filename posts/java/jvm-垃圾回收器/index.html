<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content='jvm垃圾回收总结'><title>JVM 垃圾回收</title>

<link rel='canonical' href='https://isheihei.github.io/posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/'>

<link rel="stylesheet" href="/scss/style.min.d9e0562edde3d2bdf9d3d81365095a29d062ddaaa5d671f22168e57dfdb18b4f.css">
<meta property='og:title' content='JVM 垃圾回收'>
<meta property='og:description' content='jvm垃圾回收总结'>
<meta property='og:url' content='https://isheihei.github.io/posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/'>
<meta property='og:site_name' content='isheihei&#39;s blog'>
<meta property='og:type' content='article'><meta property='article:section' content='Posts' /><meta property='article:tag' content='jvm' /><meta property='article:tag' content='Java' /><meta property='article:published_time' content='2022-05-24T17:24:10&#43;08:00'/><meta property='article:modified_time' content='2022-05-24T17:24:10&#43;08:00'/>
<meta name="twitter:title" content="JVM 垃圾回收">
<meta name="twitter:description" content="jvm垃圾回收总结">
    
    
    <link rel="shortcut icon" href= "/img/favicon_hu2f307a5f23288c798230c92f583cd3bd_467065_32x0_resize_box_3.png" />

    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="切换菜单">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/">
                
                    
                    
                    
                        
                        <img src="/img/avatar_hu2f307a5f23288c798230c92f583cd3bd_467065_300x0_resize_box_3.png" width="300"
                            height="300" class="site-logo" loading="lazy" alt="Avatar">
                    
                
                </a>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/">isheihei&#39;s blog</a></h1>
            <h2 class="site-description">兼听则明，三思而后行。</h2>
        </div>
    </header><ol class="menu" id="main-menu">
        
        
        

        <li >
            <a href='/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>主页</span>
            </a>
        </li>
        
        

        <li >
            <a href='/about/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="7" r="4" />
  <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" />
</svg>



                
                <span>关于</span>
            </a>
        </li>
        
        

        <li >
            <a href='/archives/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>归档</span>
            </a>
        </li>
        
        

        <li >
            <a href='/search/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>Search</span>
            </a>
        </li>
        
        

        <li >
            <a href='/links/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5" />
  <path d="M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5" />
</svg>



                
                <span>Links</span>
            </a>
        </li>
        

        <div class="menu-bottom-section">
            
            
                <li id="dark-mode-toggle">
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                    <span>暗色模式</span>
                </li>
            
        </div>
    </ol>
</aside>
<main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/java/" style="background-color: #729fd8; color: #fff;">
                Java
            </a>
        
    </header>
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/">JVM 垃圾回收</a>
        </h2>
    
        
        <h3 class="article-subtitle">
            jvm垃圾回收总结
        </h3>
        
    </div>

    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">May 24, 2022</time>
            </div>
        

        
    </footer>
    

    
</div>
</header>

    <section class="article-content">
    
    
    <h2 id="可达性分析">可达性分析</h2>
<h3 id="gc-roots">GC Roots</h3>
<p>可达性分析算法：也可以称为根搜索算法、追踪性垃圾收集</p>
<p>GC Roots 对象：</p>
<ul>
<li>虚拟机栈中局部变量表中引用的对象：各个线程被调用的方法中使用到的参数、局部变量等</li>
<li>本地方法栈中引用的对象</li>
<li>堆中类静态属性引用的对象</li>
<li>方法区中的常量引用的对象</li>
<li>字符串常量池（string Table）里的引用</li>
<li>同步锁 synchronized 持有的对象</li>
</ul>
<p><strong>GC Roots 是一组活跃的引用，不是对象</strong>，放在 GC Roots Set 集合</p>
<h3 id="工作原理">工作原理</h3>
<p>可达性分析算法以根对象集合（GCRoots）为起始点，从上至下的方式搜索被根对象集合所连接的目标对象</p>
<p>分析工作必须在一个保障<strong>一致性的快照</strong>中进行，否则结果的准确性无法保证，这也是导致 GC 进行时必须 Stop The World 的一个原因</p>
<p>基本原理：</p>
<ul>
<li>
<p>可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索走过的路径称为引用链</p>
</li>
<li>
<p>如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象</p>
</li>
<li>
<p>在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象</p>
</li>
</ul>
<p><img src="/posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/JVM-%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95.png"
	width="1057"
	height="710"
	srcset="/posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/JVM-%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95_hua2c8e35785c8874fd8d82cf317422726_75374_480x0_resize_box_3.png 480w, /posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/JVM-%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95_hua2c8e35785c8874fd8d82cf317422726_75374_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="JVM-可达性分析算法"
	
	
		class="gallery-image" 
		data-flex-grow="148"
		data-flex-basis="357px"
	
></p>
<h3 id="三色标记">三色标记</h3>
<h3 id="标记算法">标记算法</h3>
<p>三色标记法把遍历对象图过程中遇到的对象，标记成以下三种颜色：</p>
<ul>
<li>白色：尚未访问过</li>
<li>灰色：本对象已访问过，但是本对象引用到的其他对象尚未全部访问</li>
<li>黑色：本对象已访问过，而且本对象引用到的其他对象也全部访问完成</li>
</ul>
<p>当 Stop The World (STW) 时，对象间的引用是不会发生变化的，可以轻松完成标记，遍历访问过程为：</p>
<ol>
<li>初始时，所有对象都在白色集合</li>
<li>将 GC Roots 直接引用到的对象挪到灰色集合</li>
<li>从灰色集合中获取对象：
<ul>
<li>将本对象引用到的其他对象全部挪到灰色集合中</li>
<li>将本对象挪到黑色集合里面</li>
</ul>
</li>
<li>重复步骤 3，直至灰色集合为空时结束</li>
<li>结束后，仍在白色集合的对象即为 GC Roots 不可达，可以进行回收</li>
</ol>
<p><img src="/posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/JVM-%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95%E8%BF%87%E7%A8%8B.gif"
	width="706"
	height="451"
	srcset="/posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/JVM-%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95%E8%BF%87%E7%A8%8B_hud33a6cf6e4a2927aebe73fd8a24ced0d_152861_480x0_resize_box.gif 480w, /posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/JVM-%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95%E8%BF%87%E7%A8%8B_hud33a6cf6e4a2927aebe73fd8a24ced0d_152861_1024x0_resize_box.gif 1024w"
	loading="lazy"
	
		alt="JVM-三色标记法过程"
	
	
		class="gallery-image" 
		data-flex-grow="156"
		data-flex-basis="375px"
	
></p>
<h3 id="并发标记">并发标记</h3>
<p>并发标记时，对象间的引用可能发生变化，多标和漏标的情况就有可能发生</p>
<p><strong>多标情况：<strong>当 E 变为灰色或黑色时，其他线程断开的 D 对 E 的引用，导致这部分对象仍会被标记为存活，本轮 GC 不会回收这部分内存，这部分本应该回收但是没有回收到的内存，被称之为</strong>浮动垃圾</strong></p>
<ul>
<li>针对并发标记开始后的<strong>新对象</strong>，通常的做法是直接全部当成黑色，也算浮动垃圾</li>
<li>浮动垃圾并不会影响应用程序的正确性，只是需要等到下一轮垃圾回收中才被清除</li>
</ul>
<p><img src="/posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/JVM-%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95%E5%A4%9A%E6%A0%87%E6%83%85%E5%86%B5.png"
	width="683"
	height="420"
	srcset="/posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/JVM-%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95%E5%A4%9A%E6%A0%87%E6%83%85%E5%86%B5_hu693bfcae16628182766291aa82f4317e_13278_480x0_resize_box_3.png 480w, /posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/JVM-%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95%E5%A4%9A%E6%A0%87%E6%83%85%E5%86%B5_hu693bfcae16628182766291aa82f4317e_13278_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="JVM-三色标记法多标情况"
	
	
		class="gallery-image" 
		data-flex-grow="162"
		data-flex-basis="390px"
	
></p>
<p><strong>漏标情况：</strong></p>
<ul>
<li>条件一：灰色对象断开了对一个白色对象的引用（直接或间接），即灰色对象原成员变量的引用发生了变化</li>
<li>条件二：其他线程中修改了黑色对象，插入了一条或多条对该白色对象的新引用</li>
<li>结果：导致该白色对象当作垃圾被 GC，影响到了程序的正确性</li>
</ul>
<p><img src="/posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/JVM-%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95%E6%BC%8F%E6%A0%87%E6%83%85%E5%86%B5.png"
	width="689"
	height="432"
	srcset="/posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/JVM-%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95%E6%BC%8F%E6%A0%87%E6%83%85%E5%86%B5_hub7806eff3b888461f9e8c79abec69ead_14122_480x0_resize_box_3.png 480w, /posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/JVM-%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95%E6%BC%8F%E6%A0%87%E6%83%85%E5%86%B5_hub7806eff3b888461f9e8c79abec69ead_14122_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="JVM-三色标记法漏标情况"
	
	
		class="gallery-image" 
		data-flex-grow="159"
		data-flex-basis="382px"
	
></p>
<p>代码角度解释漏标：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Object</span> <span class="n">G</span> <span class="o">=</span> <span class="n">objE</span><span class="o">.</span><span class="na">fieldG</span><span class="o">;</span> <span class="c1">// 读
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">objE</span><span class="o">.</span><span class="na">fieldG</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>  	<span class="c1">// 写
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">objD</span><span class="o">.</span><span class="na">fieldG</span> <span class="o">=</span> <span class="n">G</span><span class="o">;</span>     	<span class="c1">// 写
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>为了解决问题，可以操作上面三步，<strong>将对象 G 记录起来，然后作为灰色对象再进行遍历</strong>，比如放到一个特定的集合，等初始的 GC Roots 遍历完（并发标记），再遍历该集合（重新标记）</p>
<blockquote>
<p>所以<strong>重新标记需要 STW</strong>，应用程序一直在运行，该集合可能会一直增加新的对象，导致永远都运行不完</p>
</blockquote>
<p>解决方法：添加读写屏障，读屏障拦截第一步，写屏障拦截第二三步，在读写前后进行一些后置处理：</p>
<ul>
<li>
<p><strong>写屏障 + 增量更新</strong>：黑色对象新增引用，会将黑色对象变成灰色对象，最后对该节点重新扫描</p>
<p>增量更新 (Incremental Update) 破坏了条件二，从而保证了不会漏标</p>
<p>缺点：对黑色变灰的对象重新扫描所有引用，比较耗费时间</p>
</li>
<li>
<p><strong>写屏障 (Store Barrier) + SATB</strong>：当原来成员变量的引用发生变化之前，记录下原来的引用对象</p>
<p>保留 GC 开始时的对象图，即原始快照 SATB，当 GC Roots 确定后，对象图就已经确定，那后续的标记也应该是按照这个时刻的对象图走，如果期间对白色对象有了新的引用会记录下来，并且将白色对象变灰（说明可达了），重新扫描该对象的引用关系</p>
<p>SATB (Snapshot At The Beginning) 破坏了条件一，从而保证了不会漏标</p>
</li>
<li>
<p><strong>读屏障 (Load Barrier)</strong>：破坏条件二，黑色对象引用白色对象的前提是获取到该对象，此时读屏障发挥作用</p>
</li>
</ul>
<p>以 Java HotSpot VM 为例，其并发标记时对漏标的处理方案如下：</p>
<ul>
<li>CMS：写屏障 + 增量更新</li>
<li>G1：写屏障 + SATB</li>
<li>ZGC：读屏障</li>
</ul>
<h2 id="垃圾回收器">垃圾回收器</h2>
<h3 id="普通">普通</h3>
<h4 id="serial">Serial</h4>
<p>Serial：串行垃圾收集器，作用于新生代，是指使用单线程进行垃圾回收，采用<strong>复制算法</strong>，新生代基本都是复制算法，因为分区了</p>
<p><strong>STW（Stop-The-World）</strong>：垃圾回收时，只有一个线程在工作，并且 Java 应用中的所有线程都要暂停，等待垃圾回收的完成</p>
<p><strong>Serial old</strong>：执行老年代垃圾回收的串行收集器，内存回收算法使用的是<strong>标记-整理算法</strong>，同样也采用了串行回收和 STW 机制</p>
<ul>
<li>Serial old 是 Client 模式下默认的老年代的垃圾回收器</li>
<li>Serial old 在 Server 模式下主要有两个用途：
<ul>
<li>在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用</li>
<li>作为老年代 CMS 收集器的<strong>后备垃圾回收方案</strong>，在并发收集发生 Concurrent Mode Failure 时使用</li>
</ul>
</li>
</ul>
<p>开启参数：<code>-XX:+UseSerialGC</code> 等价于新生代用 Serial GC 且老年代用 Serial old GC</p>
<p>优点：简单而高效（与其他收集器的单线程比），对于限定单个 CPU 的环境来说，Serial 收集器由于没有线程交互的开销，可以获得最高的单线程收集效率</p>
<p>缺点：对于交互性较强的应用而言，这种垃圾收集器是不能够接受的，比如 JavaWeb 应用</p>
<h4 id="parnew">ParNew</h4>
<p>Par 是 Parallel 并行的缩写，<strong>New 是只能处理的是新生代</strong></p>
<p>并行垃圾收集器在串行垃圾收集器的基础之上做了改进，<strong>采用复制算法</strong>，将单线程改为了多线程进行垃圾回收，可以缩短垃圾回收的时间</p>
<p>对于其他的行为（收集算法、stop the world、对象分配规则、回收策略等）同 Serial 收集器一样，应用在年轻代，除 Serial 外，只有<strong>ParNew GC 能与 CMS 收集器配合工作</strong></p>
<p>相关参数：</p>
<ul>
<li>
<p><code>-XX：+UseParNewGC</code>：表示年轻代使用并行收集器，不影响老年代</p>
</li>
<li>
<p><code>-XX:ParallelGCThreads</code>：默认开启和 CPU 数量相同的线程数</p>
</li>
</ul>
<p>ParNew 是很多 JVM 运行在 Server 模式下新生代的默认垃圾收集器</p>
<ul>
<li>对于新生代，回收次数频繁，使用并行方式高效</li>
<li>对于老年代，回收次数少，使用串行方式节省资源（CPU 并行需要切换线程，串行可以省去切换线程的资源）</li>
</ul>
<h4 id="parallel">Parallel</h4>
<p><strong>Parallel Scavenge</strong> 收集器是应用于新生代的并行垃圾回收器，<strong>采用复制算法</strong>、并行回收和 Stop the World 机制</p>
<p>**Parallel Old ** 收集器：是一个应用于老年代的并行垃圾回收器，<strong>采用标记-整理算法</strong></p>
<p>对比其他回收器：</p>
<ul>
<li>其它收集器目标是尽可能缩短垃圾收集时用户线程的停顿时间</li>
<li>Parallel 目标是达到一个可控制的吞吐量，被称为<strong>吞吐量优先</strong>收集器</li>
<li>Parallel Scavenge 对比 ParNew 拥有<strong>自适应调节策略</strong>，可以通过一个开关参数打开 GC Ergonomics</li>
</ul>
<p>应用场景：</p>
<ul>
<li>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验</li>
<li>高吞吐量可以高效率地利用 CPU 时间，尽快完成程序的运算任务，适合在后台运算而不需要太多交互</li>
</ul>
<p>停顿时间和吞吐量的关系：新生代空间变小 → 缩短停顿时间 → 垃圾回收变得频繁 → 导致吞吐量下降</p>
<p>在注重吞吐量及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge + Parallel Old 收集器，在 Server 模式下的内存回收性能很好，<strong>Java8 默认是此垃圾收集器组合</strong></p>
<p>参数配置：</p>
<ul>
<li><code>-XX：+UseParallelGC</code>：手动指定年轻代使用 Paralle 并行收集器执行内存回收任务</li>
<li><code>-XX：+UseParalleloldcc</code>：手动指定老年代使用并行回收收集器执行内存回收任务
<ul>
<li>上面两个参数，默认开启一个，另一个也会被开启（互相激活），默认 JDK8 是开启的</li>
</ul>
</li>
<li><code>-XX:+UseAdaptivesizepplicy</code>：设置 Parallel scavenge 收集器具有<strong>自适应调节策略</strong>，在这种模式下，年轻代的大小、Eden 和 Survivor 的比例、晋升老年代的对象年龄等参数会被自动调整，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量</li>
<li><code>-XX:ParallelGcrhreads</code>：设置年轻代并行收集器的线程数，一般与 CPU 数量相等，以避免过多的线程数影响垃圾收集性能
<ul>
<li>在默认情况下，当 CPU 数量小于 8 个，ParallelGcThreads 的值等于 CPU 数量</li>
<li>当 CPU 数量大于 8 个，ParallelGCThreads 的值等于 3+[5*CPU Count]/8]</li>
</ul>
</li>
<li><code>-XX:MaxGCPauseMillis</code>：设置垃圾收集器最大停顿时间（即 STW 的时间），单位是毫秒
<ul>
<li>对于用户来讲，停顿时间越短体验越好；在服务器端，注重高并发，整体的吞吐量</li>
<li>为了把停顿时间控制在 MaxGCPauseMillis 以内，收集器在工作时会调整 Java 堆大小或其他一些参数</li>
</ul>
</li>
<li><code>-XX:GCTimeRatio</code>：垃圾收集时间占总时间的比例 =1/(N+1)，用于衡量吞吐量的大小
<ul>
<li>取值范围（0，100）。默认值 99，也就是垃圾回收时间不超过 1</li>
<li>与 <code>-xx:MaxGCPauseMillis</code> 参数有一定矛盾性，暂停时间越长，Radio 参数就容易超过设定的比例</li>
</ul>
</li>
</ul>
<h3 id="并发">并发</h3>
<h4 id="cms">CMS</h4>
<p>CMS 全称 Concurrent Mark Sweep，是一款<strong>并发的、使用标记-清除</strong>算法、针对老年代的垃圾回收器，其最大特点是<strong>让垃圾收集线程与用户线程同时工作</strong></p>
<p>CMS 收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间，停顿时间越短（<strong>低延迟</strong>）越适合与用户交互的程序，良好的响应速度能提升用户体验</p>
<p>分为以下四个流程：</p>
<ul>
<li>初始标记：使用 STW 出现短暂停顿，仅标记一下 GC Roots 能直接关联到的对象，速度很快</li>
<li>并发标记：进行 GC Roots 开始遍历整个对象图，在整个回收过程中耗时最长，不需要 STW，可以与用户线程并发运行</li>
<li>重新标记：修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，比初始标记时间长但远比并发标记时间短，需要 STW（不停顿就会一直变化，采用写屏障 + 增量更新来避免漏标情况）</li>
<li>并发清除：清除标记为可以回收对象，<strong>不需要移动存活对象</strong>，所以这个阶段可以与用户线程同时并发的</li>
</ul>
<p>Mark Sweep 会造成内存碎片，不把算法换成 Mark Compact 的原因：Mark Compact 算法会整理内存，导致用户线程使用的<strong>对象的地址改变</strong>，影响用户线程继续执行</p>
<p>在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿</p>
<p><img src="/posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/JVM-CMS%E6%94%B6%E9%9B%86%E5%99%A8.png"
	width="1061"
	height="328"
	srcset="/posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/JVM-CMS%E6%94%B6%E9%9B%86%E5%99%A8_hu56ccf0817be9cd7594dce5ab3d2c7565_171134_480x0_resize_box_3.png 480w, /posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/JVM-CMS%E6%94%B6%E9%9B%86%E5%99%A8_hu56ccf0817be9cd7594dce5ab3d2c7565_171134_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="JVM-CMS收集器"
	
	
		class="gallery-image" 
		data-flex-grow="323"
		data-flex-basis="776px"
	
></p>
<p>优点：并发收集、低延迟</p>
<p>缺点：</p>
<ul>
<li>
<p>吞吐量降低：在并发阶段虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，CPU 利用率不够高</p>
</li>
<li>
<p>CMS 收集器<strong>无法处理浮动垃圾</strong>，可能出现 Concurrent Mode Failure 导致另一次 Full GC 的产生</p>
<p>浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾（产生了新对象），这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，CMS 收集需要预留出一部分内存，不能等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS，导致很长的停顿时间</p>
</li>
<li>
<p>标记 - 清除算法导致的空间碎片，往往出现老年代空间无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC；为新对象分配内存空间时，将无法使用指针碰撞（Bump the Pointer）技术，而只能够选择空闲列表（Free List）执行内存分配</p>
</li>
</ul>
<p>参数设置：</p>
<ul>
<li>
<p><code>-XX：+UseConcMarkSweepGC</code>：手动指定使用 CMS 收集器执行内存回收任务</p>
<p>开启该参数后会自动将 <code>-XX:+UseParNewGC</code> 打开，即：ParNew + CMS + Serial old的组合</p>
</li>
<li>
<p><code>-XX:CMSInitiatingoccupanyFraction</code>：设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收</p>
<ul>
<li>JDK5 及以前版本的默认值为 68，即当老年代的空间使用率达到 68% 时，会执行一次CMS回收</li>
<li>JDK6 及以上版本默认值为 92%</li>
</ul>
</li>
<li>
<p><code>-XX:+UseCMSCompactAtFullCollection</code>：用于指定在执行完 Full GC 后对内存空间进行压缩整理，以此避免内存碎片的产生，由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长</p>
</li>
<li>
<p><code>-XX:CMSFullGCsBeforecompaction</code>：<strong>设置在执行多少次 Full GC 后对内存空间进行压缩整理</strong></p>
</li>
<li>
<p><code>-XX:ParallelCMSThreads</code>：设置 CMS 的线程数量</p>
<ul>
<li>CMS 默认启动的线程数是 (ParallelGCThreads+3)/4，ParallelGCThreads 是年轻代并行收集器的线程数</li>
<li>收集线程占用的 CPU 资源多于25%，对用户程序影响可能较大；当 CPU 资源比较紧张时，受到 CMS 收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕</li>
</ul>
</li>
</ul>
<h4 id="g1-收集器">G1 收集器</h4>
<h5 id="g1-特点">G1 特点</h5>
<p>G1（Garbage-First）是一款面向服务端应用的垃圾收集器，<strong>应用于新生代和老年代</strong>、采用标记-整理算法、软实时、低延迟、可设定目标（最大 STW 停顿时间）的垃圾回收器，用于代替 CMS，适用于较大的堆（&gt;4 ~ 6G），在 JDK9 之后默认使用 G1</p>
<p>G1 对比其他处理器的优点：</p>
<ul>
<li>
<p>并发与并行：</p>
<ul>
<li>并行性：G1 在回收期间，可以有多个 GC 线程同时工作，有效利用多核计算能力，此时用户线程 STW</li>
<li>并发性：G1 拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此不会在整个回收阶段发生完全阻塞应用程序的情况</li>
<li>其他的垃圾收集器使用内置的 JVM 线程执行 GC 的多线程操作，而 G1 GC 可以采用应用线程承担后台运行的 GC 工作，JVM 的 GC 线程处理速度慢时，系统会<strong>调用应用程序线程加速垃圾回收</strong>过程</li>
</ul>
</li>
<li>
<p><strong>分区算法</strong>：</p>
<ul>
<li>
<p>从分代上看，G1  属于分代型垃圾回收器，区分年轻代和老年代，年轻代依然有 Eden 区和 Survivor 区。从堆结构上看，<strong>新生代和老年代不再物理隔离</strong>，不用担心每个代内存是否足够，这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次 GC</p>
</li>
<li>
<p>将整个堆划分成约 2048 个大小相同的独立 Region 块，每个 Region 块大小根据堆空间的实际大小而定，整体被控制在 1MB 到 32 MB之间且为 2 的 N 次幂，所有 Region 大小相同，在 JVM 生命周期内不会被改变。G1 把堆划分成多个大小相等的独立区域，使得每个小空间可以单独进行垃圾回收</p>
</li>
<li>
<p><strong>新的区域 Humongous</strong>：本身属于老年代区，当出现了一个巨型对象超出了分区容量的一半，该对象就会进入到该区域。如果一个 H 区装不下一个巨型对象，那么 G1 会寻找连续的 H 分区来存储，为了能找到连续的 H 区，有时候不得不启动 Full GC</p>
</li>
<li>
<p>G1 不会对巨型对象进行拷贝，回收时被优先考虑，G1 会跟踪老年代所有 incoming 引用，这样老年代 incoming 引用为 0 的巨型对象就可以在新生代垃圾回收时处理掉</p>
</li>
<li>
<p>Region 结构图：</p>
</li>
</ul>
</li>
</ul>
<p>​			<img src="/posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/JVM-G1-Region%E5%8C%BA%E5%9F%9F.png"
	width="681"
	height="280"
	srcset="/posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/JVM-G1-Region%E5%8C%BA%E5%9F%9F_huf114de2626066fe03e2f4c8cb0ab4be8_110250_480x0_resize_box_3.png 480w, /posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/JVM-G1-Region%E5%8C%BA%E5%9F%9F_huf114de2626066fe03e2f4c8cb0ab4be8_110250_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="JVM-G1-Region区域"
	
	
		class="gallery-image" 
		data-flex-grow="243"
		data-flex-basis="583px"
	
></p>
<ul>
<li>
<p>空间整合：</p>
<ul>
<li>CMS：标记-清除算法、内存碎片、若干次 GC 后进行一次碎片整理</li>
<li>G1：整体来看是基于标记 - 整理算法实现的收集器，从局部（Region 之间）上来看是基于复制算法实现的，两种算法都可以避免内存碎片</li>
</ul>
</li>
<li>
<p><strong>可预测的停顿时间模型（软实时 soft real-time）</strong>：可以指定在 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒</p>
<ul>
<li>由于分块的原因，G1 可以只选取部分区域进行内存回收，这样缩小了回收的范围，对于全局停顿情况也能得到较好的控制</li>
<li>G1 跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间，通过过去回收的经验获得），在后台维护一个<strong>优先列表</strong>，每次根据允许的收集时间优先回收价值最大的 Region，保证了 G1 收集器在有限的时间内可以获取尽可能高的收集效率</li>
</ul>
<ul>
<li>相比于 CMS GC，G1 未必能做到 CMS 在最好情况下的延时停顿，但是最差情况要好很多</li>
</ul>
</li>
</ul>
<p>G1 垃圾收集器的缺点：</p>
<ul>
<li>相较于 CMS，G1 还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1 无论是为了垃圾收集产生的内存占用还是程序运行时的额外执行负载都要比 CMS 要高</li>
<li>从经验上来说，在小内存应用上 CMS 的表现大概率会优于 G1，而 G1 在大内存应用上则发挥其优势，平衡点在 6-8GB 之间</li>
</ul>
<p>应用场景：</p>
<ul>
<li>面向服务端应用，针对具有大内存、多处理器的机器</li>
<li>需要低 GC 延迟，并具有大堆的应用程序提供解决方案</li>
</ul>
<h5 id="记忆集">记忆集</h5>
<p><em>对象不是孤立的，对象之间会存在跨代引用。</em></p>
<p><img src="/posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/%E8%B7%A8%E4%BB%A3%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98.png"
	width="553"
	height="515"
	srcset="/posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/%E8%B7%A8%E4%BB%A3%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98_hu52035108ac6161466b665188b0e3f286_16386_480x0_resize_box_3.png 480w, /posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/%E8%B7%A8%E4%BB%A3%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98_hu52035108ac6161466b665188b0e3f286_16386_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="跨代引用问题"
	
	
		class="gallery-image" 
		data-flex-grow="107"
		data-flex-basis="257px"
	
></p>
<blockquote>
<p>假如只局限于新生代的收集，那么我们将错误的回收E；若想正确回收，那就需要对老年区同样做一次GC搜索，明显效率低下。</p>
</blockquote>
<p>假如要现在进行一次只局限于新生代区域内的收集（Minor GC），但新生代中的对象是完全有可能被老年代所引用的，为了找出该区域中的存活对象，不得不在固定的GC Roots之外，再额外遍历整个老年代中所有对象来确保可达性分析结果的正确性，反过来也是一样 。遍历整个老年代所有对象 的方案虽然理论上可行，但无疑会为内存回收带来很大的性能负担。</p>
<p>记忆集 Remembered Set 在新生代中，每个 Region 都有一个 Remembered Set，用来被哪些其他 Region 里的对象引用（谁引用了我就记录谁）</p>
<p><img src="/posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/JUC-G1%E8%AE%B0%E5%BF%86%E9%9B%86.png"
	width="906"
	height="412"
	srcset="/posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/JUC-G1%E8%AE%B0%E5%BF%86%E9%9B%86_hu055b6e68b0ca02d5e7ac9c5083acebb0_81130_480x0_resize_box_3.png 480w, /posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/JUC-G1%E8%AE%B0%E5%BF%86%E9%9B%86_hu055b6e68b0ca02d5e7ac9c5083acebb0_81130_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="JUC-G1记忆集"
	
	
		class="gallery-image" 
		data-flex-grow="219"
		data-flex-basis="527px"
	
></p>
<ul>
<li>程序对 Reference 类型数据写操作时，产生一个 Write Barrier 暂时中断操作，检查该对象和 Reference 类型数据是否在不同的 Region（跨代引用），不同就将相关引用信息记录到 Reference 类型所属的 Region 的 Remembered Set 之中</li>
<li>进行内存回收时，在 GC 根节点的枚举范围中加入 Remembered Set 即可保证不对全堆扫描也不会有遗漏</li>
</ul>
<p>垃圾收集器在新生代中建立了记忆集这样的数据结构，可以理解为它是一个抽象类，具体实现记忆集的三种方式：</p>
<ul>
<li>字长精度</li>
<li>对象精度</li>
<li>卡精度(卡表)</li>
</ul>
<p>卡表（Card Table）在老年代中，是一种对记忆集的具体实现，主要定义了记忆集的记录精度、与堆内存的映射关系等，卡表中的每一个元素都对应着一块特定大小的内存块，这个内存块称之为卡页（card page），当存在跨代引用时，会将卡页标记为 dirty，JVM 对于卡页的维护也是通过写屏障的方式</p>
<p>收集集合 CSet 代表每次 GC 暂停时回收的一系列目标分区，在任意一次收集暂停中，CSet 所有分区都会被释放，内部存活的对象都会被转移到分配的空闲分区中。年轻代收集 CSet 只容纳年轻代分区，而混合收集会通过启发式算法，在老年代候选回收分区中，筛选出回收收益最高的分区添加到 CSet 中</p>
<ul>
<li>CSet of Young Collection</li>
<li>CSet of Mix Collection</li>
</ul>
<h5 id="工作原理-1">工作原理</h5>
<p>G1 中提供了三种垃圾回收模式：YoungGC、Mixed GC 和 Full GC，在不同的条件下被触发</p>
<ul>
<li>当堆内存使用达到一定值（默认 45%）时，开始老年代并发标记过程</li>
<li>标记完成马上开始混合回收过程</li>
</ul>
<p><img src="/posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/JVM-G1%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B.png"
	width="1129"
	height="402"
	srcset="/posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/JVM-G1%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B_huecccb4369629cd64422785cf13d275a0_99587_480x0_resize_box_3.png 480w, /posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/JVM-G1%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B_huecccb4369629cd64422785cf13d275a0_99587_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="JVM-G1回收过程"
	
	
		class="gallery-image" 
		data-flex-grow="280"
		data-flex-basis="674px"
	
></p>
<p>顺时针：Young GC → Young GC + Concurrent Mark → Mixed GC 顺序，进行垃圾回收</p>
<ul>
<li>
<p><strong>Young GC</strong>：发生在年轻代的 GC 算法，一般对象（除了巨型对象）都是在 eden region 中分配内存，当所有 eden region 被耗尽无法申请内存时，就会触发一次 Young GC，G1 停止应用程序的执行 STW，把活跃对象放入老年代，垃圾对象回收</p>
<p><strong>回收过程</strong>：</p>
<ol>
<li>扫描根：根引用连同 RSet 记录的外部引用作为扫描存活对象的入口</li>
<li>更新 RSet：处理 dirty card queue 更新 RS，此后 RSet 准确的反映对象的引用关系
<ul>
<li>dirty card queue：类似缓存，产生了引用先记录在这里，然后更新到 RSet</li>
<li>作用：产生引用直接更新 RSet 需要线程同步开销很大，使用队列性能好</li>
</ul>
</li>
<li>处理 RSet：识别被老年代对象指向的 Eden 中的对象，这些被指向的对象被认为是存活的对象，把需要回收的分区放入 Young CSet 中进行回收</li>
<li>复制对象：Eden 区内存段中存活的对象会被复制到 survivor 区，survivor 区内存段中存活的对象如果年龄未达阈值，年龄会加1，达到阀值会被会被复制到 old 区中空的内存分段，如果 survivor 空间不够，Eden 空间的部分数据会直接晋升到老年代空间</li>
<li>处理引用：处理 Soft，Weak，Phantom，JNI Weak  等引用，最终 Eden 空间的数据为空，GC 停止工作</li>
</ol>
</li>
<li>
<p>**Concurrent Mark **：</p>
<ul>
<li>初始标记：标记从根节点直接可达的对象，这个阶段是 STW 的，并且会触发一次年轻代 GC</li>
<li>并发标记 (Concurrent Marking)：在整个堆中进行并发标记（应用程序并发执行），可能被 YoungGC 中断。会计算每个区域的对象活性，即区域中存活对象的比例，若区域中的所有对象都是垃圾，则这个区域会被立即回收（<strong>实时回收</strong>），给浮动垃圾准备出更多的空间，把需要收集的 Region 放入 CSet 当中</li>
<li>最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中，这阶段需要停顿线程，但是可并行执行（<strong>防止漏标</strong>）</li>
<li>筛选回收：并发清理阶段，首先对 CSet 中各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划，也需要 STW</li>
</ul>
<p><img src="/posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/JVM-G1%E6%94%B6%E9%9B%86%E5%99%A8.jpg"
	width="763"
	height="249"
	srcset="/posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/JVM-G1%E6%94%B6%E9%9B%86%E5%99%A8_hub533c5874b46ffc58619fcd23bdf83e7_37888_480x0_resize_q75_box.jpg 480w, /posts/java/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/JVM-G1%E6%94%B6%E9%9B%86%E5%99%A8_hub533c5874b46ffc58619fcd23bdf83e7_37888_1024x0_resize_q75_box.jpg 1024w"
	loading="lazy"
	
		alt="JVM-G1收集器"
	
	
		class="gallery-image" 
		data-flex-grow="306"
		data-flex-basis="735px"
	
></p>
</li>
<li>
<p><strong>Mixed GC</strong>：当很多对象晋升到老年代时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即 Mixed GC，除了回收整个 young region，还会回收一部分的 old region，过程同 YGC</p>
<p>注意：<strong>是一部分老年代，而不是全部老年代</strong>，可以选择哪些老年代 region 收集，对垃圾回收的时间进行控制</p>
<p>在 G1 中，Mixed GC 可以通过 <code>-XX:InitiatingHeapOccupancyPercent</code> 设置阈值</p>
</li>
<li>
<p><strong>Full GC</strong>：对象内存分配速度过快，Mixed GC 来不及回收，导致老年代被填满，就会触发一次 Full GC，G1 的 Full GC 算法就是单线程执行的垃圾回收，会导致异常长时间的暂停时间，需要进行不断的调优，尽可能的避免 Full GC</p>
<p>产生 Full GC 的原因：</p>
<ul>
<li>晋升时没有足够的空间存放晋升的对象</li>
<li>并发处理过程完成之前空间耗尽，浮动垃圾</li>
</ul>
</li>
</ul>
<h5 id="相关参数">相关参数</h5>
<ul>
<li><code>-XX:+UseG1GC</code>：手动指定使用 G1 垃圾收集器执行内存回收任务</li>
<li><code>-XX:G1HeapRegionSize</code>：设置每个 Region 的大小。值是 2 的幂，范围是 1MB 到 32MB 之间，目标是根据最小的 Java 堆大小划分出约 2048 个区域，默认是堆内存的 1/2000</li>
<li><code>-XX:MaxGCPauseMillis</code>：设置期望达到的最大 GC 停顿时间指标，JVM会尽力实现，但不保证达到，默认值是 200ms</li>
<li><code>-XX:+ParallelGcThread</code>：设置 STW 时 GC 线程数的值，最多设置为 8</li>
<li><code>-XX:ConcGCThreads</code>：设置并发标记线程数，设置为并行垃圾回收线程数 ParallelGcThreads 的1/4左右</li>
<li><code>-XX:InitiatingHeapoccupancyPercent</code>：设置触发并发 Mixed GC 周期的 Java 堆占用率阈值，超过此值，就触发 GC，默认值是 45</li>
<li><code>-XX:+ClassUnloadingWithConcurrentMark</code>：并发标记类卸载，默认启用，所有对象都经过并发标记后，就可以知道哪些类不再被使用，当一个类加载器的所有类都不再使用，则卸载它所加载的所有类</li>
<li><code>-XX:G1NewSizePercent</code>：新生代占用整个堆内存的最小百分比（默认5％）</li>
<li><code>-XX:G1MaxNewSizePercent</code>：新生代占用整个堆内存的最大百分比（默认60％）</li>
<li><code>-XX:G1ReservePercent=10</code>：保留内存区域，防止 to space（Survivor中的 to 区）溢出</li>
</ul>
<p><strong>G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.</strong></p>
<p>被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备一下特点：</p>
<ul>
<li><strong>并行与并发</strong>：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。</li>
<li><strong>分代收集</strong>：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。</li>
<li><strong>空间整合</strong>：与 CMS 的“标记-清理”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。</li>
<li><strong>可预测的停顿</strong>：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。</li>
</ul>
<p>G1 收集器的运作大致分为以下几个步骤：</p>
<ul>
<li>
<p><strong>初始标记(Initial Marking)</strong>：这阶段<strong>仅仅只是标记GC Roots能直接关联到的对象并修改TAMS(Next Top at Mark Start)的值</strong>，让下一阶段用户程序并发运行时，能在正确的可用的Region中创建新对象，这阶段<strong>需要停顿线程，但是耗时很短</strong>。而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际并没有额外的停顿。</p>
</li>
<li>
<p><strong>并发标记(Concurrent Marking)</strong>：<strong>从GC Roots开始对堆的对象进行可达性分析，递归扫描整个堆里的对象图，找出存活的对象</strong>，这阶段耗时较长，但是可以与用户程序并发执行。当对象图扫描完成以后，还要<strong>重新处理SATB记录下的在并发时有引用变动的对象。</strong></p>
</li>
<li>
<p><strong>最终标记(Final Marking)</strong>：对用户线程做另一个短暂的暂停，<strong>用于处理并发阶段结束后仍遗留下来的最后那少量的 SATB 记录。</strong></p>
</li>
<li>
<p><strong>筛选回收(Live Data Counting and Evacuation)</strong>：<strong>负责更新 Region 的统计数据，对各个 Region 的回收价值和成本进行排序</strong>，根据用户所期望的停顿时间来制定回收计划。<strong>可以自由选择多个Region来构成回收集，然后把回收的那一部分Region中的存活对象==复制==到空的Region中，在对那些Region进行清空。</strong></p>
<blockquote>
<p>除了并发标记外，其余过程都要 STW</p>
</blockquote>
</li>
</ul>
<p><strong>G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)</strong> 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。</p>
<ol>
<li><strong>不管是G1还是其他分代收集器，JVM都是使用 记忆集(Remembered Set) 来避免全局扫描。</strong></li>
<li><strong>每个Region都有一个对应的记忆集。</strong></li>
<li><strong>每次Reference类型数据写操作时，都会产生一个 写屏障（Write Barrier）暂时去终止操作</strong></li>
<li><strong>然后检查将要写入的引用 指向的对象是否和该Reference类型数据在不同的 Region（其他收集器：检查老年代对象是否引用了新生代对象）</strong></li>
<li><strong>如果不同，通过 卡表（Card Table）把相关引用信息记录到引用指向对象的所在Region对应的记忆集(Remembered Set) 中</strong>，被引用对象记录引用自己的对象，这样被引用对象要可达性分析时候，可以找记忆集中的对象</li>
<li><strong>当进行垃圾收集时，在GC Roots枚举范围加上记忆集；就可以保证不进行全局扫描了。</strong></li>
</ol>
<h2 id="参考">参考</h2>
<ul>
<li>《深入理解 Java 虚拟机：JVM 高级特性与最佳实践（第二版》</li>
<li><a class="link" href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html"  target="_blank" rel="noopener"
    >https://docs.oracle.com/javase/specs/jvms/se8/html/index.html</a></li>
<li>参考文章：https://www.jianshu.com/p/12544c0ad5c1</li>
</ul>

</section>


    <footer class="article-footer">
    
    <section class="article-tags">
        
            <a href="/tags/jvm/">jvm</a>
        
            <a href="/tags/java/">Java</a>
        
    </section>


    </footer>


    
</article>

    

    

<aside class="related-content--wrapper">
    <h2 class="section-title">相关文章</h2>
    <div class="related-content">
        <div class="flex article-list--tile">
            
                
<article class="">
    <a href="/posts/java/jvm-%E7%B1%BB%E5%8A%A0%E8%BD%BD/">
        
        

        <div class="article-details">
            <h2 class="article-title">JVM 类加载</h2>
        </div>
    </a>
</article>

            
                
<article class="">
    <a href="/posts/java/jvm-%E9%94%81%E4%BC%98%E5%8C%96/">
        
        

        <div class="article-details">
            <h2 class="article-title">线程安全与锁优化</h2>
        </div>
    </a>
</article>

            
        </div>
    </div>
</aside>

     
    
        
    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            2020 - 
        
        2022 isheihei&#39;s blog
    </section>
    
    <section class="powerby">
        
            浙ICP备2022017844号 <br/>
        Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <br />
        Theme <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.12.0">Stack</a></b> designed by <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a>
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
    <aside class="sidebar right-sidebar sticky">
        
            
                
    <section class="widget archives">
        <div class="widget-icon">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



        </div>
        <h2 class="widget-title section-title">目录</h2>
        
        <div class="widget--toc">
            <nav id="TableOfContents">
  <ol>
    <li><a href="#可达性分析">可达性分析</a>
      <ol>
        <li><a href="#gc-roots">GC Roots</a></li>
        <li><a href="#工作原理">工作原理</a></li>
        <li><a href="#三色标记">三色标记</a></li>
        <li><a href="#标记算法">标记算法</a></li>
        <li><a href="#并发标记">并发标记</a></li>
      </ol>
    </li>
    <li><a href="#垃圾回收器">垃圾回收器</a>
      <ol>
        <li><a href="#普通">普通</a>
          <ol>
            <li><a href="#serial">Serial</a></li>
            <li><a href="#parnew">ParNew</a></li>
            <li><a href="#parallel">Parallel</a></li>
          </ol>
        </li>
        <li><a href="#并发">并发</a>
          <ol>
            <li><a href="#cms">CMS</a></li>
            <li><a href="#g1-收集器">G1 收集器</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#参考">参考</a></li>
  </ol>
</nav>
        </div>
    </section>

            
        
    </aside>


        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
